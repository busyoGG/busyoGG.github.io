{"meta":{"title":"Busyo's Blog","subtitle":"Busyo 的博客","description":"Busyo 的博客，分享记录与思考","author":"Busyo","url":"https://busyogg.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2023-08-24T10:07:23.840Z","updated":"2023-08-24T10:07:23.840Z","comments":true,"path":"categories/index.html","permalink":"https://busyogg.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-05-31T11:40:49.268Z","updated":"2024-05-31T11:40:49.268Z","comments":true,"path":"script/AfterProcess.js","permalink":"https://busyogg.github.io/script/AfterProcess.js","excerpt":"","text":"window.AfterProcess = { ResetCodeStyle: () => { var eles = document.getElementsByClassName(\"highlight\"); var colors = [\"#ed6a5e\", \"#f5bd4f\", \"#61c454\"]; for (let i = 0, len = eles.length; i < len; i++) { let child = eles[i].firstChild; //创建按钮 let customDiv = document.createElement(\"div\"); customDiv.style.display = \"flex\"; customDiv.style.height = \"40px\"; customDiv.style.width = \"100%\"; for (let j = 0; j < 3; j++) { let btn = document.createElement(\"div\"); btn.style.backgroundColor = colors[j]; btn.style.height = \"20px\"; btn.style.width = \"20px\"; btn.style.border = \"1px solid \" + colors[j]; btn.style.borderRadius = \"10px\"; btn.style.margin = \"10px 5px 10px 5px\"; customDiv.appendChild(btn); } console.log(\"是否匹配\", child.nodeName); if (child.nodeName != \"FIGCAPTION\") { //没有标题 eles[i].insertBefore(customDiv, child); } else { eles[i].replaceChild(customDiv, child); //有标题 let p = document.createElement(\"p\"); p.style.width = customDiv.offsetWidth - 40 * 3 + \"px\"; p.style.height = \"40px\"; p.style.textAlign = \"center\"; p.style.margin = \"0px\"; p.style.lineHeight = \"40px\"; p.innerText = child.firstChild.innerText; p.style.fontSize = \"20px\"; customDiv.appendChild(p); } } }, ResetTitle: () => { let colors = { H1: \"#61c454\", H2: \"#61c454\", H3: \"#f5bd4f\", H4: \"#ed6a5e\", H5: \"#e40056\", H6: \"#029ae2\", }; var eles = document.querySelectorAll(\"h1,h2,h3,h4,h5,h6\"); var picker = window.getComputedStyle; for (let i = 1, len = eles.length; i < len; i++) { let child = eles[i].firstChild; let eleStyle = picker(eles[i]); //创建标识 let customDiv = document.createElement(\"div\"); customDiv.style.display = \"flex\"; customDiv.style.width = \"15px\"; customDiv.style.backgroundColor = colors[eles[i].tagName]; customDiv.style.height = eleStyle.fontSize; customDiv.style.marginRight = \"10px\"; customDiv.style.marginTop = (parseFloat(eleStyle.lineHeight) - parseFloat(eleStyle.fontSize)) * 0.5 + \"px\"; customDiv.style.borderRadius = \"5px\"; // console.log(\"字体大小\",eleStyle.fontSize,parseFloat(eleStyle.lineHeight),parseFloat(eleStyle.fontSize)) // customDiv.style.verticalAlign eles[i].style.display = \"flex\"; eles[i].style.verticalAlign = \"center\"; eles[i].insertBefore(customDiv, child); } }, InitVideo: () => { let videos = document.getElementsByTagName(\"video\"); for (let index = 0; index < videos.length; index++) { let ele = videos[index]; let player = new Plyr(ele, { controls: [ \"play-large\", // The large play button in the center \"play\", // Play/pause playback \"restart\", // Restart playback \"progress\", // The progress bar and scrubber for playback and buffering \"current-time\", // The current time of playback \"duration\", // The full duration of the media \"mute\", // Toggle mute \"volume\", // Volume control \"captions\", // Toggle captions \"settings\", // Settings menu \"pip\", // Picture-in-picture (currently Safari only) \"airplay\", // Airplay (currently Safari only) \"download\", // Show a download button with a link to either the current source or a custom URL you specify in your options \"fullscreen\", // Toggle fullscreen ], }); } // 监听全屏状态变化 document.addEventListener(\"fullscreenchange\", handleFullscreenChange); document.addEventListener(\"webkitfullscreenchange\", handleFullscreenChange); document.addEventListener(\"mozfullscreenchange\", handleFullscreenChange); document.addEventListener(\"MSFullscreenChange\", handleFullscreenChange); function handleFullscreenChange() { var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement; if (fullscreenElement) { // fullscreenStateDiv.textContent = '当前是全屏状态'; for (let index = 0; index < videos.length; index++) { let ele = videos[index]; ele.classList.add(\"full-screen\"); } } else { // fullscreenStateDiv.textContent = '当前不是全屏状态'; for (let index = 0; index < videos.length; index++) { let ele = videos[index]; ele.classList.remove(\"full-screen\"); } } } }, Init: () => { console.log(\"初始化界面\"); AfterProcess.ResetCodeStyle(); AfterProcess.ResetTitle(); AfterProcess.InitVideo(); mermaid.init(undefined, \".mermaid\"); }, }; AfterProcess.Init();"},{"title":"","date":"2024-06-01T08:34:42.897Z","updated":"2024-06-01T08:34:42.897Z","comments":true,"path":"script/HomeScript.js","permalink":"https://busyogg.github.io/script/HomeScript.js","excerpt":"","text":"window.HomeScript = { InitCard: () => { var targetDiv = document.getElementsByClassName(\"post-wrapper\"); for (var i = 0; i < targetDiv.length; i++) { var element = targetDiv[i]; element.classList.add(\"card-ani\"); var targetDivTop = element.getBoundingClientRect().top; if (targetDivTop < window.innerHeight + 260) { // 当目标div进入视口时，添加动画效果 // element.classList.add(\"animated\"); element.classList.add(\"card-in\"); } else { // 当目标div离开视口时，移除动画效果 // element.classList.remove(\"animated\"); element.classList.remove(\"card-in\"); } } }, CardAni: () => { var targetDiv = document.getElementsByClassName(\"post-wrapper\"); for (var i = 0; i < targetDiv.length; i++) { var element = targetDiv[i]; var targetDivTop = element.getBoundingClientRect().top; // if (targetDivTop < window.innerHeight) { // // 当目标div进入视口时，添加动画效果 // // element.classList.add(\"animated\"); // element.classList.add(\"card-in\"); // } else { // // 当目标div离开视口时，移除动画效果 // // element.classList.remove(\"animated\"); // element.classList.remove(\"card-in\"); // } if (targetDivTop >= window.innerHeight) { element.classList.remove(\"card-in\"); } else { element.classList.add(\"card-in\"); } } }, Init: () => { HomeScript.InitCard(); window.removeEventListener(\"scroll\", HomeScript.CardAni); window.addEventListener(\"scroll\", HomeScript.CardAni); }, }; HomeScript.Init();"},{"title":"","date":"2024-06-01T09:08:33.097Z","updated":"2024-06-01T09:08:33.097Z","comments":true,"path":"script/NavBarScript.js","permalink":"https://busyogg.github.io/script/NavBarScript.js","excerpt":"","text":"window.NavBarScript = { obj: null, InitLock: () => { var isLock = localStorage.getItem(\"isLock\") || false; var ele = document.getElementsByClassName(\"head-bar\")[0]; var head = document.getElementsByClassName(\"l_header\")[0]; if (isLock == \"true\") { ele.classList.remove(\"head-bar-hover\"); head.classList.remove(\"l_header-hover\"); ele.classList.add(\"head-bar-focus\"); obj.innerHTML = \"🔒\"; } else { ele.classList.add(\"head-bar-hover\"); head.classList.add(\"l_header-hover\"); ele.classList.remove(\"head-bar-focus\"); obj.innerHTML = \"🔓\"; } console.log(\"初始化\", isLock); }, ChangeLock: () => { var isLock = localStorage.getItem(\"isLock\") || false; console.log(\"切换\"); var ele = document.getElementsByClassName(\"head-bar\")[0]; var head = document.getElementsByClassName(\"l_header\")[0]; if (isLock == \"false\") { ele.classList.remove(\"head-bar-hover\"); head.classList.remove(\"l_header-hover\"); ele.classList.add(\"head-bar-focus\"); obj.innerHTML = \"🔒\"; } else { ele.classList.add(\"head-bar-hover\"); head.classList.add(\"l_header-hover\"); ele.classList.remove(\"head-bar-focus\"); obj.innerHTML = \"🔓\"; } isLock = isLock == \"false\" ? \"true\" : \"false\"; console.log(isLock); localStorage.setItem(\"isLock\", isLock); }, Init: () => { obj = document.getElementsByClassName(\"lock-emoji\")[0]; NavBarScript.InitLock(); obj.addEventListener(\"click\", () => { NavBarScript.ChangeLock(); }); }, }; NavBarScript.Init();"},{"title":"","date":"2023-08-31T17:58:45.623Z","updated":"2023-08-31T17:58:45.623Z","comments":true,"path":"script/marked.min.js","permalink":"https://busyogg.github.io/script/marked.min.js","excerpt":"","text":"/** * marked v4.3.0 - a markdown parser * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed) * https://github.com/markedjs/marked */ !function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=\"undefined\"!=typeof globalThis?globalThis:e||self).marked={})}(this,function(r){\"use strict\";function i(e,t){for(var u=0;u"},{"title":"所有标签","date":"2023-08-24T10:08:12.138Z","updated":"2023-08-24T10:08:12.138Z","comments":true,"path":"tags/index.html","permalink":"https://busyogg.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-01-29T17:35:51.351Z","updated":"2024-01-29T17:35:51.351Z","comments":true,"path":"script/plyr.js","permalink":"https://busyogg.github.io/script/plyr.js","excerpt":"","text":"\"object\"==typeof navigator&&function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"Plyr\",t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).Plyr=t()}(this,(function(){\"use strict\";!function(){if(\"undefined\"!=typeof window)try{var e=new window.CustomEvent(\"test\",{cancelable:!0});if(e.preventDefault(),!0!==e.defaultPrevented)throw new Error(\"Could not prevent default\")}catch(e){var t=function(e,t){var i,s;return(t=t||{}).bubbles=!!t.bubbles,t.cancelable=!!t.cancelable,(i=document.createEvent(\"CustomEvent\")).initCustomEvent(e,t.bubbles,t.cancelable,t.detail),s=i.preventDefault,i.preventDefault=function(){s.call(this);try{Object.defineProperty(this,\"defaultPrevented\",{get:function(){return!0}})}catch(e){this.defaultPrevented=!0}},i};t.prototype=window.Event.prototype,window.CustomEvent=t}}();var e=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};function t(e,t,i){return(t=function(e){var t=function(e,t){if(\"object\"!=typeof e||null===e)return e;var i=e[Symbol.toPrimitive];if(void 0!==i){var s=i.call(e,t||\"default\");if(\"object\"!=typeof s)return s;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===t?String:Number)(e)}(e,\"string\");return\"symbol\"==typeof t?t:String(t)}(t))in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function i(e,t){for(var i=0;i\"function\"==typeof e,E=e=>Array.isArray(e),C=e=>b(e,NodeList),S=e=>v(e)||(T(e)||E(e)||C(e))&&!e.length||w(e)&&!Object.keys(e).length;var A={nullOrUndefined:v,object:w,number:e=>y(e)===Number&&!Number.isNaN(e),string:T,boolean:e=>y(e)===Boolean,function:k,array:E,weakMap:e=>b(e,WeakMap),nodeList:C,element:e=>null!==e&&\"object\"==typeof e&&1===e.nodeType&&\"object\"==typeof e.style&&\"object\"==typeof e.ownerDocument,textNode:e=>y(e)===Text,event:e=>b(e,Event),keyboardEvent:e=>b(e,KeyboardEvent),cue:e=>b(e,window.TextTrackCue)||b(e,window.VTTCue),track:e=>b(e,TextTrack)||!v(e)&&T(e.kind),promise:e=>b(e,Promise)&&k(e.then),url:e=>{if(b(e,window.URL))return!0;if(!T(e))return!1;let t=e;e.startsWith(\"http://\")&&e.startsWith(\"https://\")||(t=`http://${e}`);try{return!S(new URL(t).hostname)}catch(e){return!1}},empty:S};const P=(()=>{const e=document.createElement(\"span\"),t={WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"oTransitionEnd otransitionend\",transition:\"transitionend\"},i=Object.keys(t).find((t=>void 0!==e.style[t]));return!!A.string(i)&&t[i]})();function M(e,t){setTimeout((()=>{try{e.hidden=!0,e.offsetHeight,e.hidden=!1}catch(e){}}),t)}var x={isIE:Boolean(window.document.documentMode),isEdge:/Edge/g.test(navigator.userAgent),isWebKit:\"WebkitAppearance\"in document.documentElement.style&&!/Edge/g.test(navigator.userAgent),isIPhone:/iPhone|iPod/gi.test(navigator.userAgent)&&navigator.maxTouchPoints>1,isIPadOS:\"MacIntel\"===navigator.platform&&navigator.maxTouchPoints>1,isIos:/iPad|iPhone|iPod/gi.test(navigator.userAgent)&&navigator.maxTouchPoints>1};function L(e,t){return t.split(\".\").reduce(((e,t)=>e&&e[t]),e)}function N(e={},...t){if(!t.length)return e;const i=t.shift();return A.object(i)?(Object.keys(i).forEach((t=>{A.object(i[t])?(Object.keys(e).includes(t)||Object.assign(e,{[t]:{}}),N(e[t],i[t])):Object.assign(e,{[t]:i[t]})})),N(e,...t)):e}function _(e,t){const i=e.length?e:[e];Array.from(i).reverse().forEach(((e,i)=>{const s=i>0?t.cloneNode(!0):t,n=e.parentNode,a=e.nextSibling;s.appendChild(e),a?n.insertBefore(s,a):n.appendChild(s)}))}function I(e,t){A.element(e)&&!A.empty(t)&&Object.entries(t).filter((([,e])=>!A.nullOrUndefined(e))).forEach((([t,i])=>e.setAttribute(t,i)))}function O(e,t,i){const s=document.createElement(e);return A.object(t)&&I(s,t),A.string(i)&&(s.innerText=i),s}function $(e,t,i,s){A.element(t)&&t.appendChild(O(e,i,s))}function j(e){A.nodeList(e)||A.array(e)?Array.from(e).forEach(j):A.element(e)&&A.element(e.parentNode)&&e.parentNode.removeChild(e)}function R(e){if(!A.element(e))return;let{length:t}=e.childNodes;for(;t>0;)e.removeChild(e.lastChild),t-=1}function D(e,t){return A.element(t)&&A.element(t.parentNode)&&A.element(e)?(t.parentNode.replaceChild(e,t),e):null}function q(e,t){if(!A.string(e)||A.empty(e))return{};const i={},s=N({},t);return e.split(\",\").forEach((e=>{const t=e.trim(),n=t.replace(\".\",\"\"),a=t.replace(/[[\\]]/g,\"\").split(\"=\"),[r]=a,o=a.length>1?a[1].replace(/[\"']/g,\"\"):\"\";switch(t.charAt(0)){case\".\":A.string(s.class)?i.class=`${s.class} ${n}`:i.class=n;break;case\"#\":i.id=t.replace(\"#\",\"\");break;case\"[\":i[r]=o}})),N(s,i)}function H(e,t){if(!A.element(e))return;let i=t;A.boolean(i)||(i=!e.hidden),e.hidden=i}function F(e,t,i){if(A.nodeList(e))return Array.from(e).map((e=>F(e,t,i)));if(A.element(e)){let s=\"toggle\";return void 0!==i&&(s=i?\"add\":\"remove\"),e.classList[s](t),e.classList.contains(t)}return!1}function U(e,t){return A.element(e)&&e.classList.contains(t)}function V(e,t){const{prototype:i}=Element;return(i.matches||i.webkitMatchesSelector||i.mozMatchesSelector||i.msMatchesSelector||function(){return Array.from(document.querySelectorAll(t)).includes(this)}).call(e,t)}function B(e){return this.elements.container.querySelectorAll(e)}function W(e){return this.elements.container.querySelector(e)}function z(e=null,t=!1){A.element(e)&&e.focus({preventScroll:!0,focusVisible:t})}const K={\"audio/ogg\":\"vorbis\",\"audio/wav\":\"1\",\"video/webm\":\"vp8, vorbis\",\"video/mp4\":\"avc1.42E01E, mp4a.40.2\",\"video/ogg\":\"theora\"},Y={audio:\"canPlayType\"in document.createElement(\"audio\"),video:\"canPlayType\"in document.createElement(\"video\"),check(e,t){const i=Y[e]||\"html5\"!==t;return{api:i,ui:i&&Y.rangeInput}},pip:!(x.isIPhone||!A.function(O(\"video\").webkitSetPresentationMode)&&(!document.pictureInPictureEnabled||O(\"video\").disablePictureInPicture)),airplay:A.function(window.WebKitPlaybackTargetAvailabilityEvent),playsinline:\"playsInline\"in document.createElement(\"video\"),mime(e){if(A.empty(e))return!1;const[t]=e.split(\"/\");let i=e;if(!this.isHTML5||t!==this.type)return!1;Object.keys(K).includes(i)&&(i+=`; codecs=\"${K[e]}\"`);try{return Boolean(i&&this.media.canPlayType(i).replace(/no/,\"\"))}catch(e){return!1}},textTracks:\"textTracks\"in document.createElement(\"video\"),rangeInput:(()=>{const e=document.createElement(\"input\");return e.type=\"range\",\"range\"===e.type})(),touch:\"ontouchstart\"in document.documentElement,transitions:!1!==P,reducedMotion:\"matchMedia\"in window&&window.matchMedia(\"(prefers-reduced-motion)\").matches},Q=(()=>{let e=!1;try{const t=Object.defineProperty({},\"passive\",{get:()=>(e=!0,null)});window.addEventListener(\"test\",null,t),window.removeEventListener(\"test\",null,t)}catch(e){}return e})();function X(e,t,i,s=!1,n=!0,a=!1){if(!e||!(\"addEventListener\"in e)||A.empty(t)||!A.function(i))return;const r=t.split(\" \");let o=a;Q&&(o={passive:n,capture:a}),r.forEach((t=>{this&&this.eventListeners&&s&&this.eventListeners.push({element:e,type:t,callback:i,options:o}),e[s?\"addEventListener\":\"removeEventListener\"](t,i,o)}))}function J(e,t=\"\",i,s=!0,n=!1){X.call(this,e,t,i,!0,s,n)}function G(e,t=\"\",i,s=!0,n=!1){X.call(this,e,t,i,!1,s,n)}function Z(e,t=\"\",i,s=!0,n=!1){const a=(...r)=>{G(e,t,a,s,n),i.apply(this,r)};X.call(this,e,t,a,!0,s,n)}function ee(e,t=\"\",i=!1,s={}){if(!A.element(e)||A.empty(t))return;const n=new CustomEvent(t,{bubbles:i,detail:{...s,plyr:this}});e.dispatchEvent(n)}function te(){this&&this.eventListeners&&(this.eventListeners.forEach((e=>{const{element:t,type:i,callback:s,options:n}=e;t.removeEventListener(i,s,n)})),this.eventListeners=[])}function ie(){return new Promise((e=>this.ready?setTimeout(e,0):J.call(this,this.elements.container,\"ready\",e))).then((()=>{}))}function se(e){A.promise(e)&&e.then(null,(()=>{}))}function ne(e){return A.array(e)?e.filter(((t,i)=>e.indexOf(t)===i)):e}function ae(e,t){return A.array(e)&&e.length?e.reduce(((e,i)=>Math.abs(i-t)({...e,[t/i]:[t,i]})),{});function le(e){if(!(A.array(e)||A.string(e)&&e.includes(\":\")))return!1;return(A.array(e)?e:e.split(\":\")).map(Number).every(A.number)}function ce(e){if(!A.array(e)||!e.every(A.number))return null;const[t,i]=e,s=(e,t)=>0===t?e:s(t,e%t),n=s(t,i);return[t/n,i/n]}function ue(e){const t=e=>le(e)?e.split(\":\").map(Number):null;let i=t(e);if(null===i&&(i=t(this.config.ratio)),null===i&&!A.empty(this.embed)&&A.array(this.embed.ratio)&&({ratio:i}=this.embed),null===i&&this.isHTML5){const{videoWidth:e,videoHeight:t}=this.media;i=[e,t]}return ce(i)}function he(e){if(!this.isVideo)return{};const{wrapper:t}=this.elements,i=ue.call(this,e);if(!A.array(i))return{};const[s,n]=ce(i),a=100/s*n;if(re(`aspect-ratio: ${s}/${n}`)?t.style.aspectRatio=`${s}/${n}`:t.style.paddingBottom=`${a}%`,this.isVimeo&&!this.config.vimeo.premium&&this.supported.ui){const e=100/this.media.offsetWidth*parseInt(window.getComputedStyle(this.media).paddingBottom,10),i=(e-a)/(e/50);this.fullscreen.active?t.style.paddingBottom=null:this.media.style.transform=`translateY(-${i}%)`}else this.isHTML5&&t.classList.add(this.config.classNames.videoFixedRatio);return{padding:a,ratio:i}}function de(e,t,i=.05){const s=e/t,n=ae(Object.keys(oe),s);return Math.abs(n-s){const t=e.getAttribute(\"type\");return!!A.empty(t)||Y.mime.call(this,t)}))},getQualityOptions(){return this.config.quality.forced?this.config.quality.options:me.getSources.call(this).map((e=>Number(e.getAttribute(\"size\")))).filter(Boolean)},setup(){if(!this.isHTML5)return;const e=this;e.options.speed=e.config.speed.options,A.empty(this.config.ratio)||he.call(e),Object.defineProperty(e.media,\"quality\",{get(){const t=me.getSources.call(e).find((t=>t.getAttribute(\"src\")===e.source));return t&&Number(t.getAttribute(\"size\"))},set(t){if(e.quality!==t){if(e.config.quality.forced&&A.function(e.config.quality.onChange))e.config.quality.onChange(t);else{const i=me.getSources.call(e).find((e=>Number(e.getAttribute(\"size\"))===t));if(!i)return;const{currentTime:s,paused:n,preload:a,readyState:r,playbackRate:o}=e.media;e.media.src=i.getAttribute(\"src\"),(\"none\"!==a||r)&&(e.once(\"loadedmetadata\",(()=>{e.speed=o,e.currentTime=s,n||se(e.play())})),e.media.load())}ee.call(e,e.media,\"qualitychange\",!1,{quality:t})}}})},cancelRequests(){this.isHTML5&&(j(me.getSources.call(this)),this.media.setAttribute(\"src\",this.config.blankVideo),this.media.load(),this.debug.log(\"Cancelled network requests\"))}};function pe(e,...t){return A.empty(e)?e:e.toString().replace(/{(\\d+)}/g,((e,i)=>t[i].toString()))}const ge=(e=\"\",t=\"\",i=\"\")=>e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g,\"\\\\$1\"),\"g\"),i.toString()),fe=(e=\"\")=>e.toString().replace(/\\w\\S*/g,(e=>e.charAt(0).toUpperCase()+e.slice(1).toLowerCase()));function ye(e=\"\"){let t=e.toString();return t=function(e=\"\"){let t=e.toString();return t=ge(t,\"-\",\" \"),t=ge(t,\"_\",\" \"),t=fe(t),ge(t,\" \",\"\")}(t),t.charAt(0).toLowerCase()+t.slice(1)}function be(e){const t=document.createElement(\"div\");return t.appendChild(e),t.innerHTML}const ve={pip:\"PIP\",airplay:\"AirPlay\",html5:\"HTML5\",vimeo:\"Vimeo\",youtube:\"YouTube\"},we={get(e=\"\",t={}){if(A.empty(e)||A.empty(t))return\"\";let i=L(t.i18n,e);if(A.empty(i))return Object.keys(ve).includes(e)?ve[e]:\"\";const s={\"{seektime}\":t.seekTime,\"{title}\":t.title};return Object.entries(s).forEach((([e,t])=>{i=ge(i,e,t)})),i}};class Te{constructor(e){t(this,\"get\",(e=>{if(!Te.supported||!this.enabled)return null;const t=window.localStorage.getItem(this.key);if(A.empty(t))return null;const i=JSON.parse(t);return A.string(e)&&e.length?i[e]:i})),t(this,\"set\",(e=>{if(!Te.supported||!this.enabled)return;if(!A.object(e))return;let t=this.get();A.empty(t)&&(t={}),N(t,e);try{window.localStorage.setItem(this.key,JSON.stringify(t))}catch(e){}})),this.enabled=e.config.storage.enabled,this.key=e.config.storage.key}static get supported(){try{if(!(\"localStorage\"in window))return!1;const e=\"___test\";return window.localStorage.setItem(e,e),window.localStorage.removeItem(e),!0}catch(e){return!1}}}function ke(e,t=\"text\"){return new Promise(((i,s)=>{try{const s=new XMLHttpRequest;if(!(\"withCredentials\"in s))return;s.addEventListener(\"load\",(()=>{if(\"text\"===t)try{i(JSON.parse(s.responseText))}catch(e){i(s.responseText)}else i(s.response)})),s.addEventListener(\"error\",(()=>{throw new Error(s.status)})),s.open(\"GET\",e,!0),s.responseType=t,s.send()}catch(e){s(e)}}))}function Ee(e,t){if(!A.string(e))return;const i=\"cache\",s=A.string(t);let n=!1;const a=()=>null!==document.getElementById(t),r=(e,t)=>{e.innerHTML=t,s&&a()||document.body.insertAdjacentElement(\"afterbegin\",e)};if(!s||!a()){const a=Te.supported,o=document.createElement(\"div\");if(o.setAttribute(\"hidden\",\"\"),s&&o.setAttribute(\"id\",t),a){const e=window.localStorage.getItem(`${i}-${t}`);if(n=null!==e,n){const t=JSON.parse(e);r(o,t.content)}}ke(e).then((e=>{if(!A.empty(e)){if(a)try{window.localStorage.setItem(`${i}-${t}`,JSON.stringify({content:e}))}catch(e){}r(o,e)}})).catch((()=>{}))}}const Ce=e=>Math.trunc(e/60/60%60,10),Se=e=>Math.trunc(e/60%60,10),Ae=e=>Math.trunc(e%60,10);function Pe(e=0,t=!1,i=!1){if(!A.number(e))return Pe(void 0,t,i);const s=e=>`0${e}`.slice(-2);let n=Ce(e);const a=Se(e),r=Ae(e);return n=t||n>0?`${n}:`:\"\",`${i&&e>0?\"-\":\"\"}${n}${s(a)}:${s(r)}`}const Me={getIconUrl(){const e=new URL(this.config.iconUrl,window.location),t=window.location.host?window.location.host:window.top.location.host,i=e.host!==t||x.isIE&&!window.svg4everybody;return{url:this.config.iconUrl,cors:i}},findElements(){try{return this.elements.controls=W.call(this,this.config.selectors.controls.wrapper),this.elements.buttons={play:B.call(this,this.config.selectors.buttons.play),pause:W.call(this,this.config.selectors.buttons.pause),restart:W.call(this,this.config.selectors.buttons.restart),rewind:W.call(this,this.config.selectors.buttons.rewind),fastForward:W.call(this,this.config.selectors.buttons.fastForward),mute:W.call(this,this.config.selectors.buttons.mute),pip:W.call(this,this.config.selectors.buttons.pip),airplay:W.call(this,this.config.selectors.buttons.airplay),settings:W.call(this,this.config.selectors.buttons.settings),captions:W.call(this,this.config.selectors.buttons.captions),fullscreen:W.call(this,this.config.selectors.buttons.fullscreen)},this.elements.progress=W.call(this,this.config.selectors.progress),this.elements.inputs={seek:W.call(this,this.config.selectors.inputs.seek),volume:W.call(this,this.config.selectors.inputs.volume)},this.elements.display={buffer:W.call(this,this.config.selectors.display.buffer),currentTime:W.call(this,this.config.selectors.display.currentTime),duration:W.call(this,this.config.selectors.display.duration)},A.element(this.elements.progress)&&(this.elements.display.seekTooltip=this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)),!0}catch(e){return this.debug.warn(\"It looks like there is a problem with your custom controls HTML\",e),this.toggleNativeControls(!0),!1}},createIcon(e,t){const i=\"http://www.w3.org/2000/svg\",s=Me.getIconUrl.call(this),n=`${s.cors?\"\":s.url}#${this.config.iconPrefix}`,a=document.createElementNS(i,\"svg\");I(a,N(t,{\"aria-hidden\":\"true\",focusable:\"false\"}));const r=document.createElementNS(i,\"use\"),o=`${n}-${e}`;return\"href\"in r&&r.setAttributeNS(\"http://www.w3.org/1999/xlink\",\"href\",o),r.setAttributeNS(\"http://www.w3.org/1999/xlink\",\"xlink:href\",o),a.appendChild(r),a},createLabel(e,t={}){const i=we.get(e,this.config);return O(\"span\",{...t,class:[t.class,this.config.classNames.hidden].filter(Boolean).join(\" \")},i)},createBadge(e){if(A.empty(e))return null;const t=O(\"span\",{class:this.config.classNames.menu.value});return t.appendChild(O(\"span\",{class:this.config.classNames.menu.badge},e)),t},createButton(e,t){const i=N({},t);let s=ye(e);const n={element:\"button\",toggle:!1,label:null,icon:null,labelPressed:null,iconPressed:null};switch([\"element\",\"icon\",\"label\"].forEach((e=>{Object.keys(i).includes(e)&&(n[e]=i[e],delete i[e])})),\"button\"!==n.element||Object.keys(i).includes(\"type\")||(i.type=\"button\"),Object.keys(i).includes(\"class\")?i.class.split(\" \").some((e=>e===this.config.classNames.control))||N(i,{class:`${i.class} ${this.config.classNames.control}`}):i.class=this.config.classNames.control,e){case\"play\":n.toggle=!0,n.label=\"play\",n.labelPressed=\"pause\",n.icon=\"play\",n.iconPressed=\"pause\";break;case\"mute\":n.toggle=!0,n.label=\"mute\",n.labelPressed=\"unmute\",n.icon=\"volume\",n.iconPressed=\"muted\";break;case\"captions\":n.toggle=!0,n.label=\"enableCaptions\",n.labelPressed=\"disableCaptions\",n.icon=\"captions-off\",n.iconPressed=\"captions-on\";break;case\"fullscreen\":n.toggle=!0,n.label=\"enterFullscreen\",n.labelPressed=\"exitFullscreen\",n.icon=\"enter-fullscreen\",n.iconPressed=\"exit-fullscreen\";break;case\"play-large\":i.class+=` ${this.config.classNames.control}--overlaid`,s=\"play\",n.label=\"play\",n.icon=\"play\";break;default:A.empty(n.label)&&(n.label=s),A.empty(n.icon)&&(n.icon=e)}const a=O(n.element);return n.toggle?(a.appendChild(Me.createIcon.call(this,n.iconPressed,{class:\"icon--pressed\"})),a.appendChild(Me.createIcon.call(this,n.icon,{class:\"icon--not-pressed\"})),a.appendChild(Me.createLabel.call(this,n.labelPressed,{class:\"label--pressed\"})),a.appendChild(Me.createLabel.call(this,n.label,{class:\"label--not-pressed\"}))):(a.appendChild(Me.createIcon.call(this,n.icon)),a.appendChild(Me.createLabel.call(this,n.label))),N(i,q(this.config.selectors.buttons[s],i)),I(a,i),\"play\"===s?(A.array(this.elements.buttons[s])||(this.elements.buttons[s]=[]),this.elements.buttons[s].push(a)):this.elements.buttons[s]=a,a},createRange(e,t){const i=O(\"input\",N(q(this.config.selectors.inputs[e]),{type:\"range\",min:0,max:100,step:.01,value:0,autocomplete:\"off\",role:\"slider\",\"aria-label\":we.get(e,this.config),\"aria-valuemin\":0,\"aria-valuemax\":100,\"aria-valuenow\":0},t));return this.elements.inputs[e]=i,Me.updateRangeFill.call(this,i),f.setup(i),i},createProgress(e,t){const i=O(\"progress\",N(q(this.config.selectors.display[e]),{min:0,max:100,value:0,role:\"progressbar\",\"aria-hidden\":!0},t));if(\"volume\"!==e){i.appendChild(O(\"span\",null,\"0\"));const t={played:\"played\",buffer:\"buffered\"}[e],s=t?we.get(t,this.config):\"\";i.innerText=`% ${s.toLowerCase()}`}return this.elements.display[e]=i,i},createTime(e,t){const i=q(this.config.selectors.display[e],t),s=O(\"div\",N(i,{class:`${i.class?i.class:\"\"} ${this.config.classNames.display.time} `.trim(),\"aria-label\":we.get(e,this.config),role:\"timer\"}),\"00:00\");return this.elements.display[e]=s,s},bindMenuItemShortcuts(e,t){J.call(this,e,\"keydown keyup\",(i=>{if(![\" \",\"ArrowUp\",\"ArrowDown\",\"ArrowRight\"].includes(i.key))return;if(i.preventDefault(),i.stopPropagation(),\"keydown\"===i.type)return;const s=V(e,'[role=\"menuitemradio\"]');if(!s&&[\" \",\"ArrowRight\"].includes(i.key))Me.showMenuPanel.call(this,t,!0);else{let t;\" \"!==i.key&&(\"ArrowDown\"===i.key||s&&\"ArrowRight\"===i.key?(t=e.nextElementSibling,A.element(t)||(t=e.parentNode.firstElementChild)):(t=e.previousElementSibling,A.element(t)||(t=e.parentNode.lastElementChild)),z.call(this,t,!0))}}),!1),J.call(this,e,\"keyup\",(e=>{\"Return\"===e.key&&Me.focusFirstMenuItem.call(this,null,!0)}))},createMenuItem({value:e,list:t,type:i,title:s,badge:n=null,checked:a=!1}){const r=q(this.config.selectors.inputs[i]),o=O(\"button\",N(r,{type:\"button\",role:\"menuitemradio\",class:`${this.config.classNames.control} ${r.class?r.class:\"\"}`.trim(),\"aria-checked\":a,value:e})),l=O(\"span\");l.innerHTML=s,A.element(n)&&l.appendChild(n),o.appendChild(l),Object.defineProperty(o,\"checked\",{enumerable:!0,get:()=>\"true\"===o.getAttribute(\"aria-checked\"),set(e){e&&Array.from(o.parentNode.children).filter((e=>V(e,'[role=\"menuitemradio\"]'))).forEach((e=>e.setAttribute(\"aria-checked\",\"false\"))),o.setAttribute(\"aria-checked\",e?\"true\":\"false\")}}),this.listeners.bind(o,\"click keyup\",(t=>{if(!A.keyboardEvent(t)||\" \"===t.key){switch(t.preventDefault(),t.stopPropagation(),o.checked=!0,i){case\"language\":this.currentTrack=Number(e);break;case\"quality\":this.quality=e;break;case\"speed\":this.speed=parseFloat(e)}Me.showMenuPanel.call(this,\"home\",A.keyboardEvent(t))}}),i,!1),Me.bindMenuItemShortcuts.call(this,o,i),t.appendChild(o)},formatTime(e=0,t=!1){if(!A.number(e))return e;return Pe(e,Ce(this.duration)>0,t)},updateTimeDisplay(e=null,t=0,i=!1){A.element(e)&&A.number(t)&&(e.innerText=Me.formatTime(t,i))},updateVolume(){this.supported.ui&&(A.element(this.elements.inputs.volume)&&Me.setRange.call(this,this.elements.inputs.volume,this.muted?0:this.volume),A.element(this.elements.buttons.mute)&&(this.elements.buttons.mute.pressed=this.muted||0===this.volume))},setRange(e,t=0){A.element(e)&&(e.value=t,Me.updateRangeFill.call(this,e))},updateProgress(e){if(!this.supported.ui||!A.event(e))return;let t=0;const i=(e,t)=>{const i=A.number(t)?t:0,s=A.element(e)?e:this.elements.display.buffer;if(A.element(s)){s.value=i;const e=s.getElementsByTagName(\"span\")[0];A.element(e)&&(e.childNodes[0].nodeValue=i)}};if(e)switch(e.type){case\"timeupdate\":case\"seeking\":case\"seeked\":s=this.currentTime,n=this.duration,t=0===s||0===n||Number.isNaN(s)||Number.isNaN(n)?0:(s/n*100).toFixed(2),\"timeupdate\"===e.type&&Me.setRange.call(this,this.elements.inputs.seek,t);break;case\"playing\":case\"progress\":i(this.elements.display.buffer,100*this.buffered)}var s,n},updateRangeFill(e){const t=A.event(e)?e.target:e;if(A.element(t)&&\"range\"===t.getAttribute(\"type\")){if(V(t,this.config.selectors.inputs.seek)){t.setAttribute(\"aria-valuenow\",this.currentTime);const e=Me.formatTime(this.currentTime),i=Me.formatTime(this.duration),s=we.get(\"seekLabel\",this.config);t.setAttribute(\"aria-valuetext\",s.replace(\"{currentTime}\",e).replace(\"{duration}\",i))}else if(V(t,this.config.selectors.inputs.volume)){const e=100*t.value;t.setAttribute(\"aria-valuenow\",e),t.setAttribute(\"aria-valuetext\",`${e.toFixed(1)}%`)}else t.setAttribute(\"aria-valuenow\",t.value);(x.isWebKit||x.isIPadOS)&&t.style.setProperty(\"--value\",t.value/t.max*100+\"%\")}},updateSeekTooltip(e){var t,i;if(!this.config.tooltips.seek||!A.element(this.elements.inputs.seek)||!A.element(this.elements.display.seekTooltip)||0===this.duration)return;const s=this.elements.display.seekTooltip,n=`${this.config.classNames.tooltip}--visible`,a=e=>F(s,n,e);if(this.touch)return void a(!1);let r=0;const o=this.elements.progress.getBoundingClientRect();if(A.event(e))r=100/o.width*(e.pageX-o.left);else{if(!U(s,n))return;r=parseFloat(s.style.left,10)}r100&&(r=100);const l=this.duration/100*r;s.innerText=Me.formatTime(l);const c=null===(t=this.config.markers)||void 0===t||null===(i=t.points)||void 0===i?void 0:i.find((({time:e})=>e===Math.round(l)));c&&s.insertAdjacentHTML(\"afterbegin\",`${c.label}`),s.style.left=`${r}%`,A.event(e)&&[\"mouseenter\",\"mouseleave\"].includes(e.type)&&a(\"mouseenter\"===e.type)},timeUpdate(e){const t=!A.element(this.elements.display.duration)&&this.config.invertTime;Me.updateTimeDisplay.call(this,this.elements.display.currentTime,t?this.duration-this.currentTime:this.currentTime,t),e&&\"timeupdate\"===e.type&&this.media.seeking||Me.updateProgress.call(this,e)},durationUpdate(){if(!this.supported.ui||!this.config.invertTime&&this.currentTime)return;if(this.duration>=2**32)return H(this.elements.display.currentTime,!0),void H(this.elements.progress,!0);A.element(this.elements.inputs.seek)&&this.elements.inputs.seek.setAttribute(\"aria-valuemax\",this.duration);const e=A.element(this.elements.display.duration);!e&&this.config.displayDuration&&this.paused&&Me.updateTimeDisplay.call(this,this.elements.display.currentTime,this.duration),e&&Me.updateTimeDisplay.call(this,this.elements.display.duration,this.duration),this.config.markers.enabled&&Me.setMarkers.call(this),Me.updateSeekTooltip.call(this)},toggleMenuButton(e,t){H(this.elements.settings.buttons[e],!t)},updateSetting(e,t,i){const s=this.elements.settings.panels[e];let n=null,a=t;if(\"captions\"===e)n=this.currentTrack;else{if(n=A.empty(i)?this[e]:i,A.empty(n)&&(n=this.config[e].default),!A.empty(this.options[e])&&!this.options[e].includes(n))return void this.debug.warn(`Unsupported value of '${n}' for ${e}`);if(!this.config[e].options.includes(n))return void this.debug.warn(`Disabled value of '${n}' for ${e}`)}if(A.element(a)||(a=s&&s.querySelector('[role=\"menu\"]')),!A.element(a))return;this.elements.settings.buttons[e].querySelector(`.${this.config.classNames.menu.value}`).innerHTML=Me.getLabel.call(this,e,n);const r=a&&a.querySelector(`[value=\"${n}\"]`);A.element(r)&&(r.checked=!0)},getLabel(e,t){switch(e){case\"speed\":return 1===t?we.get(\"normal\",this.config):`${t}&times;`;case\"quality\":if(A.number(t)){const e=we.get(`qualityLabel.${t}`,this.config);return e.length?e:`${t}p`}return fe(t);case\"captions\":return Ne.getLabel.call(this);default:return null}},setQualityMenu(e){if(!A.element(this.elements.settings.panels.quality))return;const t=\"quality\",i=this.elements.settings.panels.quality.querySelector('[role=\"menu\"]');A.array(e)&&(this.options.quality=ne(e).filter((e=>this.config.quality.options.includes(e))));const s=!A.empty(this.options.quality)&&this.options.quality.length>1;if(Me.toggleMenuButton.call(this,t,s),R(i),Me.checkMenu.call(this),!s)return;const n=e=>{const t=we.get(`qualityBadge.${e}`,this.config);return t.length?Me.createBadge.call(this,t):null};this.options.quality.sort(((e,t)=>{const i=this.config.quality.options;return i.indexOf(e)>i.indexOf(t)?1:-1})).forEach((e=>{Me.createMenuItem.call(this,{value:e,list:i,type:t,title:Me.getLabel.call(this,\"quality\",e),badge:n(e)})})),Me.updateSetting.call(this,t,i)},setCaptionsMenu(){if(!A.element(this.elements.settings.panels.captions))return;const e=\"captions\",t=this.elements.settings.panels.captions.querySelector('[role=\"menu\"]'),i=Ne.getTracks.call(this),s=Boolean(i.length);if(Me.toggleMenuButton.call(this,e,s),R(t),Me.checkMenu.call(this),!s)return;const n=i.map(((e,i)=>({value:i,checked:this.captions.toggled&&this.currentTrack===i,title:Ne.getLabel.call(this,e),badge:e.language&&Me.createBadge.call(this,e.language.toUpperCase()),list:t,type:\"language\"})));n.unshift({value:-1,checked:!this.captions.toggled,title:we.get(\"disabled\",this.config),list:t,type:\"language\"}),n.forEach(Me.createMenuItem.bind(this)),Me.updateSetting.call(this,e,t)},setSpeedMenu(){if(!A.element(this.elements.settings.panels.speed))return;const e=\"speed\",t=this.elements.settings.panels.speed.querySelector('[role=\"menu\"]');this.options.speed=this.options.speed.filter((e=>e>=this.minimumSpeed&&e1;Me.toggleMenuButton.call(this,e,i),R(t),Me.checkMenu.call(this),i&&(this.options.speed.forEach((i=>{Me.createMenuItem.call(this,{value:i,list:t,type:e,title:Me.getLabel.call(this,\"speed\",i)})})),Me.updateSetting.call(this,e,t))},checkMenu(){const{buttons:e}=this.elements.settings,t=!A.empty(e)&&Object.values(e).some((e=>!e.hidden));H(this.elements.settings.menu,!t)},focusFirstMenuItem(e,t=!1){if(this.elements.settings.popup.hidden)return;let i=e;A.element(i)||(i=Object.values(this.elements.settings.panels).find((e=>!e.hidden)));const s=i.querySelector('[role^=\"menuitem\"]');z.call(this,s,t)},toggleMenu(e){const{popup:t}=this.elements.settings,i=this.elements.buttons.settings;if(!A.element(t)||!A.element(i))return;const{hidden:s}=t;let n=s;if(A.boolean(e))n=e;else if(A.keyboardEvent(e)&&\"Escape\"===e.key)n=!1;else if(A.event(e)){const s=A.function(e.composedPath)?e.composedPath()[0]:e.target,a=t.contains(s);if(a||!a&&e.target!==i&&n)return}i.setAttribute(\"aria-expanded\",n),H(t,!n),F(this.elements.container,this.config.classNames.menu.open,n),n&&A.keyboardEvent(e)?Me.focusFirstMenuItem.call(this,null,!0):n||s||z.call(this,i,A.keyboardEvent(e))},getMenuSize(e){const t=e.cloneNode(!0);t.style.position=\"absolute\",t.style.opacity=0,t.removeAttribute(\"hidden\"),e.parentNode.appendChild(t);const i=t.scrollWidth,s=t.scrollHeight;return j(t),{width:i,height:s}},showMenuPanel(e=\"\",t=!1){const i=this.elements.container.querySelector(`#plyr-settings-${this.id}-${e}`);if(!A.element(i))return;const s=i.parentNode,n=Array.from(s.children).find((e=>!e.hidden));if(Y.transitions&&!Y.reducedMotion){s.style.width=`${n.scrollWidth}px`,s.style.height=`${n.scrollHeight}px`;const e=Me.getMenuSize.call(this,i),t=e=>{e.target===s&&[\"width\",\"height\"].includes(e.propertyName)&&(s.style.width=\"\",s.style.height=\"\",G.call(this,s,P,t))};J.call(this,s,P,t),s.style.width=`${e.width}px`,s.style.height=`${e.height}px`}H(n,!0),H(i,!1),Me.focusFirstMenuItem.call(this,i,t)},setDownloadUrl(){const e=this.elements.buttons.download;A.element(e)&&e.setAttribute(\"href\",this.download)},create(e){const{bindMenuItemShortcuts:t,createButton:i,createProgress:s,createRange:n,createTime:a,setQualityMenu:r,setSpeedMenu:o,showMenuPanel:l}=Me;this.elements.controls=null,A.array(this.config.controls)&&this.config.controls.includes(\"play-large\")&&this.elements.container.appendChild(i.call(this,\"play-large\"));const c=O(\"div\",q(this.config.selectors.controls.wrapper));this.elements.controls=c;const u={class:\"plyr__controls__item\"};return ne(A.array(this.config.controls)?this.config.controls:[]).forEach((r=>{if(\"restart\"===r&&c.appendChild(i.call(this,\"restart\",u)),\"rewind\"===r&&c.appendChild(i.call(this,\"rewind\",u)),\"play\"===r&&c.appendChild(i.call(this,\"play\",u)),\"fast-forward\"===r&&c.appendChild(i.call(this,\"fast-forward\",u)),\"progress\"===r){const t=O(\"div\",{class:`${u.class} plyr__progress__container`}),i=O(\"div\",q(this.config.selectors.progress));if(i.appendChild(n.call(this,\"seek\",{id:`plyr-seek-${e.id}`})),i.appendChild(s.call(this,\"buffer\")),this.config.tooltips.seek){const e=O(\"span\",{class:this.config.classNames.tooltip},\"00:00\");i.appendChild(e),this.elements.display.seekTooltip=e}this.elements.progress=i,t.appendChild(this.elements.progress),c.appendChild(t)}if(\"current-time\"===r&&c.appendChild(a.call(this,\"currentTime\",u)),\"duration\"===r&&c.appendChild(a.call(this,\"duration\",u)),\"mute\"===r||\"volume\"===r){let{volume:t}=this.elements;if(A.element(t)&&c.contains(t)||(t=O(\"div\",N({},u,{class:`${u.class} plyr__volume`.trim()})),this.elements.volume=t,c.appendChild(t)),\"mute\"===r&&t.appendChild(i.call(this,\"mute\")),\"volume\"===r&&!x.isIos&&!x.isIPadOS){const i={max:1,step:.05,value:this.config.volume};t.appendChild(n.call(this,\"volume\",N(i,{id:`plyr-volume-${e.id}`})))}}if(\"captions\"===r&&c.appendChild(i.call(this,\"captions\",u)),\"settings\"===r&&!A.empty(this.config.settings)){const s=O(\"div\",N({},u,{class:`${u.class} plyr__menu`.trim(),hidden:\"\"}));s.appendChild(i.call(this,\"settings\",{\"aria-haspopup\":!0,\"aria-controls\":`plyr-settings-${e.id}`,\"aria-expanded\":!1}));const n=O(\"div\",{class:\"plyr__menu__container\",id:`plyr-settings-${e.id}`,hidden:\"\"}),a=O(\"div\"),r=O(\"div\",{id:`plyr-settings-${e.id}-home`}),o=O(\"div\",{role:\"menu\"});r.appendChild(o),a.appendChild(r),this.elements.settings.panels.home=r,this.config.settings.forEach((i=>{const s=O(\"button\",N(q(this.config.selectors.buttons.settings),{type:\"button\",class:`${this.config.classNames.control} ${this.config.classNames.control}--forward`,role:\"menuitem\",\"aria-haspopup\":!0,hidden:\"\"}));t.call(this,s,i),J.call(this,s,\"click\",(()=>{l.call(this,i,!1)}));const n=O(\"span\",null,we.get(i,this.config)),r=O(\"span\",{class:this.config.classNames.menu.value});r.innerHTML=e[i],n.appendChild(r),s.appendChild(n),o.appendChild(s);const c=O(\"div\",{id:`plyr-settings-${e.id}-${i}`,hidden:\"\"}),u=O(\"button\",{type:\"button\",class:`${this.config.classNames.control} ${this.config.classNames.control}--back`});u.appendChild(O(\"span\",{\"aria-hidden\":!0},we.get(i,this.config))),u.appendChild(O(\"span\",{class:this.config.classNames.hidden},we.get(\"menuBack\",this.config))),J.call(this,c,\"keydown\",(e=>{\"ArrowLeft\"===e.key&&(e.preventDefault(),e.stopPropagation(),l.call(this,\"home\",!0))}),!1),J.call(this,u,\"click\",(()=>{l.call(this,\"home\",!1)})),c.appendChild(u),c.appendChild(O(\"div\",{role:\"menu\"})),a.appendChild(c),this.elements.settings.buttons[i]=s,this.elements.settings.panels[i]=c})),n.appendChild(a),s.appendChild(n),c.appendChild(s),this.elements.settings.popup=n,this.elements.settings.menu=s}if(\"pip\"===r&&Y.pip&&c.appendChild(i.call(this,\"pip\",u)),\"airplay\"===r&&Y.airplay&&c.appendChild(i.call(this,\"airplay\",u)),\"download\"===r){const e=N({},u,{element:\"a\",href:this.download,target:\"_blank\"});this.isHTML5&&(e.download=\"\");const{download:t}=this.config.urls;!A.url(t)&&this.isEmbed&&N(e,{icon:`logo-${this.provider}`,label:this.provider}),c.appendChild(i.call(this,\"download\",e))}\"fullscreen\"===r&&c.appendChild(i.call(this,\"fullscreen\",u))})),this.isHTML5&&r.call(this,me.getQualityOptions.call(this)),o.call(this),c},inject(){if(this.config.loadSprite){const e=Me.getIconUrl.call(this);e.cors&&Ee(e.url,\"sprite-plyr\")}this.id=Math.floor(1e4*Math.random());let e=null;this.elements.controls=null;const t={id:this.id,seektime:this.config.seekTime,title:this.config.title};let i=!0;A.function(this.config.controls)&&(this.config.controls=this.config.controls.call(this,t)),this.config.controls||(this.config.controls=[]),A.element(this.config.controls)||A.string(this.config.controls)?e=this.config.controls:(e=Me.create.call(this,{id:this.id,seektime:this.config.seekTime,speed:this.speed,quality:this.quality,captions:Ne.getLabel.call(this)}),i=!1);let s;i&&A.string(this.config.controls)&&(e=(e=>{let i=e;return Object.entries(t).forEach((([e,t])=>{i=ge(i,`{${e}}`,t)})),i})(e)),A.string(this.config.selectors.controls.container)&&(s=document.querySelector(this.config.selectors.controls.container)),A.element(s)||(s=this.elements.container);if(s[A.element(e)?\"insertAdjacentElement\":\"insertAdjacentHTML\"](\"afterbegin\",e),A.element(this.elements.controls)||Me.findElements.call(this),!A.empty(this.elements.buttons)){const e=e=>{const t=this.config.classNames.controlPressed;e.setAttribute(\"aria-pressed\",\"false\"),Object.defineProperty(e,\"pressed\",{configurable:!0,enumerable:!0,get:()=>U(e,t),set(i=!1){F(e,t,i),e.setAttribute(\"aria-pressed\",i?\"true\":\"false\")}})};Object.values(this.elements.buttons).filter(Boolean).forEach((t=>{A.array(t)||A.nodeList(t)?Array.from(t).filter(Boolean).forEach(e):e(t)}))}if(x.isEdge&&M(s),this.config.tooltips.controls){const{classNames:e,selectors:t}=this.config,i=`${t.controls.wrapper} ${t.labels} .${e.hidden}`,s=B.call(this,i);Array.from(s).forEach((e=>{F(e,this.config.classNames.hidden,!1),F(e,this.config.classNames.tooltip,!0)}))}},setMediaMetadata(){try{\"mediaSession\"in navigator&&(navigator.mediaSession.metadata=new window.MediaMetadata({title:this.config.mediaMetadata.title,artist:this.config.mediaMetadata.artist,album:this.config.mediaMetadata.album,artwork:this.config.mediaMetadata.artwork}))}catch(e){}},setMarkers(){var e,t;if(!this.duration||this.elements.markers)return;const i=null===(e=this.config.markers)||void 0===e||null===(t=e.points)||void 0===t?void 0:t.filter((({time:e})=>e>0&&eF(a,r,e);i.forEach((e=>{const t=O(\"span\",{class:this.config.classNames.marker},\"\"),i=e.time/this.duration*100+\"%\";a&&(t.addEventListener(\"mouseenter\",(()=>{e.label||(a.style.left=i,a.innerHTML=e.label,o(!0))})),t.addEventListener(\"mouseleave\",(()=>{o(!1)}))),t.addEventListener(\"click\",(()=>{this.currentTime=e.time})),t.style.left=i,n.appendChild(t)})),s.appendChild(n),this.config.tooltips.seek||(a=O(\"span\",{class:this.config.classNames.tooltip},\"\"),s.appendChild(a)),this.elements.markers={points:n,tip:a},this.elements.progress.appendChild(s)}};function xe(e,t=!0){let i=e;if(t){const e=document.createElement(\"a\");e.href=i,i=e.href}try{return new URL(i)}catch(e){return null}}function Le(e){const t=new URLSearchParams;return A.object(e)&&Object.entries(e).forEach((([e,i])=>{t.set(e,i)})),t}const Ne={setup(){if(!this.supported.ui)return;if(!this.isVideo||this.isYouTube||this.isHTML5&&!Y.textTracks)return void(A.array(this.config.controls)&&this.config.controls.includes(\"settings\")&&this.config.settings.includes(\"captions\")&&Me.setCaptionsMenu.call(this));var e,t;if(A.element(this.elements.captions)||(this.elements.captions=O(\"div\",q(this.config.selectors.captions)),this.elements.captions.setAttribute(\"dir\",\"auto\"),e=this.elements.captions,t=this.elements.wrapper,A.element(e)&&A.element(t)&&t.parentNode.insertBefore(e,t.nextSibling)),x.isIE&&window.URL){const e=this.media.querySelectorAll(\"track\");Array.from(e).forEach((e=>{const t=e.getAttribute(\"src\"),i=xe(t);null!==i&&i.hostname!==window.location.href.hostname&&[\"http:\",\"https:\"].includes(i.protocol)&&ke(t,\"blob\").then((t=>{e.setAttribute(\"src\",window.URL.createObjectURL(t))})).catch((()=>{j(e)}))}))}const i=ne((navigator.languages||[navigator.language||navigator.userLanguage||\"en\"]).map((e=>e.split(\"-\")[0])));let s=(this.storage.get(\"language\")||this.config.captions.language||\"auto\").toLowerCase();\"auto\"===s&&([s]=i);let n=this.storage.get(\"captions\");if(A.boolean(n)||({active:n}=this.config.captions),Object.assign(this.captions,{toggled:!1,active:n,language:s,languages:i}),this.isHTML5){const e=this.config.captions.update?\"addtrack removetrack\":\"removetrack\";J.call(this,this.media.textTracks,e,Ne.update.bind(this))}setTimeout(Ne.update.bind(this),0)},update(){const e=Ne.getTracks.call(this,!0),{active:t,language:i,meta:s,currentTrackNode:n}=this.captions,a=Boolean(e.find((e=>e.language===i)));this.isHTML5&&this.isVideo&&e.filter((e=>!s.get(e))).forEach((e=>{this.debug.log(\"Track added\",e),s.set(e,{default:\"showing\"===e.mode}),\"showing\"===e.mode&&(e.mode=\"hidden\"),J.call(this,e,\"cuechange\",(()=>Ne.updateCues.call(this)))})),(a&&this.language!==i||!e.includes(n))&&(Ne.setLanguage.call(this,i),Ne.toggle.call(this,t&&a)),this.elements&&F(this.elements.container,this.config.classNames.captions.enabled,!A.empty(e)),A.array(this.config.controls)&&this.config.controls.includes(\"settings\")&&this.config.settings.includes(\"captions\")&&Me.setCaptionsMenu.call(this)},toggle(e,t=!0){if(!this.supported.ui)return;const{toggled:i}=this.captions,s=this.config.classNames.captions.active,n=A.nullOrUndefined(e)?!i:e;if(n!==i){if(t||(this.captions.active=n,this.storage.set({captions:n})),!this.language&&n&&!t){const e=Ne.getTracks.call(this),t=Ne.findTrack.call(this,[this.captions.language,...this.captions.languages],!0);return this.captions.language=t.language,void Ne.set.call(this,e.indexOf(t))}this.elements.buttons.captions&&(this.elements.buttons.captions.pressed=n),F(this.elements.container,s,n),this.captions.toggled=n,Me.updateSetting.call(this,\"captions\"),ee.call(this,this.media,n?\"captionsenabled\":\"captionsdisabled\")}setTimeout((()=>{n&&this.captions.toggled&&(this.captions.currentTrackNode.mode=\"hidden\")}))},set(e,t=!0){const i=Ne.getTracks.call(this);if(-1!==e)if(A.number(e))if(e in i){if(this.captions.currentTrack!==e){this.captions.currentTrack=e;const s=i[e],{language:n}=s||{};this.captions.currentTrackNode=s,Me.updateSetting.call(this,\"captions\"),t||(this.captions.language=n,this.storage.set({language:n})),this.isVimeo&&this.embed.enableTextTrack(n),ee.call(this,this.media,\"languagechange\")}Ne.toggle.call(this,!0,t),this.isHTML5&&this.isVideo&&Ne.updateCues.call(this)}else this.debug.warn(\"Track not found\",e);else this.debug.warn(\"Invalid caption argument\",e);else Ne.toggle.call(this,!1,t)},setLanguage(e,t=!0){if(!A.string(e))return void this.debug.warn(\"Invalid language argument\",e);const i=e.toLowerCase();this.captions.language=i;const s=Ne.getTracks.call(this),n=Ne.findTrack.call(this,[i]);Ne.set.call(this,s.indexOf(n),t)},getTracks(e=!1){return Array.from((this.media||{}).textTracks||[]).filter((t=>!this.isHTML5||e||this.captions.meta.has(t))).filter((e=>[\"captions\",\"subtitles\"].includes(e.kind)))},findTrack(e,t=!1){const i=Ne.getTracks.call(this),s=e=>Number((this.captions.meta.get(e)||{}).default),n=Array.from(i).sort(((e,t)=>s(t)-s(e)));let a;return e.every((e=>(a=n.find((t=>t.language===e)),!a))),a||(t?n[0]:void 0)},getCurrentTrack(){return Ne.getTracks.call(this)[this.currentTrack]},getLabel(e){let t=e;return!A.track(t)&&Y.textTracks&&this.captions.toggled&&(t=Ne.getCurrentTrack.call(this)),A.track(t)?A.empty(t.label)?A.empty(t.language)?we.get(\"enabled\",this.config):e.language.toUpperCase():t.label:we.get(\"disabled\",this.config)},updateCues(e){if(!this.supported.ui)return;if(!A.element(this.elements.captions))return void this.debug.warn(\"No captions element to render to\");if(!A.nullOrUndefined(e)&&!Array.isArray(e))return void this.debug.warn(\"updateCues: Invalid input\",e);let t=e;if(!t){const e=Ne.getCurrentTrack.call(this);t=Array.from((e||{}).activeCues||[]).map((e=>e.getCueAsHTML())).map(be)}const i=t.map((e=>e.trim())).join(\"\\n\");if(i!==this.elements.captions.innerHTML){R(this.elements.captions);const e=O(\"span\",q(this.config.selectors.caption));e.innerHTML=i,this.elements.captions.appendChild(e),ee.call(this,this.media,\"cuechange\")}}},_e={enabled:!0,title:\"\",debug:!1,autoplay:!1,autopause:!0,playsinline:!0,seekTime:10,volume:1,muted:!1,duration:null,displayDuration:!0,invertTime:!0,toggleInvert:!0,ratio:null,clickToPlay:!0,hideControls:!0,resetOnEnd:!1,disableContextMenu:!0,loadSprite:!0,iconPrefix:\"plyr\",iconUrl:\"https://cdn.plyr.io/3.7.8/plyr.svg\",blankVideo:\"https://cdn.plyr.io/static/blank.mp4\",quality:{default:576,options:[4320,2880,2160,1440,1080,720,576,480,360,240],forced:!1,onChange:null},loop:{active:!1},speed:{selected:1,options:[.5,.75,1,1.25,1.5,1.75,2,4]},keyboard:{focused:!0,global:!1},tooltips:{controls:!1,seek:!0},captions:{active:!1,language:\"auto\",update:!1},fullscreen:{enabled:!0,fallback:!0,iosNative:!1},storage:{enabled:!0,key:\"plyr\"},controls:[\"play-large\",\"play\",\"progress\",\"current-time\",\"mute\",\"volume\",\"captions\",\"settings\",\"pip\",\"airplay\",\"fullscreen\"],settings:[\"captions\",\"quality\",\"speed\"],i18n:{restart:\"Restart\",rewind:\"Rewind {seektime}s\",play:\"Play\",pause:\"Pause\",fastForward:\"Forward {seektime}s\",seek:\"Seek\",seekLabel:\"{currentTime} of {duration}\",played:\"Played\",buffered:\"Buffered\",currentTime:\"Current time\",duration:\"Duration\",volume:\"Volume\",mute:\"Mute\",unmute:\"Unmute\",enableCaptions:\"Enable captions\",disableCaptions:\"Disable captions\",download:\"Download\",enterFullscreen:\"Enter fullscreen\",exitFullscreen:\"Exit fullscreen\",frameTitle:\"Player for {title}\",captions:\"Captions\",settings:\"Settings\",pip:\"PIP\",menuBack:\"Go back to previous menu\",speed:\"Speed\",normal:\"Normal\",quality:\"Quality\",loop:\"Loop\",start:\"Start\",end:\"End\",all:\"All\",reset:\"Reset\",disabled:\"Disabled\",enabled:\"Enabled\",advertisement:\"Ad\",qualityBadge:{2160:\"4K\",1440:\"HD\",1080:\"HD\",720:\"HD\",576:\"SD\",480:\"SD\"}},urls:{download:null,vimeo:{sdk:\"https://player.vimeo.com/api/player.js\",iframe:\"https://player.vimeo.com/video/{0}?{1}\",api:\"https://vimeo.com/api/oembed.json?url={0}\"},youtube:{sdk:\"https://www.youtube.com/iframe_api\",api:\"https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}\"},googleIMA:{sdk:\"https://imasdk.googleapis.com/js/sdkloader/ima3.js\"}},listeners:{seek:null,play:null,pause:null,restart:null,rewind:null,fastForward:null,mute:null,volume:null,captions:null,download:null,fullscreen:null,pip:null,airplay:null,speed:null,quality:null,loop:null,language:null},events:[\"ended\",\"progress\",\"stalled\",\"playing\",\"waiting\",\"canplay\",\"canplaythrough\",\"loadstart\",\"loadeddata\",\"loadedmetadata\",\"timeupdate\",\"volumechange\",\"play\",\"pause\",\"error\",\"seeking\",\"seeked\",\"emptied\",\"ratechange\",\"cuechange\",\"download\",\"enterfullscreen\",\"exitfullscreen\",\"captionsenabled\",\"captionsdisabled\",\"languagechange\",\"controlshidden\",\"controlsshown\",\"ready\",\"statechange\",\"qualitychange\",\"adsloaded\",\"adscontentpause\",\"adscontentresume\",\"adstarted\",\"adsmidpoint\",\"adscomplete\",\"adsallcomplete\",\"adsimpression\",\"adsclick\"],selectors:{editable:\"input, textarea, select, [contenteditable]\",container:\".plyr\",controls:{container:null,wrapper:\".plyr__controls\"},labels:\"[data-plyr]\",buttons:{play:'[data-plyr=\"play\"]',pause:'[data-plyr=\"pause\"]',restart:'[data-plyr=\"restart\"]',rewind:'[data-plyr=\"rewind\"]',fastForward:'[data-plyr=\"fast-forward\"]',mute:'[data-plyr=\"mute\"]',captions:'[data-plyr=\"captions\"]',download:'[data-plyr=\"download\"]',fullscreen:'[data-plyr=\"fullscreen\"]',pip:'[data-plyr=\"pip\"]',airplay:'[data-plyr=\"airplay\"]',settings:'[data-plyr=\"settings\"]',loop:'[data-plyr=\"loop\"]'},inputs:{seek:'[data-plyr=\"seek\"]',volume:'[data-plyr=\"volume\"]',speed:'[data-plyr=\"speed\"]',language:'[data-plyr=\"language\"]',quality:'[data-plyr=\"quality\"]'},display:{currentTime:\".plyr__time--current\",duration:\".plyr__time--duration\",buffer:\".plyr__progress__buffer\",loop:\".plyr__progress__loop\",volume:\".plyr__volume--display\"},progress:\".plyr__progress\",captions:\".plyr__captions\",caption:\".plyr__caption\"},classNames:{type:\"plyr--{0}\",provider:\"plyr--{0}\",video:\"plyr__video-wrapper\",embed:\"plyr__video-embed\",videoFixedRatio:\"plyr__video-wrapper--fixed-ratio\",embedContainer:\"plyr__video-embed__container\",poster:\"plyr__poster\",posterEnabled:\"plyr__poster-enabled\",ads:\"plyr__ads\",control:\"plyr__control\",controlPressed:\"plyr__control--pressed\",playing:\"plyr--playing\",paused:\"plyr--paused\",stopped:\"plyr--stopped\",loading:\"plyr--loading\",hover:\"plyr--hover\",tooltip:\"plyr__tooltip\",cues:\"plyr__cues\",marker:\"plyr__progress__marker\",hidden:\"plyr__sr-only\",hideControls:\"plyr--hide-controls\",isTouch:\"plyr--is-touch\",uiSupported:\"plyr--full-ui\",noTransition:\"plyr--no-transition\",display:{time:\"plyr__time\"},menu:{value:\"plyr__menu__value\",badge:\"plyr__badge\",open:\"plyr--menu-open\"},captions:{enabled:\"plyr--captions-enabled\",active:\"plyr--captions-active\"},fullscreen:{enabled:\"plyr--fullscreen-enabled\",fallback:\"plyr--fullscreen-fallback\"},pip:{supported:\"plyr--pip-supported\",active:\"plyr--pip-active\"},airplay:{supported:\"plyr--airplay-supported\",active:\"plyr--airplay-active\"},previewThumbnails:{thumbContainer:\"plyr__preview-thumb\",thumbContainerShown:\"plyr__preview-thumb--is-shown\",imageContainer:\"plyr__preview-thumb__image-container\",timeContainer:\"plyr__preview-thumb__time-container\",scrubbingContainer:\"plyr__preview-scrubbing\",scrubbingContainerShown:\"plyr__preview-scrubbing--is-shown\"}},attributes:{embed:{provider:\"data-plyr-provider\",id:\"data-plyr-embed-id\",hash:\"data-plyr-embed-hash\"}},ads:{enabled:!1,publisherId:\"\",tagUrl:\"\"},previewThumbnails:{enabled:!1,src:\"\"},vimeo:{byline:!1,portrait:!1,title:!1,speed:!0,transparent:!1,customControls:!0,referrerPolicy:null,premium:!1},youtube:{rel:0,showinfo:0,iv_load_policy:3,modestbranding:1,customControls:!0,noCookie:!1},mediaMetadata:{title:\"\",artist:\"\",album:\"\",artwork:[]},markers:{enabled:!1,points:[]}},Ie=\"picture-in-picture\",Oe=\"inline\",$e={html5:\"html5\",youtube:\"youtube\",vimeo:\"vimeo\"},je=\"audio\",Re=\"video\";const De=()=>{};class qe{constructor(e=!1){this.enabled=window.console&&e,this.enabled&&this.log(\"Debugging enabled\")}get log(){return this.enabled?Function.prototype.bind.call(console.log,console):De}get warn(){return this.enabled?Function.prototype.bind.call(console.warn,console):De}get error(){return this.enabled?Function.prototype.bind.call(console.error,console):De}}class He{constructor(e){t(this,\"onChange\",(()=>{if(!this.supported)return;const e=this.player.elements.buttons.fullscreen;A.element(e)&&(e.pressed=this.active);const t=this.target===this.player.media?this.target:this.player.elements.container;ee.call(this.player,t,this.active?\"enterfullscreen\":\"exitfullscreen\",!0)})),t(this,\"toggleFallback\",((e=!1)=>{if(e?this.scrollPosition={x:window.scrollX??0,y:window.scrollY??0}:window.scrollTo(this.scrollPosition.x,this.scrollPosition.y),document.body.style.overflow=e?\"hidden\":\"\",F(this.target,this.player.config.classNames.fullscreen.fallback,e),x.isIos){let t=document.head.querySelector('meta[name=\"viewport\"]');const i=\"viewport-fit=cover\";t||(t=document.createElement(\"meta\"),t.setAttribute(\"name\",\"viewport\"));const s=A.string(t.content)&&t.content.includes(i);e?(this.cleanupViewport=!s,s||(t.content+=`,${i}`)):this.cleanupViewport&&(t.content=t.content.split(\",\").filter((e=>e.trim()!==i)).join(\",\"))}this.onChange()})),t(this,\"trapFocus\",(e=>{if(x.isIos||x.isIPadOS||!this.active||\"Tab\"!==e.key)return;const t=document.activeElement,i=B.call(this.player,\"a[href], button:not(:disabled), input:not(:disabled), [tabindex]\"),[s]=i,n=i[i.length-1];t!==n||e.shiftKey?t===s&&e.shiftKey&&(n.focus(),e.preventDefault()):(s.focus(),e.preventDefault())})),t(this,\"update\",(()=>{if(this.supported){let e;e=this.forceFallback?\"Fallback (forced)\":He.nativeSupported?\"Native\":\"Fallback\",this.player.debug.log(`${e} fullscreen enabled`)}else this.player.debug.log(\"Fullscreen not supported and fallback disabled\");F(this.player.elements.container,this.player.config.classNames.fullscreen.enabled,this.supported)})),t(this,\"enter\",(()=>{this.supported&&(x.isIos&&this.player.config.fullscreen.iosNative?this.player.isVimeo?this.player.embed.requestFullscreen():this.target.webkitEnterFullscreen():!He.nativeSupported||this.forceFallback?this.toggleFallback(!0):this.prefix?A.empty(this.prefix)||this.target[`${this.prefix}Request${this.property}`]():this.target.requestFullscreen({navigationUI:\"hide\"}))})),t(this,\"exit\",(()=>{if(this.supported)if(x.isIos&&this.player.config.fullscreen.iosNative)this.player.isVimeo?this.player.embed.exitFullscreen():this.target.webkitEnterFullscreen(),se(this.player.play());else if(!He.nativeSupported||this.forceFallback)this.toggleFallback(!1);else if(this.prefix){if(!A.empty(this.prefix)){const e=\"moz\"===this.prefix?\"Cancel\":\"Exit\";document[`${this.prefix}${e}${this.property}`]()}}else(document.cancelFullScreen||document.exitFullscreen).call(document)})),t(this,\"toggle\",(()=>{this.active?this.exit():this.enter()})),this.player=e,this.prefix=He.prefix,this.property=He.property,this.scrollPosition={x:0,y:0},this.forceFallback=\"force\"===e.config.fullscreen.fallback,this.player.elements.fullscreen=e.config.fullscreen.container&&function(e,t){const{prototype:i}=Element;return(i.closest||function(){let e=this;do{if(V.matches(e,t))return e;e=e.parentElement||e.parentNode}while(null!==e&&1===e.nodeType);return null}).call(e,t)}(this.player.elements.container,e.config.fullscreen.container),J.call(this.player,document,\"ms\"===this.prefix?\"MSFullscreenChange\":`${this.prefix}fullscreenchange`,(()=>{this.onChange()})),J.call(this.player,this.player.elements.container,\"dblclick\",(e=>{A.element(this.player.elements.controls)&&this.player.elements.controls.contains(e.target)||this.player.listeners.proxy(e,this.toggle,\"fullscreen\")})),J.call(this,this.player.elements.container,\"keydown\",(e=>this.trapFocus(e))),this.update()}static get nativeSupported(){return!!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled)}get useNative(){return He.nativeSupported&&!this.forceFallback}static get prefix(){if(A.function(document.exitFullscreen))return\"\";let e=\"\";return[\"webkit\",\"moz\",\"ms\"].some((t=>!(!A.function(document[`${t}ExitFullscreen`])&&!A.function(document[`${t}CancelFullScreen`]))&&(e=t,!0))),e}static get property(){return\"moz\"===this.prefix?\"FullScreen\":\"Fullscreen\"}get supported(){return[this.player.config.fullscreen.enabled,this.player.isVideo,He.nativeSupported||this.player.config.fullscreen.fallback,!this.player.isYouTube||He.nativeSupported||!x.isIos||this.player.config.playsinline&&!this.player.config.fullscreen.iosNative].every(Boolean)}get active(){if(!this.supported)return!1;if(!He.nativeSupported||this.forceFallback)return U(this.target,this.player.config.classNames.fullscreen.fallback);const e=this.prefix?this.target.getRootNode()[`${this.prefix}${this.property}Element`]:this.target.getRootNode().fullscreenElement;return e&&e.shadowRoot?e===this.target.getRootNode().host:e===this.target}get target(){return x.isIos&&this.player.config.fullscreen.iosNative?this.player.media:this.player.elements.fullscreen??this.player.elements.container}}function Fe(e,t=1){return new Promise(((i,s)=>{const n=new Image,a=()=>{delete n.onload,delete n.onerror,(n.naturalWidth>=t?i:s)(n)};Object.assign(n,{onload:a,onerror:a,src:e})}))}const Ue={addStyleHook(){F(this.elements.container,this.config.selectors.container.replace(\".\",\"\"),!0),F(this.elements.container,this.config.classNames.uiSupported,this.supported.ui)},toggleNativeControls(e=!1){e&&this.isHTML5?this.media.setAttribute(\"controls\",\"\"):this.media.removeAttribute(\"controls\")},build(){if(this.listeners.media(),!this.supported.ui)return this.debug.warn(`Basic support only for ${this.provider} ${this.type}`),void Ue.toggleNativeControls.call(this,!0);A.element(this.elements.controls)||(Me.inject.call(this),this.listeners.controls()),Ue.toggleNativeControls.call(this),this.isHTML5&&Ne.setup.call(this),this.volume=null,this.muted=null,this.loop=null,this.quality=null,this.speed=null,Me.updateVolume.call(this),Me.timeUpdate.call(this),Me.durationUpdate.call(this),Ue.checkPlaying.call(this),F(this.elements.container,this.config.classNames.pip.supported,Y.pip&&this.isHTML5&&this.isVideo),F(this.elements.container,this.config.classNames.airplay.supported,Y.airplay&&this.isHTML5),F(this.elements.container,this.config.classNames.isTouch,this.touch),this.ready=!0,setTimeout((()=>{ee.call(this,this.media,\"ready\")}),0),Ue.setTitle.call(this),this.poster&&Ue.setPoster.call(this,this.poster,!1).catch((()=>{})),this.config.duration&&Me.durationUpdate.call(this),this.config.mediaMetadata&&Me.setMediaMetadata.call(this)},setTitle(){let e=we.get(\"play\",this.config);if(A.string(this.config.title)&&!A.empty(this.config.title)&&(e+=`, ${this.config.title}`),Array.from(this.elements.buttons.play||[]).forEach((t=>{t.setAttribute(\"aria-label\",e)})),this.isEmbed){const e=W.call(this,\"iframe\");if(!A.element(e))return;const t=A.empty(this.config.title)?\"video\":this.config.title,i=we.get(\"frameTitle\",this.config);e.setAttribute(\"title\",i.replace(\"{title}\",t))}},togglePoster(e){F(this.elements.container,this.config.classNames.posterEnabled,e)},setPoster(e,t=!0){return t&&this.poster?Promise.reject(new Error(\"Poster already set\")):(this.media.setAttribute(\"data-poster\",e),this.elements.poster.removeAttribute(\"hidden\"),ie.call(this).then((()=>Fe(e))).catch((t=>{throw e===this.poster&&Ue.togglePoster.call(this,!1),t})).then((()=>{if(e!==this.poster)throw new Error(\"setPoster cancelled by later call to setPoster\")})).then((()=>(Object.assign(this.elements.poster.style,{backgroundImage:`url('${e}')`,backgroundSize:\"\"}),Ue.togglePoster.call(this,!0),e))))},checkPlaying(e){F(this.elements.container,this.config.classNames.playing,this.playing),F(this.elements.container,this.config.classNames.paused,this.paused),F(this.elements.container,this.config.classNames.stopped,this.stopped),Array.from(this.elements.buttons.play||[]).forEach((e=>{Object.assign(e,{pressed:this.playing}),e.setAttribute(\"aria-label\",we.get(this.playing?\"pause\":\"play\",this.config))})),A.event(e)&&\"timeupdate\"===e.type||Ue.toggleControls.call(this)},checkLoading(e){this.loading=[\"stalled\",\"waiting\"].includes(e.type),clearTimeout(this.timers.loading),this.timers.loading=setTimeout((()=>{F(this.elements.container,this.config.classNames.loading,this.loading),Ue.toggleControls.call(this)}),this.loading?250:0)},toggleControls(e){const{controls:t}=this.elements;if(t&&this.config.hideControls){const i=this.touch&&this.lastSeekTime+2e3>Date.now();this.toggleControls(Boolean(e||this.loading||this.paused||t.pressed||t.hover||i))}},migrateStyles(){Object.values({...this.media.style}).filter((e=>!A.empty(e)&&A.string(e)&&e.startsWith(\"--plyr\"))).forEach((e=>{this.elements.container.style.setProperty(e,this.media.style.getPropertyValue(e)),this.media.style.removeProperty(e)})),A.empty(this.media.style)&&this.media.removeAttribute(\"style\")}};class Ve{constructor(e){t(this,\"firstTouch\",(()=>{const{player:e}=this,{elements:t}=e;e.touch=!0,F(t.container,e.config.classNames.isTouch,!0)})),t(this,\"global\",((e=!0)=>{const{player:t}=this;t.config.keyboard.global&&X.call(t,window,\"keydown keyup\",this.handleKey,e,!1),X.call(t,document.body,\"click\",this.toggleMenu,e),Z.call(t,document.body,\"touchstart\",this.firstTouch)})),t(this,\"container\",(()=>{const{player:e}=this,{config:t,elements:i,timers:s}=e;!t.keyboard.global&&t.keyboard.focused&&J.call(e,i.container,\"keydown keyup\",this.handleKey,!1),J.call(e,i.container,\"mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen\",(t=>{const{controls:n}=i;n&&\"enterfullscreen\"===t.type&&(n.pressed=!1,n.hover=!1);let a=0;[\"touchstart\",\"touchmove\",\"mousemove\"].includes(t.type)&&(Ue.toggleControls.call(e,!0),a=e.touch?3e3:2e3),clearTimeout(s.controls),s.controls=setTimeout((()=>Ue.toggleControls.call(e,!1)),a)}));const n=()=>{if(!e.isVimeo||e.config.vimeo.premium)return;const t=i.wrapper,{active:s}=e.fullscreen,[n,a]=ue.call(e),r=re(`aspect-ratio: ${n} / ${a}`);if(!s)return void(r?(t.style.width=null,t.style.height=null):(t.style.maxWidth=null,t.style.margin=null));const[o,l]=[Math.max(document.documentElement.clientWidth||0,window.innerWidth||0),Math.max(document.documentElement.clientHeight||0,window.innerHeight||0)],c=o/l>n/a;r?(t.style.width=c?\"auto\":\"100%\",t.style.height=c?\"100%\":\"auto\"):(t.style.maxWidth=c?l/a*n+\"px\":null,t.style.margin=c?\"0 auto\":null)},a=()=>{clearTimeout(s.resized),s.resized=setTimeout(n,50)};J.call(e,i.container,\"enterfullscreen exitfullscreen\",(t=>{const{target:s}=e.fullscreen;if(s!==i.container)return;if(!e.isEmbed&&A.empty(e.config.ratio))return;n();(\"enterfullscreen\"===t.type?J:G).call(e,window,\"resize\",a)}))})),t(this,\"media\",(()=>{const{player:e}=this,{elements:t}=e;if(J.call(e,e.media,\"timeupdate seeking seeked\",(t=>Me.timeUpdate.call(e,t))),J.call(e,e.media,\"durationchange loadeddata loadedmetadata\",(t=>Me.durationUpdate.call(e,t))),J.call(e,e.media,\"ended\",(()=>{e.isHTML5&&e.isVideo&&e.config.resetOnEnd&&(e.restart(),e.pause())})),J.call(e,e.media,\"progress playing seeking seeked\",(t=>Me.updateProgress.call(e,t))),J.call(e,e.media,\"volumechange\",(t=>Me.updateVolume.call(e,t))),J.call(e,e.media,\"playing play pause ended emptied timeupdate\",(t=>Ue.checkPlaying.call(e,t))),J.call(e,e.media,\"waiting canplay seeked playing\",(t=>Ue.checkLoading.call(e,t))),e.supported.ui&&e.config.clickToPlay&&!e.isAudio){const i=W.call(e,`.${e.config.classNames.video}`);if(!A.element(i))return;J.call(e,t.container,\"click\",(s=>{([t.container,i].includes(s.target)||i.contains(s.target))&&(e.touch&&e.config.hideControls||(e.ended?(this.proxy(s,e.restart,\"restart\"),this.proxy(s,(()=>{se(e.play())}),\"play\")):this.proxy(s,(()=>{se(e.togglePlay())}),\"play\")))}))}e.supported.ui&&e.config.disableContextMenu&&J.call(e,t.wrapper,\"contextmenu\",(e=>{e.preventDefault()}),!1),J.call(e,e.media,\"volumechange\",(()=>{e.storage.set({volume:e.volume,muted:e.muted})})),J.call(e,e.media,\"ratechange\",(()=>{Me.updateSetting.call(e,\"speed\"),e.storage.set({speed:e.speed})})),J.call(e,e.media,\"qualitychange\",(t=>{Me.updateSetting.call(e,\"quality\",null,t.detail.quality)})),J.call(e,e.media,\"ready qualitychange\",(()=>{Me.setDownloadUrl.call(e)}));const i=e.config.events.concat([\"keyup\",\"keydown\"]).join(\" \");J.call(e,e.media,i,(i=>{let{detail:s={}}=i;\"error\"===i.type&&(s=e.media.error),ee.call(e,t.container,i.type,!0,s)}))})),t(this,\"proxy\",((e,t,i)=>{const{player:s}=this,n=s.config.listeners[i];let a=!0;A.function(n)&&(a=n.call(s,e)),!1!==a&&A.function(t)&&t.call(s,e)})),t(this,\"bind\",((e,t,i,s,n=!0)=>{const{player:a}=this,r=a.config.listeners[s],o=A.function(r);J.call(a,e,t,(e=>this.proxy(e,i,s)),n&&!o)})),t(this,\"controls\",(()=>{const{player:e}=this,{elements:t}=e,i=x.isIE?\"change\":\"input\";if(t.buttons.play&&Array.from(t.buttons.play).forEach((t=>{this.bind(t,\"click\",(()=>{se(e.togglePlay())}),\"play\")})),this.bind(t.buttons.restart,\"click\",e.restart,\"restart\"),this.bind(t.buttons.rewind,\"click\",(()=>{e.lastSeekTime=Date.now(),e.rewind()}),\"rewind\"),this.bind(t.buttons.fastForward,\"click\",(()=>{e.lastSeekTime=Date.now(),e.forward()}),\"fastForward\"),this.bind(t.buttons.mute,\"click\",(()=>{e.muted=!e.muted}),\"mute\"),this.bind(t.buttons.captions,\"click\",(()=>e.toggleCaptions())),this.bind(t.buttons.download,\"click\",(()=>{ee.call(e,e.media,\"download\")}),\"download\"),this.bind(t.buttons.fullscreen,\"click\",(()=>{e.fullscreen.toggle()}),\"fullscreen\"),this.bind(t.buttons.pip,\"click\",(()=>{e.pip=\"toggle\"}),\"pip\"),this.bind(t.buttons.airplay,\"click\",e.airplay,\"airplay\"),this.bind(t.buttons.settings,\"click\",(t=>{t.stopPropagation(),t.preventDefault(),Me.toggleMenu.call(e,t)}),null,!1),this.bind(t.buttons.settings,\"keyup\",(t=>{[\" \",\"Enter\"].includes(t.key)&&(\"Enter\"!==t.key?(t.preventDefault(),t.stopPropagation(),Me.toggleMenu.call(e,t)):Me.focusFirstMenuItem.call(e,null,!0))}),null,!1),this.bind(t.settings.menu,\"keydown\",(t=>{\"Escape\"===t.key&&Me.toggleMenu.call(e,t)})),this.bind(t.inputs.seek,\"mousedown mousemove\",(e=>{const i=t.progress.getBoundingClientRect(),s=100/i.width*(e.pageX-i.left);e.currentTarget.setAttribute(\"seek-value\",s)})),this.bind(t.inputs.seek,\"mousedown mouseup keydown keyup touchstart touchend\",(t=>{const i=t.currentTarget,s=\"play-on-seeked\";if(A.keyboardEvent(t)&&![\"ArrowLeft\",\"ArrowRight\"].includes(t.key))return;e.lastSeekTime=Date.now();const n=i.hasAttribute(s),a=[\"mouseup\",\"touchend\",\"keyup\"].includes(t.type);n&&a?(i.removeAttribute(s),se(e.play())):!a&&e.playing&&(i.setAttribute(s,\"\"),e.pause())})),x.isIos){const t=B.call(e,'input[type=\"range\"]');Array.from(t).forEach((e=>this.bind(e,i,(e=>M(e.target)))))}this.bind(t.inputs.seek,i,(t=>{const i=t.currentTarget;let s=i.getAttribute(\"seek-value\");A.empty(s)&&(s=i.value),i.removeAttribute(\"seek-value\"),e.currentTime=s/i.max*e.duration}),\"seek\"),this.bind(t.progress,\"mouseenter mouseleave mousemove\",(t=>Me.updateSeekTooltip.call(e,t))),this.bind(t.progress,\"mousemove touchmove\",(t=>{const{previewThumbnails:i}=e;i&&i.loaded&&i.startMove(t)})),this.bind(t.progress,\"mouseleave touchend click\",(()=>{const{previewThumbnails:t}=e;t&&t.loaded&&t.endMove(!1,!0)})),this.bind(t.progress,\"mousedown touchstart\",(t=>{const{previewThumbnails:i}=e;i&&i.loaded&&i.startScrubbing(t)})),this.bind(t.progress,\"mouseup touchend\",(t=>{const{previewThumbnails:i}=e;i&&i.loaded&&i.endScrubbing(t)})),x.isWebKit&&Array.from(B.call(e,'input[type=\"range\"]')).forEach((t=>{this.bind(t,\"input\",(t=>Me.updateRangeFill.call(e,t.target)))})),e.config.toggleInvert&&!A.element(t.display.duration)&&this.bind(t.display.currentTime,\"click\",(()=>{0!==e.currentTime&&(e.config.invertTime=!e.config.invertTime,Me.timeUpdate.call(e))})),this.bind(t.inputs.volume,i,(t=>{e.volume=t.target.value}),\"volume\"),this.bind(t.controls,\"mouseenter mouseleave\",(i=>{t.controls.hover=!e.touch&&\"mouseenter\"===i.type})),t.fullscreen&&Array.from(t.fullscreen.children).filter((e=>!e.contains(t.container))).forEach((i=>{this.bind(i,\"mouseenter mouseleave\",(i=>{t.controls&&(t.controls.hover=!e.touch&&\"mouseenter\"===i.type)}))})),this.bind(t.controls,\"mousedown mouseup touchstart touchend touchcancel\",(e=>{t.controls.pressed=[\"mousedown\",\"touchstart\"].includes(e.type)})),this.bind(t.controls,\"focusin\",(()=>{const{config:i,timers:s}=e;F(t.controls,i.classNames.noTransition,!0),Ue.toggleControls.call(e,!0),setTimeout((()=>{F(t.controls,i.classNames.noTransition,!1)}),0);const n=this.touch?3e3:4e3;clearTimeout(s.controls),s.controls=setTimeout((()=>Ue.toggleControls.call(e,!1)),n)})),this.bind(t.inputs.volume,\"wheel\",(t=>{const i=t.webkitDirectionInvertedFromDevice,[s,n]=[t.deltaX,-t.deltaY].map((e=>i?-e:e)),a=Math.sign(Math.abs(s)>Math.abs(n)?s:n);e.increaseVolume(a/50);const{volume:r}=e.media;(1===a&&r0)&&t.preventDefault()}),\"volume\",!1)})),this.player=e,this.lastKey=null,this.focusTimer=null,this.lastKeyDown=null,this.handleKey=this.handleKey.bind(this),this.toggleMenu=this.toggleMenu.bind(this),this.firstTouch=this.firstTouch.bind(this)}handleKey(e){const{player:t}=this,{elements:i}=t,{key:s,type:n,altKey:a,ctrlKey:r,metaKey:o,shiftKey:l}=e,c=\"keydown\"===n,u=c&&s===this.lastKey;if(a||r||o||l)return;if(!s)return;if(c){const n=document.activeElement;if(A.element(n)){const{editable:s}=t.config.selectors,{seek:a}=i.inputs;if(n!==a&&V(n,s))return;if(\" \"===e.key&&V(n,'button, [role^=\"menuitem\"]'))return}switch([\" \",\"ArrowLeft\",\"ArrowUp\",\"ArrowRight\",\"ArrowDown\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"c\",\"f\",\"k\",\"l\",\"m\"].includes(s)&&(e.preventDefault(),e.stopPropagation()),s){case\"0\":case\"1\":case\"2\":case\"3\":case\"4\":case\"5\":case\"6\":case\"7\":case\"8\":case\"9\":u||(h=parseInt(s,10),t.currentTime=t.duration/10*h);break;case\" \":case\"k\":u||se(t.togglePlay());break;case\"ArrowUp\":t.increaseVolume(.1);break;case\"ArrowDown\":t.decreaseVolume(.1);break;case\"m\":u||(t.muted=!t.muted);break;case\"ArrowRight\":t.forward();break;case\"ArrowLeft\":t.rewind();break;case\"f\":t.fullscreen.toggle();break;case\"c\":u||t.toggleCaptions();break;case\"l\":t.loop=!t.loop}\"Escape\"===s&&!t.fullscreen.usingNative&&t.fullscreen.active&&t.fullscreen.toggle(),this.lastKey=s}else this.lastKey=null;var h}toggleMenu(e){Me.toggleMenu.call(this.player,e)}}var Be=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e,t){e.exports=function(){var e=function(){},t={},i={},s={};function n(e,t){e=e.push?e:[e];var n,a,r,o=[],l=e.length,c=l;for(n=function(e,i){i.length&&o.push(e),--c||t(o)};l--;)a=e[l],(r=i[a])?n(a,r):(s[a]=s[a]||[]).push(n)}function a(e,t){if(e){var n=s[e];if(i[e]=t,n)for(;n.length;)n[0](e,t),n.splice(0,1)}}function r(t,i){t.call&&(t={success:t}),i.length?(t.error||e)(i):(t.success||e)(t)}function o(t,i,s,n){var a,r,l=document,c=s.async,u=(s.numRetries||0)+1,h=s.before||e,d=t.replace(/[\\?|#].*$/,\"\"),m=t.replace(/^(css|img)!/,\"\");n=n||0,/(^css!|\\.css$)/.test(d)?((r=l.createElement(\"link\")).rel=\"stylesheet\",r.href=m,(a=\"hideFocus\"in r)&&r.relList&&(a=0,r.rel=\"preload\",r.as=\"style\")):/(^img!|\\.(png|gif|jpg|svg|webp)$)/.test(d)?(r=l.createElement(\"img\")).src=m:((r=l.createElement(\"script\")).src=t,r.async=void 0===c||c),r.onload=r.onerror=r.onbeforeload=function(e){var l=e.type[0];if(a)try{r.sheet.cssText.length||(l=\"e\")}catch(e){18!=e.code&&(l=\"e\")}if(\"e\"==l){if((n+=1){Ke.ready.call(e)})).catch((t=>{e.debug.warn(\"Vimeo SDK (player.js) failed to load\",t)}))},ready(){const e=this,t=e.config.vimeo,{premium:i,referrerPolicy:s,...n}=t;let a=e.media.getAttribute(\"src\"),r=\"\";A.empty(a)?(a=e.media.getAttribute(e.config.attributes.embed.id),r=e.media.getAttribute(e.config.attributes.embed.hash)):r=function(e){const t=e.match(/^.*(vimeo.com\\/|video\\/)(\\d+)(\\?.*&*h=|\\/)+([\\d,a-f]+)/);return t&&5===t.length?t[4]:null}(a);const o=r?{h:r}:{};i&&Object.assign(n,{controls:!1,sidedock:!1});const l=Le({loop:e.config.loop.active,autoplay:e.autoplay,muted:e.muted,gesture:\"media\",playsinline:e.config.playsinline,...o,...n}),c=(u=a,A.empty(u)?null:A.number(Number(u))?u:u.match(/^.*(vimeo.com\\/|video\\/)(\\d+).*/)?RegExp.$2:u);var u;const h=O(\"iframe\"),d=pe(e.config.urls.vimeo.iframe,c,l);if(h.setAttribute(\"src\",d),h.setAttribute(\"allowfullscreen\",\"\"),h.setAttribute(\"allow\",[\"autoplay\",\"fullscreen\",\"picture-in-picture\",\"encrypted-media\",\"accelerometer\",\"gyroscope\"].join(\"; \")),A.empty(s)||h.setAttribute(\"referrerPolicy\",s),i||!t.customControls)h.setAttribute(\"data-poster\",e.poster),e.media=D(h,e.media);else{const t=O(\"div\",{class:e.config.classNames.embedContainer,\"data-poster\":e.poster});t.appendChild(h),e.media=D(t,e.media)}t.customControls||ke(pe(e.config.urls.vimeo.api,d)).then((t=>{!A.empty(t)&&t.thumbnail_url&&Ue.setPoster.call(e,t.thumbnail_url).catch((()=>{}))})),e.embed=new window.Vimeo.Player(h,{autopause:e.config.autopause,muted:e.muted}),e.media.paused=!0,e.media.currentTime=0,e.supported.ui&&e.embed.disableTextTrack(),e.media.play=()=>(ze.call(e,!0),e.embed.play()),e.media.pause=()=>(ze.call(e,!1),e.embed.pause()),e.media.stop=()=>{e.pause(),e.currentTime=0};let{currentTime:m}=e.media;Object.defineProperty(e.media,\"currentTime\",{get:()=>m,set(t){const{embed:i,media:s,paused:n,volume:a}=e,r=n&&!i.hasPlayed;s.seeking=!0,ee.call(e,s,\"seeking\"),Promise.resolve(r&&i.setVolume(0)).then((()=>i.setCurrentTime(t))).then((()=>r&&i.pause())).then((()=>r&&i.setVolume(a))).catch((()=>{}))}});let p=e.config.speed.selected;Object.defineProperty(e.media,\"playbackRate\",{get:()=>p,set(t){e.embed.setPlaybackRate(t).then((()=>{p=t,ee.call(e,e.media,\"ratechange\")})).catch((()=>{e.options.speed=[1]}))}});let{volume:g}=e.config;Object.defineProperty(e.media,\"volume\",{get:()=>g,set(t){e.embed.setVolume(t).then((()=>{g=t,ee.call(e,e.media,\"volumechange\")}))}});let{muted:f}=e.config;Object.defineProperty(e.media,\"muted\",{get:()=>f,set(t){const i=!!A.boolean(t)&&t;e.embed.setMuted(!!i||e.config.muted).then((()=>{f=i,ee.call(e,e.media,\"volumechange\")}))}});let y,{loop:b}=e.config;Object.defineProperty(e.media,\"loop\",{get:()=>b,set(t){const i=A.boolean(t)?t:e.config.loop.active;e.embed.setLoop(i).then((()=>{b=i}))}}),e.embed.getVideoUrl().then((t=>{y=t,Me.setDownloadUrl.call(e)})).catch((e=>{this.debug.warn(e)})),Object.defineProperty(e.media,\"currentSrc\",{get:()=>y}),Object.defineProperty(e.media,\"ended\",{get:()=>e.currentTime===e.duration}),Promise.all([e.embed.getVideoWidth(),e.embed.getVideoHeight()]).then((t=>{const[i,s]=t;e.embed.ratio=de(i,s),he.call(this)})),e.embed.setAutopause(e.config.autopause).then((t=>{e.config.autopause=t})),e.embed.getVideoTitle().then((t=>{e.config.title=t,Ue.setTitle.call(this)})),e.embed.getCurrentTime().then((t=>{m=t,ee.call(e,e.media,\"timeupdate\")})),e.embed.getDuration().then((t=>{e.media.duration=t,ee.call(e,e.media,\"durationchange\")})),e.embed.getTextTracks().then((t=>{e.media.textTracks=t,Ne.setup.call(e)})),e.embed.on(\"cuechange\",(({cues:t=[]})=>{const i=t.map((e=>function(e){const t=document.createDocumentFragment(),i=document.createElement(\"div\");return t.appendChild(i),i.innerHTML=e,t.firstChild.innerText}(e.text)));Ne.updateCues.call(e,i)})),e.embed.on(\"loaded\",(()=>{if(e.embed.getPaused().then((t=>{ze.call(e,!t),t||ee.call(e,e.media,\"playing\")})),A.element(e.embed.element)&&e.supported.ui){e.embed.element.setAttribute(\"tabindex\",-1)}})),e.embed.on(\"bufferstart\",(()=>{ee.call(e,e.media,\"waiting\")})),e.embed.on(\"bufferend\",(()=>{ee.call(e,e.media,\"playing\")})),e.embed.on(\"play\",(()=>{ze.call(e,!0),ee.call(e,e.media,\"playing\")})),e.embed.on(\"pause\",(()=>{ze.call(e,!1)})),e.embed.on(\"timeupdate\",(t=>{e.media.seeking=!1,m=t.seconds,ee.call(e,e.media,\"timeupdate\")})),e.embed.on(\"progress\",(t=>{e.media.buffered=t.percent,ee.call(e,e.media,\"progress\"),1===parseInt(t.percent,10)&&ee.call(e,e.media,\"canplaythrough\"),e.embed.getDuration().then((t=>{t!==e.media.duration&&(e.media.duration=t,ee.call(e,e.media,\"durationchange\"))}))})),e.embed.on(\"seeked\",(()=>{e.media.seeking=!1,ee.call(e,e.media,\"seeked\")})),e.embed.on(\"ended\",(()=>{e.media.paused=!0,ee.call(e,e.media,\"ended\")})),e.embed.on(\"error\",(t=>{e.media.error=t,ee.call(e,e.media,\"error\")})),t.customControls&&setTimeout((()=>Ue.build.call(e)),0)}};function Ye(e){e&&!this.embed.hasPlayed&&(this.embed.hasPlayed=!0),this.media.paused===e&&(this.media.paused=!e,ee.call(this,this.media,e?\"play\":\"pause\"))}function Qe(e){return e.noCookie?\"https://www.youtube-nocookie.com\":\"http:\"===window.location.protocol?\"http://www.youtube.com\":void 0}const Xe={setup(){if(F(this.elements.wrapper,this.config.classNames.embed,!0),A.object(window.YT)&&A.function(window.YT.Player))Xe.ready.call(this);else{const e=window.onYouTubeIframeAPIReady;window.onYouTubeIframeAPIReady=()=>{A.function(e)&&e(),Xe.ready.call(this)},We(this.config.urls.youtube.sdk).catch((e=>{this.debug.warn(\"YouTube API failed to load\",e)}))}},getTitle(e){ke(pe(this.config.urls.youtube.api,e)).then((e=>{if(A.object(e)){const{title:t,height:i,width:s}=e;this.config.title=t,Ue.setTitle.call(this),this.embed.ratio=de(s,i)}he.call(this)})).catch((()=>{he.call(this)}))},ready(){const e=this,t=e.config.youtube,i=e.media&&e.media.getAttribute(\"id\");if(!A.empty(i)&&i.startsWith(\"youtube-\"))return;let s=e.media.getAttribute(\"src\");A.empty(s)&&(s=e.media.getAttribute(this.config.attributes.embed.id));const n=(a=s,A.empty(a)?null:a.match(/^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/)?RegExp.$2:a);var a;const r=O(\"div\",{id:`${e.provider}-${Math.floor(1e4*Math.random())}`,\"data-poster\":t.customControls?e.poster:void 0});if(e.media=D(r,e.media),t.customControls){const t=e=>`https://i.ytimg.com/vi/${n}/${e}default.jpg`;Fe(t(\"maxres\"),121).catch((()=>Fe(t(\"sd\"),121))).catch((()=>Fe(t(\"hq\")))).then((t=>Ue.setPoster.call(e,t.src))).then((t=>{t.includes(\"maxres\")||(e.elements.poster.style.backgroundSize=\"cover\")})).catch((()=>{}))}e.embed=new window.YT.Player(e.media,{videoId:n,host:Qe(t),playerVars:N({},{autoplay:e.config.autoplay?1:0,hl:e.config.hl,controls:e.supported.ui&&t.customControls?0:1,disablekb:1,playsinline:e.config.playsinline&&!e.config.fullscreen.iosNative?1:0,cc_load_policy:e.captions.active?1:0,cc_lang_pref:e.config.captions.language,widget_referrer:window?window.location.href:null},t),events:{onError(t){if(!e.media.error){const i=t.data,s={2:\"The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.\",5:\"The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.\",100:\"The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.\",101:\"The owner of the requested video does not allow it to be played in embedded players.\",150:\"The owner of the requested video does not allow it to be played in embedded players.\"}[i]||\"An unknown error occurred\";e.media.error={code:i,message:s},ee.call(e,e.media,\"error\")}},onPlaybackRateChange(t){const i=t.target;e.media.playbackRate=i.getPlaybackRate(),ee.call(e,e.media,\"ratechange\")},onReady(i){if(A.function(e.media.play))return;const s=i.target;Xe.getTitle.call(e,n),e.media.play=()=>{Ye.call(e,!0),s.playVideo()},e.media.pause=()=>{Ye.call(e,!1),s.pauseVideo()},e.media.stop=()=>{s.stopVideo()},e.media.duration=s.getDuration(),e.media.paused=!0,e.media.currentTime=0,Object.defineProperty(e.media,\"currentTime\",{get:()=>Number(s.getCurrentTime()),set(t){e.paused&&!e.embed.hasPlayed&&e.embed.mute(),e.media.seeking=!0,ee.call(e,e.media,\"seeking\"),s.seekTo(t)}}),Object.defineProperty(e.media,\"playbackRate\",{get:()=>s.getPlaybackRate(),set(e){s.setPlaybackRate(e)}});let{volume:a}=e.config;Object.defineProperty(e.media,\"volume\",{get:()=>a,set(t){a=t,s.setVolume(100*a),ee.call(e,e.media,\"volumechange\")}});let{muted:r}=e.config;Object.defineProperty(e.media,\"muted\",{get:()=>r,set(t){const i=A.boolean(t)?t:r;r=i,s[i?\"mute\":\"unMute\"](),s.setVolume(100*a),ee.call(e,e.media,\"volumechange\")}}),Object.defineProperty(e.media,\"currentSrc\",{get:()=>s.getVideoUrl()}),Object.defineProperty(e.media,\"ended\",{get:()=>e.currentTime===e.duration});const o=s.getAvailablePlaybackRates();e.options.speed=o.filter((t=>e.config.speed.options.includes(t))),e.supported.ui&&t.customControls&&e.media.setAttribute(\"tabindex\",-1),ee.call(e,e.media,\"timeupdate\"),ee.call(e,e.media,\"durationchange\"),clearInterval(e.timers.buffering),e.timers.buffering=setInterval((()=>{e.media.buffered=s.getVideoLoadedFraction(),(null===e.media.lastBuffered||e.media.lastBufferedUe.build.call(e)),50)},onStateChange(i){const s=i.target;clearInterval(e.timers.playing);switch(e.media.seeking&&[1,2].includes(i.data)&&(e.media.seeking=!1,ee.call(e,e.media,\"seeked\")),i.data){case-1:ee.call(e,e.media,\"timeupdate\"),e.media.buffered=s.getVideoLoadedFraction(),ee.call(e,e.media,\"progress\");break;case 0:Ye.call(e,!1),e.media.loop?(s.stopVideo(),s.playVideo()):ee.call(e,e.media,\"ended\");break;case 1:t.customControls&&!e.config.autoplay&&e.media.paused&&!e.embed.hasPlayed?e.media.pause():(Ye.call(e,!0),ee.call(e,e.media,\"playing\"),e.timers.playing=setInterval((()=>{ee.call(e,e.media,\"timeupdate\")}),50),e.media.duration!==s.getDuration()&&(e.media.duration=s.getDuration(),ee.call(e,e.media,\"durationchange\")));break;case 2:e.muted||e.embed.unMute(),Ye.call(e,!1);break;case 3:ee.call(e,e.media,\"waiting\")}ee.call(e,e.elements.container,\"statechange\",!1,{code:i.data})}}})}},Je={setup(){this.media?(F(this.elements.container,this.config.classNames.type.replace(\"{0}\",this.type),!0),F(this.elements.container,this.config.classNames.provider.replace(\"{0}\",this.provider),!0),this.isEmbed&&F(this.elements.container,this.config.classNames.type.replace(\"{0}\",\"video\"),!0),this.isVideo&&(this.elements.wrapper=O(\"div\",{class:this.config.classNames.video}),_(this.media,this.elements.wrapper),this.elements.poster=O(\"div\",{class:this.config.classNames.poster}),this.elements.wrapper.appendChild(this.elements.poster)),this.isHTML5?me.setup.call(this):this.isYouTube?Xe.setup.call(this):this.isVimeo&&Ke.setup.call(this)):this.debug.warn(\"No media element found!\")}};class Ge{constructor(e){t(this,\"load\",(()=>{this.enabled&&(A.object(window.google)&&A.object(window.google.ima)?this.ready():We(this.player.config.urls.googleIMA.sdk).then((()=>{this.ready()})).catch((()=>{this.trigger(\"error\",new Error(\"Google IMA SDK failed to load\"))})))})),t(this,\"ready\",(()=>{var e;this.enabled||((e=this).manager&&e.manager.destroy(),e.elements.displayContainer&&e.elements.displayContainer.destroy(),e.elements.container.remove()),this.startSafetyTimer(12e3,\"ready()\"),this.managerPromise.then((()=>{this.clearSafetyTimer(\"onAdsManagerLoaded()\")})),this.listeners(),this.setupIMA()})),t(this,\"setupIMA\",(()=>{this.elements.container=O(\"div\",{class:this.player.config.classNames.ads}),this.player.elements.container.appendChild(this.elements.container),google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED),google.ima.settings.setLocale(this.player.config.ads.language),google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline),this.elements.displayContainer=new google.ima.AdDisplayContainer(this.elements.container,this.player.media),this.loader=new google.ima.AdsLoader(this.elements.displayContainer),this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED,(e=>this.onAdsManagerLoaded(e)),!1),this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR,(e=>this.onAdError(e)),!1),this.requestAds()})),t(this,\"requestAds\",(()=>{const{container:e}=this.player.elements;try{const t=new google.ima.AdsRequest;t.adTagUrl=this.tagUrl,t.linearAdSlotWidth=e.offsetWidth,t.linearAdSlotHeight=e.offsetHeight,t.nonLinearAdSlotWidth=e.offsetWidth,t.nonLinearAdSlotHeight=e.offsetHeight,t.forceNonLinearFullSlot=!1,t.setAdWillPlayMuted(!this.player.muted),this.loader.requestAds(t)}catch(e){this.onAdError(e)}})),t(this,\"pollCountdown\",((e=!1)=>{if(!e)return clearInterval(this.countdownTimer),void this.elements.container.removeAttribute(\"data-badge-text\");this.countdownTimer=setInterval((()=>{const e=Pe(Math.max(this.manager.getRemainingTime(),0)),t=`${we.get(\"advertisement\",this.player.config)} - ${e}`;this.elements.container.setAttribute(\"data-badge-text\",t)}),100)})),t(this,\"onAdsManagerLoaded\",(e=>{if(!this.enabled)return;const t=new google.ima.AdsRenderingSettings;t.restoreCustomPlaybackStateOnAdBreakComplete=!0,t.enablePreloading=!0,this.manager=e.getAdsManager(this.player,t),this.cuePoints=this.manager.getCuePoints(),this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR,(e=>this.onAdError(e))),Object.keys(google.ima.AdEvent.Type).forEach((e=>{this.manager.addEventListener(google.ima.AdEvent.Type[e],(e=>this.onAdEvent(e)))})),this.trigger(\"loaded\")})),t(this,\"addCuePoints\",(()=>{A.empty(this.cuePoints)||this.cuePoints.forEach((e=>{if(0!==e&&-1!==e&&e{const{container:t}=this.player.elements,i=e.getAd(),s=e.getAdData();switch((e=>{ee.call(this.player,this.player.media,`ads${e.replace(/_/g,\"\").toLowerCase()}`)})(e.type),e.type){case google.ima.AdEvent.Type.LOADED:this.trigger(\"loaded\"),this.pollCountdown(!0),i.isLinear()||(i.width=t.offsetWidth,i.height=t.offsetHeight);break;case google.ima.AdEvent.Type.STARTED:this.manager.setVolume(this.player.volume);break;case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:this.player.ended?this.loadAds():this.loader.contentComplete();break;case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:this.pauseContent();break;case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:this.pollCountdown(),this.resumeContent();break;case google.ima.AdEvent.Type.LOG:s.adError&&this.player.debug.warn(`Non-fatal ad error: ${s.adError.getMessage()}`)}})),t(this,\"onAdError\",(e=>{this.cancel(),this.player.debug.warn(\"Ads error\",e)})),t(this,\"listeners\",(()=>{const{container:e}=this.player.elements;let t;this.player.on(\"canplay\",(()=>{this.addCuePoints()})),this.player.on(\"ended\",(()=>{this.loader.contentComplete()})),this.player.on(\"timeupdate\",(()=>{t=this.player.currentTime})),this.player.on(\"seeked\",(()=>{const e=this.player.currentTime;A.empty(this.cuePoints)||this.cuePoints.forEach(((i,s)=>{t{const{container:e}=this.player.elements;this.managerPromise||this.resumeContent(),this.managerPromise.then((()=>{this.manager.setVolume(this.player.volume),this.elements.displayContainer.initialize();try{this.initialized||(this.manager.init(e.offsetWidth,e.offsetHeight,google.ima.ViewMode.NORMAL),this.manager.start()),this.initialized=!0}catch(e){this.onAdError(e)}})).catch((()=>{}))})),t(this,\"resumeContent\",(()=>{this.elements.container.style.zIndex=\"\",this.playing=!1,se(this.player.media.play())})),t(this,\"pauseContent\",(()=>{this.elements.container.style.zIndex=3,this.playing=!0,this.player.media.pause()})),t(this,\"cancel\",(()=>{this.initialized&&this.resumeContent(),this.trigger(\"error\"),this.loadAds()})),t(this,\"loadAds\",(()=>{this.managerPromise.then((()=>{this.manager&&this.manager.destroy(),this.managerPromise=new Promise((e=>{this.on(\"loaded\",e),this.player.debug.log(this.manager)})),this.initialized=!1,this.requestAds()})).catch((()=>{}))})),t(this,\"trigger\",((e,...t)=>{const i=this.events[e];A.array(i)&&i.forEach((e=>{A.function(e)&&e.apply(this,t)}))})),t(this,\"on\",((e,t)=>(A.array(this.events[e])||(this.events[e]=[]),this.events[e].push(t),this))),t(this,\"startSafetyTimer\",((e,t)=>{this.player.debug.log(`Safety timer invoked from: ${t}`),this.safetyTimer=setTimeout((()=>{this.cancel(),this.clearSafetyTimer(\"startSafetyTimer()\")}),e)})),t(this,\"clearSafetyTimer\",(e=>{A.nullOrUndefined(this.safetyTimer)||(this.player.debug.log(`Safety timer cleared from: ${e}`),clearTimeout(this.safetyTimer),this.safetyTimer=null)})),this.player=e,this.config=e.config.ads,this.playing=!1,this.initialized=!1,this.elements={container:null,displayContainer:null},this.manager=null,this.loader=null,this.cuePoints=null,this.events={},this.safetyTimer=null,this.countdownTimer=null,this.managerPromise=new Promise(((e,t)=>{this.on(\"loaded\",e),this.on(\"error\",t)})),this.load()}get enabled(){const{config:e}=this;return this.player.isHTML5&&this.player.isVideo&&e.enabled&&(!A.empty(e.publisherId)||A.url(e.tagUrl))}get tagUrl(){const{config:e}=this;if(A.url(e.tagUrl))return e.tagUrl;return`https://go.aniview.com/api/adserver6/vast/?${Le({AV_PUBLISHERID:\"58c25bb0073ef448b1087ad6\",AV_CHANNELID:\"5a0458dc28a06145e4519d21\",AV_URL:window.location.hostname,cb:Date.now(),AV_WIDTH:640,AV_HEIGHT:480,AV_CDIM2:e.publisherId})}`}}function Ze(e=0,t=0,i=255){return Math.min(Math.max(e,t),i)}const et=e=>{const t=[];return e.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/).forEach((e=>{const i={};e.split(/\\r\\n|\\n|\\r/).forEach((e=>{if(A.number(i.startTime)){if(!A.empty(e.trim())&&A.empty(i.text)){const t=e.trim().split(\"#xywh=\");[i.text]=t,t[1]&&([i.x,i.y,i.w,i.h]=t[1].split(\",\"))}}else{const t=e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);t&&(i.startTime=60*Number(t[1]||0)*60+60*Number(t[2])+Number(t[3])+Number(`0.${t[4]}`),i.endTime=60*Number(t[6]||0)*60+60*Number(t[7])+Number(t[8])+Number(`0.${t[9]}`))}})),i.text&&t.push(i)})),t},tt=(e,t)=>{const i={};return e>t.width/t.height?(i.width=t.width,i.height=1/e*t.width):(i.height=t.height,i.width=e*t.height),i};class it{constructor(e){t(this,\"load\",(()=>{this.player.elements.display.seekTooltip&&(this.player.elements.display.seekTooltip.hidden=this.enabled),this.enabled&&this.getThumbnails().then((()=>{this.enabled&&(this.render(),this.determineContainerAutoSizing(),this.listeners(),this.loaded=!0)}))})),t(this,\"getThumbnails\",(()=>new Promise((e=>{const{src:t}=this.player.config.previewThumbnails;if(A.empty(t))throw new Error(\"Missing previewThumbnails.src config attribute\");const i=()=>{this.thumbnails.sort(((e,t)=>e.height-t.height)),this.player.debug.log(\"Preview thumbnails\",this.thumbnails),e()};if(A.function(t))t((e=>{this.thumbnails=e,i()}));else{const e=(A.string(t)?[t]:t).map((e=>this.getThumbnail(e)));Promise.all(e).then(i)}})))),t(this,\"getThumbnail\",(e=>new Promise((t=>{ke(e).then((i=>{const s={frames:et(i),height:null,urlPrefix:\"\"};s.frames[0].text.startsWith(\"/\")||s.frames[0].text.startsWith(\"http://\")||s.frames[0].text.startsWith(\"https://\")||(s.urlPrefix=e.substring(0,e.lastIndexOf(\"/\")+1));const n=new Image;n.onload=()=>{s.height=n.naturalHeight,s.width=n.naturalWidth,this.thumbnails.push(s),t()},n.src=s.urlPrefix+s.frames[0].text}))})))),t(this,\"startMove\",(e=>{if(this.loaded&&A.event(e)&&[\"touchmove\",\"mousemove\"].includes(e.type)&&this.player.media.duration){if(\"touchmove\"===e.type)this.seekTime=this.player.media.duration*(this.player.elements.inputs.seek.value/100);else{var t,i;const s=this.player.elements.progress.getBoundingClientRect(),n=100/s.width*(e.pageX-s.left);this.seekTime=this.player.media.duration*(n/100),this.seekTimethis.player.media.duration-1&&(this.seekTime=this.player.media.duration-1),this.mousePosX=e.pageX,this.elements.thumb.time.innerText=Pe(this.seekTime);const a=null===(t=this.player.config.markers)||void 0===t||null===(i=t.points)||void 0===i?void 0:i.find((({time:e})=>e===Math.round(this.seekTime)));a&&this.elements.thumb.time.insertAdjacentHTML(\"afterbegin\",`${a.label}`)}this.showImageAtCurrentTime()}})),t(this,\"endMove\",(()=>{this.toggleThumbContainer(!1,!0)})),t(this,\"startScrubbing\",(e=>{(A.nullOrUndefined(e.button)||!1===e.button||0===e.button)&&(this.mouseDown=!0,this.player.media.duration&&(this.toggleScrubbingContainer(!0),this.toggleThumbContainer(!1,!0),this.showImageAtCurrentTime()))})),t(this,\"endScrubbing\",(()=>{this.mouseDown=!1,Math.ceil(this.lastTime)===Math.ceil(this.player.media.currentTime)?this.toggleScrubbingContainer(!1):Z.call(this.player,this.player.media,\"timeupdate\",(()=>{this.mouseDown||this.toggleScrubbingContainer(!1)}))})),t(this,\"listeners\",(()=>{this.player.on(\"play\",(()=>{this.toggleThumbContainer(!1,!0)})),this.player.on(\"seeked\",(()=>{this.toggleThumbContainer(!1)})),this.player.on(\"timeupdate\",(()=>{this.lastTime=this.player.media.currentTime}))})),t(this,\"render\",(()=>{this.elements.thumb.container=O(\"div\",{class:this.player.config.classNames.previewThumbnails.thumbContainer}),this.elements.thumb.imageContainer=O(\"div\",{class:this.player.config.classNames.previewThumbnails.imageContainer}),this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);const e=O(\"div\",{class:this.player.config.classNames.previewThumbnails.timeContainer});this.elements.thumb.time=O(\"span\",{},\"00:00\"),e.appendChild(this.elements.thumb.time),this.elements.thumb.imageContainer.appendChild(e),A.element(this.player.elements.progress)&&this.player.elements.progress.appendChild(this.elements.thumb.container),this.elements.scrubbing.container=O(\"div\",{class:this.player.config.classNames.previewThumbnails.scrubbingContainer}),this.player.elements.wrapper.appendChild(this.elements.scrubbing.container)})),t(this,\"destroy\",(()=>{this.elements.thumb.container&&this.elements.thumb.container.remove(),this.elements.scrubbing.container&&this.elements.scrubbing.container.remove()})),t(this,\"showImageAtCurrentTime\",(()=>{this.mouseDown?this.setScrubbingContainerSize():this.setThumbContainerSizeAndPos();const e=this.thumbnails[0].frames.findIndex((e=>this.seekTime>=e.startTime&&this.seekTime=0;let i=0;this.mouseDown||this.toggleThumbContainer(t),t&&(this.thumbnails.forEach(((t,s)=>{this.loadedImages.includes(t.frames[e].text)&&(i=s)})),e!==this.showingThumb&&(this.showingThumb=e,this.loadImage(i)))})),t(this,\"loadImage\",((e=0)=>{const t=this.showingThumb,i=this.thumbnails[e],{urlPrefix:s}=i,n=i.frames[t],a=i.frames[t].text,r=s+a;if(this.currentImageElement&&this.currentImageElement.dataset.filename===a)this.showImage(this.currentImageElement,n,e,t,a,!1),this.currentImageElement.dataset.index=t,this.removeOldImages(this.currentImageElement);else{this.loadingImage&&this.usingSprites&&(this.loadingImage.onload=null);const i=new Image;i.src=r,i.dataset.index=t,i.dataset.filename=a,this.showingThumbFilename=a,this.player.debug.log(`Loading image: ${r}`),i.onload=()=>this.showImage(i,n,e,t,a,!0),this.loadingImage=i,this.removeOldImages(i)}})),t(this,\"showImage\",((e,t,i,s,n,a=!0)=>{this.player.debug.log(`Showing thumb: ${n}. num: ${s}. qual: ${i}. newimg: ${a}`),this.setImageSizeAndOffset(e,t),a&&(this.currentImageContainer.appendChild(e),this.currentImageElement=e,this.loadedImages.includes(n)||this.loadedImages.push(n)),this.preloadNearby(s,!0).then(this.preloadNearby(s,!1)).then(this.getHigherQuality(i,e,t,n))})),t(this,\"removeOldImages\",(e=>{Array.from(this.currentImageContainer.children).forEach((t=>{if(\"img\"!==t.tagName.toLowerCase())return;const i=this.usingSprites?500:1e3;if(t.dataset.index!==e.dataset.index&&!t.dataset.deleting){t.dataset.deleting=!0;const{currentImageContainer:e}=this;setTimeout((()=>{e.removeChild(t),this.player.debug.log(`Removing thumb: ${t.dataset.filename}`)}),i)}}))})),t(this,\"preloadNearby\",((e,t=!0)=>new Promise((i=>{setTimeout((()=>{const s=this.thumbnails[0].frames[e].text;if(this.showingThumbFilename===s){let n;n=t?this.thumbnails[0].frames.slice(e):this.thumbnails[0].frames.slice(0,e).reverse();let a=!1;n.forEach((e=>{const t=e.text;if(t!==s&&!this.loadedImages.includes(t)){a=!0,this.player.debug.log(`Preloading thumb filename: ${t}`);const{urlPrefix:e}=this.thumbnails[0],s=e+t,n=new Image;n.src=s,n.onload=()=>{this.player.debug.log(`Preloaded thumb filename: ${t}`),this.loadedImages.includes(t)||this.loadedImages.push(t),i()}}})),a||i()}}),300)})))),t(this,\"getHigherQuality\",((e,t,i,s)=>{if(e{const i=this.player.config.classNames.previewThumbnails.thumbContainerShown;this.elements.thumb.container.classList.toggle(i,e),!e&&t&&(this.showingThumb=null,this.showingThumbFilename=null)})),t(this,\"toggleScrubbingContainer\",((e=!1)=>{const t=this.player.config.classNames.previewThumbnails.scrubbingContainerShown;this.elements.scrubbing.container.classList.toggle(t,e),e||(this.showingThumb=null,this.showingThumbFilename=null)})),t(this,\"determineContainerAutoSizing\",(()=>{(this.elements.thumb.imageContainer.clientHeight>20||this.elements.thumb.imageContainer.clientWidth>20)&&(this.sizeSpecifiedInCSS=!0)})),t(this,\"setThumbContainerSizeAndPos\",(()=>{const{imageContainer:e}=this.elements.thumb;if(this.sizeSpecifiedInCSS){if(e.clientHeight>20&&e.clientWidth{const e=this.player.elements.progress.getBoundingClientRect(),t=this.player.elements.container.getBoundingClientRect(),{container:i}=this.elements.thumb,s=t.left-e.left+10,n=t.right-e.left-i.clientWidth-10,a=this.mousePosX-e.left-i.clientWidth/2,r=Ze(a,s,n);i.style.left=`${r}px`,i.style.setProperty(\"--preview-arrow-offset\",a-r+\"px\")})),t(this,\"setScrubbingContainerSize\",(()=>{const{width:e,height:t}=tt(this.thumbAspectRatio,{width:this.player.media.clientWidth,height:this.player.media.clientHeight});this.elements.scrubbing.container.style.width=`${e}px`,this.elements.scrubbing.container.style.height=`${t}px`})),t(this,\"setImageSizeAndOffset\",((e,t)=>{if(!this.usingSprites)return;const i=this.thumbContainerHeight/t.h;e.style.height=e.naturalHeight*i+\"px\",e.style.width=e.naturalWidth*i+\"px\",e.style.left=`-${t.x*i}px`,e.style.top=`-${t.y*i}px`})),this.player=e,this.thumbnails=[],this.loaded=!1,this.lastMouseMoveTime=Date.now(),this.mouseDown=!1,this.loadedImages=[],this.elements={thumb:{},scrubbing:{}},this.load()}get enabled(){return this.player.isHTML5&&this.player.isVideo&&this.player.config.previewThumbnails.enabled}get currentImageContainer(){return this.mouseDown?this.elements.scrubbing.container:this.elements.thumb.imageContainer}get usingSprites(){return Object.keys(this.thumbnails[0].frames[0]).includes(\"w\")}get thumbAspectRatio(){return this.usingSprites?this.thumbnails[0].frames[0].w/this.thumbnails[0].frames[0].h:this.thumbnails[0].width/this.thumbnails[0].height}get thumbContainerHeight(){if(this.mouseDown){const{height:e}=tt(this.thumbAspectRatio,{width:this.player.media.clientWidth,height:this.player.media.clientHeight});return e}return this.sizeSpecifiedInCSS?this.elements.thumb.imageContainer.clientHeight:Math.floor(this.player.media.clientWidth/this.thumbAspectRatio/4)}get currentImageElement(){return this.mouseDown?this.currentScrubbingImageElement:this.currentThumbnailImageElement}set currentImageElement(e){this.mouseDown?this.currentScrubbingImageElement=e:this.currentThumbnailImageElement=e}}const st={insertElements(e,t){A.string(t)?$(e,this.media,{src:t}):A.array(t)&&t.forEach((t=>{$(e,this.media,t)}))},change(e){L(e,\"sources.length\")?(me.cancelRequests.call(this),this.destroy.call(this,(()=>{this.options.quality=[],j(this.media),this.media=null,A.element(this.elements.container)&&this.elements.container.removeAttribute(\"class\");const{sources:t,type:i}=e,[{provider:s=$e.html5,src:n}]=t,a=\"html5\"===s?i:\"div\",r=\"html5\"===s?{}:{src:n};Object.assign(this,{provider:s,type:i,supported:Y.check(i,s,this.config.playsinline),media:O(a,r)}),this.elements.container.appendChild(this.media),A.boolean(e.autoplay)&&(this.config.autoplay=e.autoplay),this.isHTML5&&(this.config.crossorigin&&this.media.setAttribute(\"crossorigin\",\"\"),this.config.autoplay&&this.media.setAttribute(\"autoplay\",\"\"),A.empty(e.poster)||(this.poster=e.poster),this.config.loop.active&&this.media.setAttribute(\"loop\",\"\"),this.config.muted&&this.media.setAttribute(\"muted\",\"\"),this.config.playsinline&&this.media.setAttribute(\"playsinline\",\"\")),Ue.addStyleHook.call(this),this.isHTML5&&st.insertElements.call(this,\"source\",t),this.config.title=e.title,Je.setup.call(this),this.isHTML5&&Object.keys(e).includes(\"tracks\")&&st.insertElements.call(this,\"track\",e.tracks),(this.isHTML5||this.isEmbed&&!this.supported.ui)&&Ue.build.call(this),this.isHTML5&&this.media.load(),A.empty(e.previewThumbnails)||(Object.assign(this.config.previewThumbnails,e.previewThumbnails),this.previewThumbnails&&this.previewThumbnails.loaded&&(this.previewThumbnails.destroy(),this.previewThumbnails=null),this.config.previewThumbnails.enabled&&(this.previewThumbnails=new it(this))),this.fullscreen.update()}),!0)):this.debug.warn(\"Invalid source format\")}};class nt{constructor(e,i){if(t(this,\"play\",(()=>A.function(this.media.play)?(this.ads&&this.ads.enabled&&this.ads.managerPromise.then((()=>this.ads.play())).catch((()=>se(this.media.play()))),this.media.play()):null)),t(this,\"pause\",(()=>this.playing&&A.function(this.media.pause)?this.media.pause():null)),t(this,\"togglePlay\",(e=>(A.boolean(e)?e:!this.playing)?this.play():this.pause())),t(this,\"stop\",(()=>{this.isHTML5?(this.pause(),this.restart()):A.function(this.media.stop)&&this.media.stop()})),t(this,\"restart\",(()=>{this.currentTime=0})),t(this,\"rewind\",(e=>{this.currentTime-=A.number(e)?e:this.config.seekTime})),t(this,\"forward\",(e=>{this.currentTime+=A.number(e)?e:this.config.seekTime})),t(this,\"increaseVolume\",(e=>{const t=this.media.muted?0:this.volume;this.volume=t+(A.number(e)?e:0)})),t(this,\"decreaseVolume\",(e=>{this.increaseVolume(-e)})),t(this,\"airplay\",(()=>{Y.airplay&&this.media.webkitShowPlaybackTargetPicker()})),t(this,\"toggleControls\",(e=>{if(this.supported.ui&&!this.isAudio){const t=U(this.elements.container,this.config.classNames.hideControls),i=void 0===e?void 0:!e,s=F(this.elements.container,this.config.classNames.hideControls,i);if(s&&A.array(this.config.controls)&&this.config.controls.includes(\"settings\")&&!A.empty(this.config.settings)&&Me.toggleMenu.call(this,!1),s!==t){const e=s?\"controlshidden\":\"controlsshown\";ee.call(this,this.media,e)}return!s}return!1})),t(this,\"on\",((e,t)=>{J.call(this,this.elements.container,e,t)})),t(this,\"once\",((e,t)=>{Z.call(this,this.elements.container,e,t)})),t(this,\"off\",((e,t)=>{G(this.elements.container,e,t)})),t(this,\"destroy\",((e,t=!1)=>{if(!this.ready)return;const i=()=>{document.body.style.overflow=\"\",this.embed=null,t?(Object.keys(this.elements).length&&(j(this.elements.buttons.play),j(this.elements.captions),j(this.elements.controls),j(this.elements.wrapper),this.elements.buttons.play=null,this.elements.captions=null,this.elements.controls=null,this.elements.wrapper=null),A.function(e)&&e()):(te.call(this),me.cancelRequests.call(this),D(this.elements.original,this.elements.container),ee.call(this,this.elements.original,\"destroyed\",!0),A.function(e)&&e.call(this.elements.original),this.ready=!1,setTimeout((()=>{this.elements=null,this.media=null}),200))};this.stop(),clearTimeout(this.timers.loading),clearTimeout(this.timers.controls),clearTimeout(this.timers.resized),this.isHTML5?(Ue.toggleNativeControls.call(this,!0),i()):this.isYouTube?(clearInterval(this.timers.buffering),clearInterval(this.timers.playing),null!==this.embed&&A.function(this.embed.destroy)&&this.embed.destroy(),i()):this.isVimeo&&(null!==this.embed&&this.embed.unload().then(i),setTimeout(i,200))})),t(this,\"supports\",(e=>Y.mime.call(this,e))),this.timers={},this.ready=!1,this.loading=!1,this.failed=!1,this.touch=Y.touch,this.media=e,this.config=N({},_e,nt.defaults,i||{},(()=>{try{return JSON.parse(this.media.getAttribute(\"data-plyr-config\"))}catch(e){return{}}})()),this.elements={container:null,fullscreen:null,captions:null,buttons:{},display:{},progress:{},inputs:{},settings:{popup:null,menu:null,panels:{},buttons:{}}},this.captions={active:null,currentTrack:-1,meta:new WeakMap},this.fullscreen={active:!1},this.options={speed:[],quality:[]},this.debug=new qe(this.config.debug),this.debug.log(\"Config\",this.config),this.debug.log(\"Support\",Y),A.nullOrUndefined(this.media)||!A.element(this.media))return void this.debug.error(\"Setup failed: no suitable element passed\");if(this.media.plyr)return void this.debug.warn(\"Target already setup\");if(!this.config.enabled)return void this.debug.error(\"Setup failed: disabled by config\");if(!Y.check().api)return void this.debug.error(\"Setup failed: no support\");const s=this.media.cloneNode(!0);s.autoplay=!1,this.elements.original=s;const n=this.media.tagName.toLowerCase();let a=null,r=null;switch(n){case\"div\":if(a=this.media.querySelector(\"iframe\"),A.element(a)){if(r=xe(a.getAttribute(\"src\")),this.provider=function(e){return/^(https?:\\/\\/)?(www\\.)?(youtube\\.com|youtube-nocookie\\.com|youtu\\.?be)\\/.+$/.test(e)?$e.youtube:/^https?:\\/\\/player.vimeo.com\\/video\\/\\d{0,9}(?=\\b|\\/)/.test(e)?$e.vimeo:null}(r.toString()),this.elements.container=this.media,this.media=a,this.elements.container.className=\"\",r.search.length){const e=[\"1\",\"true\"];e.includes(r.searchParams.get(\"autoplay\"))&&(this.config.autoplay=!0),e.includes(r.searchParams.get(\"loop\"))&&(this.config.loop.active=!0),this.isYouTube?(this.config.playsinline=e.includes(r.searchParams.get(\"playsinline\")),this.config.youtube.hl=r.searchParams.get(\"hl\")):this.config.playsinline=!0}}else this.provider=this.media.getAttribute(this.config.attributes.embed.provider),this.media.removeAttribute(this.config.attributes.embed.provider);if(A.empty(this.provider)||!Object.values($e).includes(this.provider))return void this.debug.error(\"Setup failed: Invalid provider\");this.type=Re;break;case\"video\":case\"audio\":this.type=n,this.provider=$e.html5,this.media.hasAttribute(\"crossorigin\")&&(this.config.crossorigin=!0),this.media.hasAttribute(\"autoplay\")&&(this.config.autoplay=!0),(this.media.hasAttribute(\"playsinline\")||this.media.hasAttribute(\"webkit-playsinline\"))&&(this.config.playsinline=!0),this.media.hasAttribute(\"muted\")&&(this.config.muted=!0),this.media.hasAttribute(\"loop\")&&(this.config.loop.active=!0);break;default:return void this.debug.error(\"Setup failed: unsupported type\")}this.supported=Y.check(this.type,this.provider),this.supported.api?(this.eventListeners=[],this.listeners=new Ve(this),this.storage=new Te(this),this.media.plyr=this,A.element(this.elements.container)||(this.elements.container=O(\"div\"),_(this.media,this.elements.container)),Ue.migrateStyles.call(this),Ue.addStyleHook.call(this),Je.setup.call(this),this.config.debug&&J.call(this,this.elements.container,this.config.events.join(\" \"),(e=>{this.debug.log(`event: ${e.type}`)})),this.fullscreen=new He(this),(this.isHTML5||this.isEmbed&&!this.supported.ui)&&Ue.build.call(this),this.listeners.container(),this.listeners.global(),this.config.ads.enabled&&(this.ads=new Ge(this)),this.isHTML5&&this.config.autoplay&&this.once(\"canplay\",(()=>se(this.play()))),this.lastSeekTime=0,this.config.previewThumbnails.enabled&&(this.previewThumbnails=new it(this))):this.debug.error(\"Setup failed: no support\")}get isHTML5(){return this.provider===$e.html5}get isEmbed(){return this.isYouTube||this.isVimeo}get isYouTube(){return this.provider===$e.youtube}get isVimeo(){return this.provider===$e.vimeo}get isVideo(){return this.type===Re}get isAudio(){return this.type===je}get playing(){return Boolean(this.ready&&!this.paused&&!this.ended)}get paused(){return Boolean(this.media.paused)}get stopped(){return Boolean(this.paused&&0===this.currentTime)}get ended(){return Boolean(this.media.ended)}set currentTime(e){if(!this.duration)return;const t=A.number(e)&&e>0;this.media.currentTime=t?Math.min(e,this.duration):0,this.debug.log(`Seeking to ${this.currentTime} seconds`)}get currentTime(){return Number(this.media.currentTime)}get buffered(){const{buffered:e}=this.media;return A.number(e)?e:e&&e.length&&this.duration>0?e.end(0)/this.duration:0}get seeking(){return Boolean(this.media.seeking)}get duration(){const e=parseFloat(this.config.duration),t=(this.media||{}).duration,i=A.number(t)&&t!==1/0?t:0;return e||i}set volume(e){let t=e;A.string(t)&&(t=Number(t)),A.number(t)||(t=this.storage.get(\"volume\")),A.number(t)||({volume:t}=this.config),t>1&&(t=1),t0&&(this.muted=!1)}get volume(){return Number(this.media.volume)}set muted(e){let t=e;A.boolean(t)||(t=this.storage.get(\"muted\")),A.boolean(t)||(t=this.config.muted),this.config.muted=t,this.media.muted=t}get muted(){return Boolean(this.media.muted)}get hasAudio(){return!this.isHTML5||(!!this.isAudio||(Boolean(this.media.mozHasAudio)||Boolean(this.media.webkitAudioDecodedByteCount)||Boolean(this.media.audioTracks&&this.media.audioTracks.length)))}set speed(e){let t=null;A.number(e)&&(t=e),A.number(t)||(t=this.storage.get(\"speed\")),A.number(t)||(t=this.config.speed.selected);const{minimumSpeed:i,maximumSpeed:s}=this;t=Ze(t,i,s),this.config.speed.selected=t,setTimeout((()=>{this.media&&(this.media.playbackRate=t)}),0)}get speed(){return Number(this.media.playbackRate)}get minimumSpeed(){return this.isYouTube?Math.min(...this.options.speed):this.isVimeo?.5:.0625}get maximumSpeed(){return this.isYouTube?Math.max(...this.options.speed):this.isVimeo?2:16}set quality(e){const t=this.config.quality,i=this.options.quality;if(!i.length)return;let s=[!A.empty(e)&&Number(e),this.storage.get(\"quality\"),t.selected,t.default].find(A.number),n=!0;if(!i.includes(s)){const e=ae(i,s);this.debug.warn(`Unsupported quality option: ${s}, using ${e} instead`),s=e,n=!1}t.selected=s,this.media.quality=s,n&&this.storage.set({quality:s})}get quality(){return this.media.quality}set loop(e){const t=A.boolean(e)?e:this.config.loop.active;this.config.loop.active=t,this.media.loop=t}get loop(){return Boolean(this.media.loop)}set source(e){st.change.call(this,e)}get source(){return this.media.currentSrc}get download(){const{download:e}=this.config.urls;return A.url(e)?e:this.source}set download(e){A.url(e)&&(this.config.urls.download=e,Me.setDownloadUrl.call(this))}set poster(e){this.isVideo?Ue.setPoster.call(this,e,!1).catch((()=>{})):this.debug.warn(\"Poster can only be set for video\")}get poster(){return this.isVideo?this.media.getAttribute(\"poster\")||this.media.getAttribute(\"data-poster\"):null}get ratio(){if(!this.isVideo)return null;const e=ce(ue.call(this));return A.array(e)?e.join(\":\"):e}set ratio(e){this.isVideo?A.string(e)&&le(e)?(this.config.ratio=ce(e),he.call(this)):this.debug.error(`Invalid aspect ratio specified (${e})`):this.debug.warn(\"Aspect ratio can only be set for video\")}set autoplay(e){this.config.autoplay=A.boolean(e)?e:this.config.autoplay}get autoplay(){return Boolean(this.config.autoplay)}toggleCaptions(e){Ne.toggle.call(this,e,!1)}set currentTrack(e){Ne.set.call(this,e,!1),Ne.setup.call(this)}get currentTrack(){const{toggled:e,currentTrack:t}=this.captions;return e?t:-1}set language(e){Ne.setLanguage.call(this,e,!1)}get language(){return(Ne.getCurrentTrack.call(this)||{}).language}set pip(e){if(!Y.pip)return;const t=A.boolean(e)?e:!this.pip;A.function(this.media.webkitSetPresentationMode)&&this.media.webkitSetPresentationMode(t?Ie:Oe),A.function(this.media.requestPictureInPicture)&&(!this.pip&&t?this.media.requestPictureInPicture():this.pip&&!t&&document.exitPictureInPicture())}get pip(){return Y.pip?A.empty(this.media.webkitPresentationMode)?this.media===document.pictureInPictureElement:this.media.webkitPresentationMode===Ie:null}setPreviewThumbnails(e){this.previewThumbnails&&this.previewThumbnails.loaded&&(this.previewThumbnails.destroy(),this.previewThumbnails=null),Object.assign(this.config.previewThumbnails,e),this.config.previewThumbnails.enabled&&(this.previewThumbnails=new it(this))}static supported(e,t){return Y.check(e,t)}static loadSprite(e,t){return Ee(e,t)}static setup(e,t={}){let i=null;return A.string(e)?i=Array.from(document.querySelectorAll(e)):A.nodeList(e)?i=Array.from(e):A.array(e)&&(i=e.filter(A.element)),A.empty(i)?null:i.map((e=>new nt(e,t)))}}var at;return nt.defaults=(at=_e,JSON.parse(JSON.stringify(at))),nt}));"}],"posts":[{"title":"Unity-编辑器 UI 开发优化框架 EditorUIExtension VE 篇","slug":"Unity-编辑器-UI-开发优化框架-EditorUIExtension-VisuelElement-篇","date":"2024-05-30T11:53:07.000Z","updated":"2024-05-31T17:58:47.337Z","comments":true,"path":"article/78043d7e1c5e/","link":"","permalink":"https://busyogg.github.io/article/78043d7e1c5e/","excerpt":"","text":"简介基于 VisualElement 的编辑器 UI 框架，目的是简化编辑器开发时的 UI 构建。利用特性标签进行 UI 的初始化。 对于变量，我们只需要打上对应的标签，就能够在 UI 面板上显示对应的 UI。 对于方法，我们只需要打上 Button 标签，就能够生成一个实现该方法的按钮。 同时，本框架还支持对 UI 的样式和布局进行有限的修改，同样也是通过特性实现。 UI 界面的渲染顺序按照编辑器脚本对象的声明顺序排序，布局的结构也要按照顺序声明，可以看作是以代码的形式绘制 UI。 本框架支持自定义拓展功能，具体的使用说明和拓展规则见： EditorUIExtention 文档 原理初始化特性我们通过基类初始化获取 Type，然后通过 Type 获取 members 并且按照声明顺序排序，之后通过遍历，在其循环体内根据对应的特性类别进行 UI 的渲染函数初始化。 初始化分为三种情况： 普通 UI。 列表。 Box。 所有初始化的 UI 元素都会存储到基类中，通过字段名可以获取到对应的 UI。 初始化 UI初始化 UI 就是判断 member 特性是否包含 E_Editor ，并且字段不是 List 类型。 然后我们根据 E_Editor 的类型来生成不同的 UI。每个 UI 我们都要调用样式的初始化方法，这样才能实现通过特性修改样式。由于 VisualElement 具有复杂的嵌套关系，因此在调用样式初始化方法的时候要注意传入的 UI 主体是正确的。 UI 的形式如下： graph LR; table_1[\"父容器标签输入框\"] 每个 UI 都有父容器，父容器本身不提供样式修改，只是构成 UI 的最上层单位。如果有需要的话可以自己添加样式修改的逻辑。 初始化列表初始化 UI 就是判断 member 特性是否包含 E_Editor ，并且字段是 List 类型。 列表的初始化与普通 UI 初始化略有不同，不过其内部 Item 的生成逻辑和普通 UI 是相同的。 目前列表不支持虚拟化。 列表结构如下： graph TD; subgraph outerTable[\"父容器\"] subgraph innerTable1[\"列表\"] table_1[\"列表元素1\"] table_2[\"列表元素2\"] end end 列表还衍生了添加列表元素和移除列表元素两个方法。 添加列表元素通过字段名获取对应的列表和字段，然后通过和列表初始化一样的方法来添加列表元素；移除列表元素的逻辑和添加类似，只是逻辑比添加简单一点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// &lt;summary&gt;/// 添加列表元素/// &lt;/summary&gt;/// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;protected void ListAdd(string id)&#123; VisualElement element = GetElement(id); VisualElement list = element.Children().ElementAt(1); FieldInfo field = _type.GetField(id, _flag); E_Editor editor = field.GetCustomAttribute&lt;E_Editor&gt;(); IList data = field.GetValue(this) as IList; data.Add(null); Action&lt;object&gt; setData = o =&gt; &#123; data[data.Count - 1] = o; &#125;; VisualElement subBox = new VisualElement(); list.Add(subBox); GenerateItem(subBox, field, editor.GetEType(), null, setData, true); RegisterDrag(subBox, list, data);&#125;/// &lt;summary&gt;/// 移除最后一个数组元素/// &lt;/summary&gt;/// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt;protected void ListRemove(string id)&#123; VisualElement element = GetElement(id); VisualElement list = element.Children().ElementAt(1); if (list.childCount == 0) &#123; Debug.LogWarning(&quot;没有元素了&quot;); return; &#125; list.RemoveAt(list.childCount - 1); FieldInfo field = _type.GetField(id, _flag); IList data = field.GetValue(this) as IList; data.RemoveAt(data.Count - 1);&#125; 初始化 Box初始化 Box 需要判断是否具有 VE_Box 特性，一般来说 VE_Box 不会与 E_Editor 混用。 初始化 Box 需要单独一个字段来创建 Box，字段为 string 类型，字段的值就是 Box 的名称，用于后面查找 Box。Box 的显示名称需要配合 E_Name 来设置。 如果有传入 _boxName ，那么创建的 Box 就会去查找相关的 Box，然后添加到里面，否则添加到根节点。 对于 UI 元素添加到 Box 来说，只需要打上 VE_Box 的特性，然后在构造函数传入 Box 的名字就可以。 初始化样式样式的初始化分为两种： UI 元素样式初始化。 Box 样式初始化。 Box 样式初始化相对简单，只需要根据对应的特性设置 style 即可。 UI 元素样式不仅需要设置 style，还因为设置 style 后会影响原来的伪类的样式，因此需要重新设置监听并修改不同情况下的 UI 元素样式。 Button UI 因为本身劫持了所有左键事件，因此需要额外的处理，详情见源码 初始化拖拽初始化拖拽我们对每个列表元素监听三个事件： 鼠标按下。 鼠标移动。 鼠标抬起。 鼠标按下的时候我们记录当前鼠标的位置、当前的元素（拖拽元素）和当前元素的 left 和 top。 鼠标移动的时候我们判断是否是第一次执行移动函数，是的话我们把所有元素都变成绝对布局，并且设置好 left 和 top。 然后我们添加一个空的元素到拖拽元素的索引位置作为占位元素，拖拽元素移动到容器最尾端。这样做是为了让拖拽元素显示在 UI 层级的最上层，并且不会扰乱原来列表的索引（因为 VisualElement 没有 zIndex）。 接着我们捕捉鼠标，这样其他 UI 元素不会被鼠标事件影响，鼠标超出当前元素也能够继续捕获事件。为什么不放在鼠标按下的时候，是因为当列表需要打开对象选择器的时候，捕获鼠标就无法触发这个事件。 鼠标在移动的时候实时修改拖拽元素的 left 和 top，就可以实现元素跟着鼠标移动了。 在鼠标抬起的时候，我们遍历列表子对象，查看是否有和拖拽元素包围盒相交的对象，如果有的话交换两个元素。 交换的过程如下： graph TD; A[\"查找相交元素索引\"] B[\"移除拖拽元素\"] C[\"插入拖拽元素到相交元素索引处\"] D[\"插入相交元素到拖拽元素的原索引处\"] E[\"交换列表中两个元素的值\"] A --> B --> C --> D --> E 然后我们把所有元素都变为相对布局，置 left 和 top 为 0。 如果父容器中存在占位元素，就移除（因为有可能只有按下没有移动，就不存在占位元素）。在有占位元素的情况下，判断是否有经过元素交换，没有的话就把拖拽元素插入回原来的索引。 最后重置各种状态，包括释放鼠标。 由于focus事件会阻止事件冒泡，会导致鼠标抬起事件无法触发，拖拽状态无法重置，因此我们在根节点监听鼠标左键按下的事件，然后在拖拽的鼠标移动事件中添加该判断条件，当focus的时候根节点的鼠标按下监听被阻止，此时判定鼠标移动的时候就判定为没有拖拽，从而解决这个问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/// &lt;summary&gt;/// 注册拖拽/// &lt;/summary&gt;/// &lt;param name=&quot;ele&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt;private void RegisterDrag(VisualElement ele, VisualElement parent, IList data)&#123; VisualElement empty = new VisualElement(); int defIndex = 0; bool isCapture = false; ele.RegisterCallback&lt;PointerDownEvent&gt;(evt =&gt; &#123; if (evt.button == 0) // 左键 &#123; _dragElement = ele; _defPos = evt.position; _defTL = new Vector2(_dragElement.resolvedStyle.left - _dragElement.resolvedStyle.marginLeft, _dragElement.resolvedStyle.top - _dragElement.resolvedStyle.marginTop); &#125; &#125;); ele.RegisterCallback&lt;PointerMoveEvent&gt;(evt =&gt; &#123; if (!isCapture &amp;&amp; _dragElement != null) &#123; ele.CapturePointer(evt.pointerId); isCapture = true; foreach (var child in parent.Children()) &#123; child.style.position = Position.Absolute; // Debug.Log(child.resolvedStyle.left); child.style.left = child.resolvedStyle.left - child.resolvedStyle.marginLeft; child.style.top = child.resolvedStyle.top - child.resolvedStyle.marginTop; &#125; //占位 defIndex = parent.IndexOf(_dragElement); parent.Insert(defIndex, empty); _dragElement.BringToFront(); &#125; if (_dragElement != null &amp;&amp; ele.HasPointerCapture(evt.pointerId)) &#123; Vector2 delta = new Vector2(evt.position.x, evt.position.y) - _defPos; _dragElement.style.top = _defTL.y + delta.y; _dragElement.style.left = _defTL.x + delta.x; &#125; &#125;); ele.RegisterCallback&lt;PointerUpEvent&gt;(evt =&gt; &#123; if (_dragElement != null) &#123; bool isExchange = false; foreach (var child in parent.Children()) &#123; if (child != _dragElement &amp;&amp; child.worldBound.Contains(evt.position)) &#123; //UI 交换 int insertIndex = parent.IndexOf(child); parent.Remove(_dragElement); parent.Insert(insertIndex, _dragElement); parent.Insert(defIndex, child); //数据交换 (data[defIndex], data[insertIndex]) = (data[insertIndex], data[defIndex]); isExchange = true; break; &#125; &#125; foreach (var child in parent.Children()) &#123; child.style.position = Position.Relative; child.style.left = 0; child.style.top = 0; &#125; if (parent.IndexOf(empty) != -1) &#123; parent.Remove(empty); if (!isExchange) &#123; parent.Insert(defIndex, _dragElement); &#125; &#125; _dragElement.ReleasePointer(evt.pointerId); _dragElement = null; isCapture = false; &#125; &#125;);&#125; 项目 更新日志2024-05-31 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"框架","slug":"框架","permalink":"https://busyogg.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"VisualElement","slug":"VisualElement","permalink":"https://busyogg.github.io/tags/VisualElement/"}]},{"title":"碰撞检测之线段检测","slug":"碰撞检测之线段检测","date":"2024-05-18T12:29:43.000Z","updated":"2024-05-30T12:26:28.659Z","comments":true,"path":"article/ae332e92ff44/","link":"","permalink":"https://busyogg.github.io/article/ae332e92ff44/","excerpt":"","text":"简介本文主要阐述线段之间的碰撞检测原理和实现方式以及线段之间最小距离（本文方法返回的结果是距离的平方）的计算方式。 原理在求线段最小距离之前，我们先补充一个求一点在线段上的最近点的方法。 我们计算该点在线段上的投影大小，根据投影大小我们可以知道该点在线段上的比例，然后通过这个比例求出线段上的最合适的检测点，即该点在线段上的最近点。如果检测点超出线段范围，那我们就要使其移动到线段极限位置。 求点在线段上最近点的代码如下： 12345678private Vector3 GetClosestPointOnLineSegment(Vector3 start, Vector3 end, Vector3 point)&#123; Vector3 line = end - start; //dot line line 求长度平方 float ratio = Vector3.Dot(point - start, line) / Vector3.Dot(line, line); ratio = Mathf.Min(Mathf.Max(ratio, 0), 1); return start + ratio * line;&#125; 该方法在求线段最小距离的时候会用到。 求线段之间的最小距离分为两种情况： 线段平行。 线段不平行。 那么我们如何判断线段是否平行？ 我们可以比较两条线段的方向向量，如果两条线段的方向向量相等的话，这两条线段就平行。 12//判断完全平行bool isParallel = line1.normalized == line2.normalized; 线段平行在线段平行的情况下，我们只需要计算一条线段的两个端点相对于另一条线段的距离，取其中最小的距离即可。 因为两线段平行，所以只需要进行一次这样的计算就行，反过来计算的两个端点距离和当前计算的两个端点距离是一样的。 计算两个端点的原因是在某些情况下，一条线段的两个端点与另一条线段的距离是不一样的。 一致的情况不一致的情况 12345//完全平行float disStart1 = (GetClosestPointOnLineSegment(start1, end1, start2) - start2).sqrMagnitude;float disEnd1 = (GetClosestPointOnLineSegment(start1, end1, end2) - end2).sqrMagnitude;dis = Mathf.Min(disStart1, disEnd1); 线段不平行在线段不平行的情况下，又分为两种情况： 线段同面。 线段不同面。 判断线段是否同面，我们就需要知道两条线段之间的距离是否为 0，如果为 0 的话，两条线段就同面。 那么我们如何判断两条线段之间的距离是否为 0 呢？ 根据定理，两条直线之间的最短距离等于两条直线的中垂线的长度。因此我们只需要得到中垂线就能计算出两条直线之间的距离。 中垂线的方向向量我们可以通过向量叉乘来得到。 又根据 $中垂线长度&#x3D;\\dfrac{叉乘向量和两直线任意两点连线的点积}{叉乘向量的模长}$ 即 $B的投影长度&#x3D;\\dfrac{AB 的点积}{A 的模长}$ 我们就能得到两直线之间的距离，同时也是两线段平面之间的距离，也就是两线段之间的距离。 123Vector3 normal = Vector3.Cross(line1, line2);float len = normal.sqrMagnitude;float dis2Line = Mathf.Pow(Mathf.Abs(Vector3.Dot(start2 - start1, normal)), 2) / len; 线段同面在线段同面的时候，我们需要判断两条线段是否相交，如果相交的话，距离就为 0；不相交的话，我们分别计算每条线段的两个顶点相对于另一条线段的距离，最后选择最小的距离。 123456789101112131415//同面// 检测线段相交bool isLineCross = CheckLineCross(start1, end1, start2, end2);if (isLineCross)&#123; dis = 0;&#125;else&#123; float disStart1 = (GetClosestPointOnLineSegment(start1, end1, start2) - start2).sqrMagnitude; float disEnd1 = (GetClosestPointOnLineSegment(start1, end1, end2) - end2).sqrMagnitude; float disStart2 = (GetClosestPointOnLineSegment(start2, end2, start1) - start1).sqrMagnitude; float disEnd2 = (GetClosestPointOnLineSegment(start2, end2, end1) - end1).sqrMagnitude; dis = Mathf.Min(disStart1, disEnd1, disStart2, disEnd2);&#125; 线段不同面在线段不同面的时候，我们把其中一条线段平移到另一条线段的平面上，然后按照线段同面的方法来得到最小的距离。不过在这种情况下，线段交叉时候的距离为两个线段的中垂线的长度。 为什么不是直接用中垂线长度呢？ 因为中垂线长度是直线之间的最短距离，而线段是有范围的，这个范围不一定经过中垂线的端点，在线段共面交叉的时候，中垂线的长度才是有效的。 如何平移到同一个平面？ 只需要让 line2 根据中垂线方向移动中垂线长度即可。不过我们要注意移动的是正方向还是负方向，可以根据两线段任意两点的方向向量来决定。 1234567891011121314151617181920float offset = Mathf.Sqrt(dis2Line);//计算line2相对line1的方位Vector3 directionStart = start2 - start1;float direction = Vector3.Dot(directionStart, normal) &gt; 0 ? 1 : -1;// 检测线段相交bool isLineCross = CheckLineCross(start1, end1, start2 - normal.normalized * (offset * direction), end2 - normal.normalized * (offset * direction));if (isLineCross)&#123; dis = dis2Line;&#125;else&#123; float disStart1 = (GetClosestPointOnLineSegment(start1, end1, start2) - start2).sqrMagnitude; float disEnd1 = (GetClosestPointOnLineSegment(start1, end1, end2) - end2).sqrMagnitude; float disStart2 = (GetClosestPointOnLineSegment(start2, end2, start1) - start1).sqrMagnitude; float disEnd2 = (GetClosestPointOnLineSegment(start2, end2, end1) - end1).sqrMagnitude; dis = Mathf.Min(disStart1, disEnd1, disStart2, disEnd2);&#125; 线段交叉检测上文我们提到需要检测线段是否交叉，交叉检测需要进行两个步骤： 快速排斥。 跨立检测。 快速排斥是为了能够以简单的判定快速去除不相交的情况。原理和 SAT 有点类似，在 XYZ 三轴方向上如果有一个轴存在投影不相交的情况，则两线段一定不相交。 跨立检测的方法和叉乘有关，如果两条线段互相跨立，则其中一条线段的端点在另一条线段的两侧。 对于 A1A2 线段来说，判断 B1A2 和 B2A2 相对于 A1A2 的左右方向来说是否相反，是的话就证明 B1、B2 在 A1A2 两边；同理对于 B1B2 线段来说，判断 A1B1 和 A2B1 相对于 A1A2 的左右方向来说是否相反，是的话就证明 A1、A2 在 B1B2 两边。 12345678910111213141516171819202122232425private bool CheckLineCross(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)&#123; //快速排斥 if (Mathf.Min(start1.x, end1.x) - Mathf.Max(start2.x, end2.x) &gt; 0.01 || Mathf.Min(start1.y, end1.y) - Mathf.Max(start2.y, end2.y) &gt; 0.01 || Mathf.Min(start1.z, end1.z) - Mathf.Max(start2.z, end2.z) &gt; 0.01 || Mathf.Min(start2.x, end2.x) - Mathf.Max(start1.x, end1.x) &gt; 0.01 || Mathf.Min(start2.y, end2.y) - Mathf.Max(start1.y, end1.y) &gt; 0.01 || Mathf.Min(start2.z, end2.z) - Mathf.Max(start1.z, end1.z) &gt; 0.01) &#123; return false; &#125; Vector3 line1 = end1 - start1; Vector3 line2 = end2 - start2; //跨立 if (Vector3.Cross(line1, start2 - start1).normalized == Vector3.Cross(line1, end2 - start1).normalized || Vector3.Cross(line2, start1 - start2).normalized == Vector3.Cross(line2, end1 - start2).normalized) &#123; return false; &#125; return true;&#125; 这部分也可以直接用于线段的碰撞检测。 代码线段相交检测12345678910111213141516171819202122232425private bool CheckLineCross(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)&#123; //快速排斥 if (Mathf.Min(start1.x, end1.x) - Mathf.Max(start2.x, end2.x) &gt; 0.01 || Mathf.Min(start1.y, end1.y) - Mathf.Max(start2.y, end2.y) &gt; 0.01 || Mathf.Min(start1.z, end1.z) - Mathf.Max(start2.z, end2.z) &gt; 0.01 || Mathf.Min(start2.x, end2.x) - Mathf.Max(start1.x, end1.x) &gt; 0.01 || Mathf.Min(start2.y, end2.y) - Mathf.Max(start1.y, end1.y) &gt; 0.01 || Mathf.Min(start2.z, end2.z) - Mathf.Max(start1.z, end1.z) &gt; 0.01) &#123; return false; &#125; Vector3 line1 = end1 - start1; Vector3 line2 = end2 - start2; //跨立 if (Vector3.Cross(line1, start2 - start1).normalized == Vector3.Cross(line1, end2 - start1).normalized || Vector3.Cross(line2, start1 - start2).normalized == Vector3.Cross(line2, end1 - start2).normalized) &#123; return false; &#125; return true;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/// &lt;summary&gt;/// 求两条线段的最短距离/// &lt;/summary&gt;/// &lt;param name=&quot;start1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;end1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;start2&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;end2&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private float GetClosestDistanceBetweenLinesSqr(Vector3 start1, Vector3 end1, Vector3 start2, Vector3 end2)&#123; Vector3 line1 = end1 - start1; Vector3 line2 = end2 - start2; float dis = 0; //判断完全平行 bool isParallel = line1.normalized == line2.normalized; if (isParallel) &#123; //完全平行 float disStart1 = (GetClosestPointOnLineSegment(start1, end1, start2) - start2).sqrMagnitude; float disEnd1 = (GetClosestPointOnLineSegment(start1, end1, end2) - end2).sqrMagnitude; dis = Mathf.Min(disStart1, disEnd1); &#125; else &#123; Vector3 normal = Vector3.Cross(line1, line2); float len = normal.sqrMagnitude; float dis2Line = Mathf.Pow(Mathf.Abs(Vector3.Dot(start2 - start1, normal)), 2) / len; //判断同面 if (dis2Line == 0) &#123; //同面 // 检测线段相交 bool isLineCross = CheckLineCross(start1, end1, start2, end2); if (isLineCross) &#123; dis = 0; &#125; else &#123; float disStart1 = (GetClosestPointOnLineSegment(start1, end1, start2) - start2).sqrMagnitude; float disEnd1 = (GetClosestPointOnLineSegment(start1, end1, end2) - end2).sqrMagnitude; float disStart2 = (GetClosestPointOnLineSegment(start2, end2, start1) - start1).sqrMagnitude; float disEnd2 = (GetClosestPointOnLineSegment(start2, end2, end1) - end1).sqrMagnitude; dis = Mathf.Min(disStart1, disEnd1, disStart2, disEnd2); &#125; &#125; else &#123; float offset = Mathf.Sqrt(dis2Line); //计算line2相对line1的方位 Vector3 directionStart = start2 - start1; float direction = Vector3.Dot(directionStart, normal) &gt; 0 ? 1 : -1; // 检测线段相交 bool isLineCross = CheckLineCross(start1, end1, start2 - normal.normalized * (offset * direction), end2 - normal.normalized * (offset * direction)); if (isLineCross) &#123; dis = dis2Line; &#125; else &#123; float disStart1 = (GetClosestPointOnLineSegment(start1, end1, start2) - start2).sqrMagnitude; float disEnd1 = (GetClosestPointOnLineSegment(start1, end1, end2) - end2).sqrMagnitude; float disStart2 = (GetClosestPointOnLineSegment(start2, end2, start1) - start1).sqrMagnitude; float disEnd2 = (GetClosestPointOnLineSegment(start2, end2, end1) - end1).sqrMagnitude; dis = Mathf.Min(disStart1, disEnd1, disStart2, disEnd2); &#125; &#125; &#125; return dis;&#125; 项目地址 更新日志2024-05-19 更新基础内容。","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"线段","slug":"线段","permalink":"https://busyogg.github.io/tags/%E7%BA%BF%E6%AE%B5/"}]},{"title":"Untiy-节点编辑器开发优化框架 GraphViewExtension","slug":"Untiy-节点编辑器开发优化框架GraphViewExtension","date":"2024-05-12T13:57:08.000Z","updated":"2024-05-31T09:21:23.289Z","comments":true,"path":"article/1166dedab522/","link":"","permalink":"https://busyogg.github.io/article/1166dedab522/","excerpt":"","text":"简介通过 Attribute 标签简化节点编辑器开发。 支持选中描边，自定义节点大小，未手动修改大小的时候自适应节点大小。 支持打开、保存、关闭节点图。支持 Ctrl+S 保存当前节点图。 本文只阐述原理，具体的使用方法请见说明文档 GraphViewExtension 文档 演示视频节点操作 文件操作 原理节点UI节点的 UI 初始化是通过给字段打 Attribute 标签，然后在创建节点的时候进行反射初始化。 因为 GraphView 用的是 UI ToolKit 的体系，所以所有的 UI 都是 VisualElement 节点。该体系和 Editor 的 UI 不同，因此此处不套用 EditorUIExtension 的初始化方式。 为了保持 UI 初始化的一致性，本项目采用 VisualElement 作为一个 UI 的父容器，里面再添加具体的 UI。这样在 UI 构造为 标签 + 输入框 的类型的时候，就可以在这个父容器里面进行横向排布而不影响到最上层的容器。 注意：父容器方向默认是竖向排列，需要自己设置样式为横向 graph LR; table_1[\"父容器标签输入框\"] 具体实现如下： 12345678910111213141516171819case NodeTypeEnum.Input: ele.style.flexDirection = FlexDirection.Row; //foreLabel 为在 switch 之外定义的辅助标签，在此处代码省略定义过程 foreLabel = new Label(); foreLabel.style.fontSize = _fontSize; foreLabel.text = subName; ele.Add(foreLabel); TextField text = new TextField(); text.style.flexGrow = 1; text.style.height = _fontSize * 1.2f; var fontChild = text.Children().FirstOrDefault().Children().FirstOrDefault(); fontChild.style.fontSize = _fontSize; text.RegisterValueChangedCallback(evt =&gt; &#123; setValue(this, evt.newValue); &#125;); ele.Add(text); break; 同时为了能够把自定义数量的 UI 框在同一个矩形里，额外定义一种 Box 类型的 UI，在该 UI 初始化的时候，会创建一个新的顶层容器来容纳 UI。容纳一定数量的 UI 之后（Box 设置的数量），下一次创建 UI 会再新建一个顶层容器，后面的 UI 都在这个新的容器里容纳。 graph TD; table_1[\"默认顶层容器UI1UI2UI3\"] table_2[\"Box 创建的顶层容器UI4UI5\"] table_3[\"Box 之后的新顶层容器UI6UI7UI8\"] table_1 --> table_2 table_2 --> table_3 具体的实现如下： 1234567891011121314151617181920212223242526272829303132//ui box 分割。没有 box 标签的情况下都在默认的第一个 box 中添加 uiint boxCount = -1;var box = new VisualElement();//extensionContainer 为所有顶层容器的父容器extensionContainer.Add(box);foreach (var field in fields)&#123; GraphNode attr = field.GetCustomAttribute&lt;GraphNode&gt;(); if (attr != null) &#123; // 判断是否需要增加 ui box if (boxCount == 0) &#123; box = new VisualElement(); extensionContainer.Add(box); &#125; if (boxCount &gt; -1) &#123; boxCount--; &#125; switch (attr.Type())&#123; case NodeTypeEnum.Box: box = new VisualElement(); extensionContainer.Add(box); boxCount = int.Parse(extra[0]); // 此处省略 box 样式设置 break; &#125; &#125;&#125; 通过 boxCount 来计数，有新的 Box 的时候才会赋值并且执行判断和自减，自减到 0 代表完全填入足量的 UI，这时候就需要新建一个 VisualElement 来装 Box 外的 UI。 如果以上方法无法满足你的 UI 构建需要的话，通过重写 CustomUI 来实现客制化 UI。 数据节点内设有一个 ExpandoObject 类型字段 _data 来存储数据。 ExpandoObject 是个 dynamic 类型，可以通过点来设置和读取属性。 例如： 123dynamic obj = new ExpandoObject();obj.a = 1;obj.b = &quot;str&quot;; 因此我们可以利用这个动态类型来保存任意类型的数据。 保存数据除了当前节点的数据，我们还需要保存节点的关系。因此我们用树来存储。 我们定义一个简单的数据节点类 GDataNode ，该类保存数据和子节点列表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System.Collections.Generic;namespace GraphViewExtension&#123; public class GDataNode &#123; private List&lt;GDataNode&gt; _children = new List&lt;GDataNode&gt;(); private dynamic _data; private string _type; public void SetData(dynamic data) &#123; _data = data; &#125; public void SetNodeType(string type) &#123; _type = type; &#125; public void AddChild(GDataNode node) &#123; if (!_children.Contains(node)) &#123; _children.Add(node); &#125; &#125; public List&lt;GDataNode&gt; GetChildren() &#123; return _children; &#125; public dynamic GetData() &#123; return _data; &#125; public string GetNodeType() &#123; return _type; &#125; &#125;&#125; 然后我们在保存数据的时候，通过遍历 _outputPort 的 connections ，也就是输出节点的连接，递归地保存到本节点的 GDataNode 中。 具体的流程如下： 123456789101112131415161718192021222324/// &lt;summary&gt;/// 保存数据/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public GDataNode SaveData()&#123; // 保存基本数据 _data.guid = guid; _data.pos = _defPos.ToString(); _data.size = (_curSize.Equals(Vector2.zero) ? _defSize : _curSize).ToString(); _dataNode.SetNodeType(_type.FullName); // 保存额外数据，用户自定义 SetData(); _dataNode.SetData(_data); // 遍历子节点 var connections = _outputPort.connections; foreach (var edge in connections) &#123; RootNode node = edge.input.node as RootNode; _dataNode.AddChild(node?.SaveData()); &#125; return _dataNode;&#125; 其中 SetData 是用户自定义保存数据的方法。 读取数据和用户自定义保存数据一样，我们读取数据的时候也需要自己实现数据的初始化。具体的函数为 ResetData 。 节点尺寸本项目允许用户通过拖拽节点右下角进行节点尺寸的修改。 尺寸分为两个部分： _defSize ，用于存储最小的大小。 _curSize ，用于存储当前大小。 当手动修改过大小后，部分功能就读取 _curSize ，否则读取 _defSize 的数据。 主要的原理就是监听鼠标的按下、移动和抬起事件，然后进行相应的操作。 鼠标按下鼠标按下事件是在节点内监听的。 鼠标按下的时候我们判断鼠标在节点的坐标是否在节点右下角的范围内，本项目给了 10 个像素的空余。 1234567891011121314151617/// &lt;summary&gt;/// 节点尺寸调节鼠标按下回调/// &lt;/summary&gt;/// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;private void ResizeStart(MouseDownEvent evt)&#123; if (evt.button == 0) &#123; // 判断改大小 if (IsResizeArea(evt.localMousePosition)) &#123; _mouseOffset = evt.mousePosition - layout.size; _isResizing = true; evt.StopPropagation(); &#125; &#125;&#125; evt 的 localMousePosition 是鼠标在当前节点的坐标，以节点左上角为 (0,0)。 mousePosition 是鼠标的世界坐标，layout.size 是当前节点的尺寸。通过相减得到当前节点左上角的世界坐标。 鼠标移动鼠标移动事件是在 GraphView 监听的。如果在节点监听，则在鼠标移出节点的时候会接收不到事件。 鼠标移动的时候，如果是尺寸修改状态，则计算新的大小并更新。计算大小的时候会和最小大小进行比较选择其中较大的一方。 12345678910111213141516/// &lt;summary&gt;/// 节点尺寸调节鼠标移动回调/// &lt;/summary&gt;/// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;private void ResizeMove(MouseMoveEvent evt)&#123; if (_isResizing) &#123; Vector2 newSize = evt.mousePosition - _mouseOffset; newSize = Vector2.Max(_defSize, newSize); // 更新节点的大小 UpdateSize(newSize); evt.StopPropagation(); &#125;&#125; 鼠标抬起鼠标抬起事件是在 GraphView 监听的。如果在节点监听，则在鼠标移出节点的时候会接收不到事件。 鼠标抬起的时候置尺寸调节状态为 false 。 1234567891011121314151617/// &lt;summary&gt;/// 节点尺寸调节鼠标抬起回调/// &lt;/summary&gt;/// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt;private void ResizeEnd(MouseUpEvent evt)&#123; // 尺寸调节部分的代码 if (_isResizing) &#123; Debug.Log(layout.size); _isResizing = false; evt.StopPropagation(); &#125; // 描边用的值 _defPos = layout.position + new Vector2(_borderOffset * 0.5f, _borderOffset * 0.5f);&#125; 描边本项目支持在点击节点的时候对节点进行描边，如果节点有前置节点，则前置节点也会描边，这样可以清楚地看到该节点的路线。 点击描边是在 GraphView 监听的，具体的逻辑请看 [图](# 图) 部分。 描边的实现描边的实现很简单，只需要修改节点的 style 的 border 相关的样式就可以。 由于描边的时候 VisualElement 是内描边，因此我们需要扩大节点的大小。 扩大大小的时候需要用 _curSize 或 _defSize 加上描边的 ** 宽度 *2**，该值本项目存储为 _borderOffset 。还原的时候就把节点尺寸设为 _curSize 或 _defSize 即可。 位置偏移因为我们修改了节点大小，因此节点会产生视觉上的偏移（节点内大小不变，扩大的部分为描边，整个节点左上角坐标不变，因此视觉上会往右下偏移一点距离，距离为描边宽度）。 所以我们要对这个偏移进行修正。 修正的原理也很简单，只需要在描边的时候往左上移动描边宽度的距离，取消描边的时候把节点位置还原即可。 因此我们需要记录节点的原始坐标 _defPos 。 这里还有一个额外情况，由于本项目的 备注 UI 会在没手动调整节点尺寸的情况下自动更新节点尺寸，因此会在描边的时候造成重复修正偏移的情况，因此增加一个标识 _lastBordered 判断是否修正过坐标。 具体的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// &lt;summary&gt;/// 描边/// &lt;/summary&gt;private void DrawBorder()&#123; if (_isBordered) &#123; if (_curSize.Equals(Vector2.zero)) &#123; style.width = _defSize.x + _borderOffset; style.height = _defSize.y + _borderOffset; &#125; else &#123; style.width = _curSize.x + _borderOffset; style.height = _curSize.y + _borderOffset; &#125; _defPos = new Vector2(style.left.value.value, style.top.value.value); // 如果没描过边，则调整节点坐标位置以防止错位 if (_lastBordered != _isBordered) &#123; style.left = _defPos.x - _borderOffset * 0.5f; style.top = _defPos.y - _borderOffset * 0.5f; &#125; &#125; else &#123; if (_curSize.Equals(Vector2.zero)) &#123; style.width = _defSize.x; style.height = _defSize.y; &#125; else &#123; style.width = _curSize.x; style.height = _curSize.y; &#125; // 还原节点默认位置 style.left = _defPos.x; style.top = _defPos.y; &#125; _lastBordered = _isBordered;&#125; 图（GraphView）菜单本项目在创建图的时候引入自定义的多级搜索菜单，并在菜单中注册选择监听事件。具体逻辑见 [多级搜索菜单](# 多级搜索菜单) 项。 然后我们注册图的 nodeCreationRequest 委托，使其在创建节点的时候打开该菜单。 123456789101112public GGraph(EditorWindow editorWindow, GSearchWindow provider)&#123; // 监听创建节点 nodeCreationRequest += (context) =&gt; &#123; // 打开搜索框 SearchWindow.Open( new SearchWindowContext(context.screenMousePosition), provider ); &#125;;&#125; 监听事件本项目除了 Unity 提供的基础的滚轮缩放、窗口拖动、选中节点移动、多节点框选功能外，额外监听了鼠标按下、鼠标移动、点击和按键抬起。 基础功能1234567891011public GGraph(EditorWindow editorWindow, GSearchWindow provider)&#123; // 滚轮缩放 SetupZoom(ContentZoomer.DefaultMinScale, ContentZoomer.DefaultMaxScale); // 窗口内容拖动 this.AddManipulator(new ContentDragger()); // 选中 Node 移动功能 this.AddManipulator(new SelectionDragger()); // 多个 node 框选功能 this.AddManipulator(new RectangleSelector());&#125; 点击描边其中监听鼠标按下、鼠标移动和点击是为了实现节点点击描边的功能。 其中鼠标移动是为了判断节点是否产生了拖拽，在拖拽的时候不产生描边。鼠标按下是为了判断是否对节点进行了操作，否则只监听移动的话不管鼠标是否按下都会判定。 描边判断的主要逻辑在点击监听内，具体逻辑如下。 flowchart TB; A[\"获取点击的 UI\"] --> B[\"判断是否为空\"] B --> C[\"为空，取消原节点描边\"] B --> D[\"不为空，循环判断节点或节点的父节点是否为 RootNode\"] D --> E[\"不是，取消原节点描边\"] D --> F[\"是，判断节点或节点的父节点是否可交互\"] F --> G[\"是，不做任何操作\"] F --> H[\"不是，判断原节点是否存在并且当前节点不等于原节点并且不是 RootNode\"] H --> I[\"是，取消原节点描边\"] H --> J[\"不是，描边当前节点，并保存\"] 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public GGraph(EditorWindow editorWindow, GSearchWindow provider)&#123; RegisterCallback&lt;PointerDownEvent&gt;(evt =&gt; &#123; if (evt.button == 0) &#123; _isDown = true; &#125; &#125;); RegisterCallback&lt;PointerMoveEvent&gt;(evt =&gt; &#123; if (_isDown) &#123; _isMoved = true; &#125; &#125;); // 监听点击的节点 RegisterCallback&lt;ClickEvent&gt;(evt =&gt; &#123; if (!_isMoved) &#123; Vector2 localMousePosition = evt.position - new Vector3(layout.xMin, layout.yMin); // 获取当前被选中的对象 var currentSelection = panel.Pick(localMousePosition); if (currentSelection == null) &#123; if (_clickNode != null) &#123; _clickNode.UnSelected(); _clickNode = null; &#125; &#125; else &#123; bool isInput = false; while (currentSelection != null &amp;&amp; currentSelection is not RootNode) &#123; if (IsInputField(currentSelection)) &#123; isInput = true; break; &#125; currentSelection = currentSelection.parent; &#125; if (currentSelection == null) &#123; if (_clickNode != null) &#123; _clickNode.UnSelected(); _clickNode = null; &#125; &#125; else &#123; if (isInput) return; if (_clickNode != null &amp;&amp; currentSelection != _clickNode &amp;&amp; currentSelection is not RootNode) &#123; _clickNode.UnSelected(); _clickNode = null; &#125; else &#123; _clickNode?.UnSelected(); _clickNode = currentSelection as RootNode; _clickNode?.Selected(); &#125; &#125; &#125; &#125; _isMoved = false; _isDown = false; &#125;);&#125; 组合键监听监听组合键主要是为了监听 Ctrl+S 来保存文件（焦点需要在 GraphView 内）。 保存文件的逻辑和下一小节的逻辑相同，不过这里不会选择保存的路径，而是直接使用打开的路径。 如果是新的文件的话，会走初次保存文件的逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243public GGraph(EditorWindow editorWindow, GSearchWindow provider)&#123; // 监听保存组合键 RegisterCallback&lt;KeyUpEvent&gt;(OnKeyUp);&#125;private void OnKeyUp(KeyUpEvent evt)&#123; // 检查是否按下了 Ctrl 键和 S 键 if (evt.keyCode == KeyCode.S &amp;&amp; evt.ctrlKey) &#123; if (_filePath == &quot;&quot;) &#123; Save(); return; &#125; Debug.Log(&quot;Ctrl + S pressed. Saving...&quot;); // 执行保存操作 List&lt;GDataNode&gt; list = SaveData(); List&lt;SaveJson&gt; listJson = new List&lt;SaveJson&gt;(); foreach (var data in list) &#123; listJson.Add(ToJson(data)); &#125; string jsonData = JsonConvert.SerializeObject(listJson); FileInfo myFile = new FileInfo(_filePath); StreamWriter sw = myFile.CreateText(); foreach (var s in jsonData) &#123; sw.Write(s); &#125; sw.Close(); // 这里可以添加你的保存逻辑 evt.StopPropagation (); // 阻止事件传递，避免触发其他事件 &#125;&#125; 数据存储与读取数据存储与读取，重点在于数据的序列化与反序列化。 序列化数据首先我们考虑节点可能并不一定从同一个根节点展开，因此需要保存成一个根节点列表。 由于我们定义的 GDataNode 具有额外的方法，所以我们提取其字段构成新的数据类 SaveJson 。 12345678910111213using System.Collections.Generic;namespace GraphViewExtension&#123; public class SaveJson &#123; public List&lt;SaveJson&gt; children = new List&lt;SaveJson&gt;(); public dynamic data; public string type; &#125;&#125; 本项目把数据保存为 Json 格式，利用 Unity 自带的 Newtonsoft.Json 来实现序列化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void Save()&#123; string filePath = EditorUtility.SaveFilePanel (&quot;保存到本地&quot;, Application.dataPath + &quot;/Json&quot;, &quot;NewFile&quot;, &quot;json&quot;); if (filePath != &quot;&quot;) &#123; SetFilePath(filePath); List&lt;GDataNode&gt; list = SaveData(); List&lt;SaveJson&gt; listJson = new List&lt;SaveJson&gt;(); foreach (var data in list) &#123; listJson.Add(ToJson(data)); &#125; string jsonData = JsonConvert.SerializeObject(listJson); FileInfo myFile = new FileInfo(filePath); StreamWriter sw = myFile.CreateText(); foreach (var s in jsonData) &#123; sw.Write(s); &#125; sw.Close(); _editorWindow.ShowNotification (new GUIContent (&quot;保存成功，路径为:&quot; + filePath)); &#125;&#125;/// &lt;summary&gt;/// 转换为 JSON/// &lt;/summary&gt;/// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public SaveJson ToJson(GDataNode data)&#123; SaveJson save = new SaveJson(); save.type = data.GetNodeType(); save.data = data.GetData(); foreach (var child in data.GetChildren()) &#123; save.children.Add(ToJson(child)); &#125; return save;&#125; 反序列化数据反序列化同理，我们需要把 SaveJson 转为 GDataNode 。 由于数据在读取的时候都是 JObject 格式，并且在遍历赋值的时候都是 JProperty 格式，存入 ExpandoObject 的话会失去数据类型，因此我们根据数据的 JTokenType 手动转换为对应的类型。 读取数据还存在一种情况：已经读取过一次数据。 这时候我们就要弹窗提示用户是否重新打开，确定就清空当前内容并打开新的内容，取消就无事发生。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void Open()&#123; bool isOpen = GetOpen(); if (isOpen) &#123; bool res = EditorUtility.DisplayDialog (&quot;打开新文件&quot;, &quot;是否打开一个新的文件，当前内容未保存的部分会消失。&quot;, &quot;确定&quot;, &quot;取消&quot;); if (res) &#123; ClearGraph(); &#125; else &#123; return; &#125; &#125; string filePath = EditorUtility.OpenFilePanel (&quot;打开 ScriptableObject&quot;, &quot;Assets/Json&quot;, &quot;json&quot;); if (filePath != &quot;&quot;) &#123; string jsonData = &quot;&quot;; StreamReader sr = File.OpenText(filePath); while (sr.ReadLine() is &#123; &#125; nextLine) &#123; jsonData += nextLine; &#125; sr.Close(); List&lt;SaveJson&gt; json = JsonConvert.DeserializeObject&lt;List&lt;SaveJson&gt;&gt;(jsonData); List&lt;GDataNode&gt; list = new List&lt;GDataNode&gt;(); foreach (var data in json) &#123; list.Add(ToGDataNode(data)); &#125; SetFilePath(filePath); OpenData(list); &#125;&#125;/// &lt;summary&gt;/// 转换为节点数据/// &lt;/summary&gt;/// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public GDataNode ToGDataNode(SaveJson json)&#123; GDataNode data = new GDataNode(); data.SetNodeType(json.type); dynamic obj = new ExpandoObject(); foreach (var res in (json.data as JObject).Properties()) &#123; JTokenType jType = res.Value.Type; switch (jType) &#123; case JTokenType.String: ((IDictionary&lt;string, object&gt;)obj)[res.Name] = res.Value.Value&lt;string&gt;(); break; case JTokenType.Float: ((IDictionary&lt;string, object&gt;)obj)[res.Name] = res.Value.Value&lt;float&gt;(); break; case JTokenType.Boolean: ((IDictionary&lt;string, object&gt;)obj)[res.Name] = res.Value.Value&lt;bool&gt;(); break; &#125; &#125; data.SetData(obj); foreach (var child in json.children) &#123; data.AddChild(ToGDataNode(child)); &#125; return data;&#125; 工具栏工具栏我们可以使用 Unity 提供的 Toolbar 和 ToolbarButton 来创建。 1234567891011121314protected virtual void SetupToolbar()&#123; var toolbar = new Toolbar(); var openBtn = new ToolbarButton &#123;text = &quot;打开&quot;&#125;; openBtn.clicked += Open; var saveBtn = new ToolbarButton &#123;text = &quot;保存&quot;&#125;; saveBtn.clicked += Save; var closeBtn = new ToolbarButton &#123;text = &quot;关闭&quot;&#125;; closeBtn.clicked += Close; toolbar.Add(openBtn); toolbar.Add(saveBtn); toolbar.Add(closeBtn); Add(toolbar);&#125; 多级搜索菜单多级搜索菜单类继承自 ScriptableObject 和 ISearchWindowProvider。 本类定义一个菜单数组 entries ，并且默认传入一个菜单组，也就是一打开显示的界面。 1234public List&lt;SearchTreeEntry&gt; entries = new List&lt;SearchTreeEntry&gt;()&#123; new SearchTreeGroupEntry (new GUIContent (&quot;创建节点&quot;))&#125;; 然后我们在构造函数中初始化菜单的配置文件，同样也是通过 Newtonsoft.Json 实现。 12345private void InitJson()&#123; string json = EditorGUIUtility.Load(&quot;Assets/Editor/GraphViewExtension/Graph/Menu.json&quot;).ToString(); _menu = JArray.Parse(json);&#125; 最后我们根据结构创建菜单，其中 level 代表层级，高层级的 level 被低层级的 level 嵌套。 123456789101112131415161718192021private void CreateMenu(JToken obj, int level = 1)&#123; string menuName = obj[&quot;name&quot;].ToString(); string menuType = &quot;GraphViewExtension.&quot; + obj[&quot;type&quot;]; JToken children = obj[&quot;child&quot;]; bool isChild = children?.Count() &gt; 0; if (isChild) &#123; entries.Add(new SearchTreeGroupEntry(new GUIContent(menuName)) &#123; level = level &#125;); foreach (var child in children) &#123; CreateMenu(child, level + 1); &#125; &#125; else &#123; entries.Add(new SearchTreeEntry(new GUIContent(menuName)) &#123; level = level, userData = Type.GetType(menuType) &#125;); &#125;&#125; 整体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384using System;using System.Collections.Generic;using System.Linq;using Unity.Plastic.Newtonsoft.Json;using Unity.Plastic.Newtonsoft.Json.Linq;using UnityEditor;using UnityEditor.Experimental.GraphView;using UnityEngine;namespace GraphViewExtension&#123; public class GSearchWindow: ScriptableObject,ISearchWindowProvider &#123; public delegate bool SelectHandle(SearchTreeEntry searchTreeEntry, SearchWindowContext context); public SelectHandle onSelectEntryHandler; private bool _inited; private JArray _menu; public List&lt;SearchTreeEntry&gt; entries = new List&lt;SearchTreeEntry&gt;() &#123; new SearchTreeGroupEntry (new GUIContent (&quot;创建节点&quot;)) &#125;; private void BuildTree() &#123; InitJson(); foreach (var token in _menu) &#123; CreateMenu(token); &#125; _inited = true; &#125; private void InitJson() &#123; string json = EditorGUIUtility.Load(&quot;Assets/Editor/GraphViewExtension/Graph/Menu.json&quot;).ToString(); _menu = JArray.Parse(json); &#125; private void CreateMenu(JToken obj,int level = 1) &#123; string menuName = obj[&quot;name&quot;].ToString(); string menuType = &quot;GraphViewExtension.&quot; + obj[&quot;type&quot;]; JToken children = obj[&quot;child&quot;]; bool isChild = children?.Count() &gt; 0; if (isChild) &#123; entries.Add(new SearchTreeGroupEntry(new GUIContent(menuName))&#123;level = level&#125;); foreach (var child in children) &#123; CreateMenu(child, level + 1); &#125; &#125; else &#123; entries.Add(new SearchTreeEntry(new GUIContent(menuName))&#123;level = level,userData = Type.GetType(menuType)&#125;); &#125; &#125; public List&lt;SearchTreeEntry&gt; CreateSearchTree(SearchWindowContext context) &#123; if (!_inited) &#123; BuildTree(); &#125; return entries; &#125; public bool OnSelectEntry(SearchTreeEntry searchTreeEntry, SearchWindowContext context) &#123; if (onSelectEntryHandler == null) return false; return onSelectEntryHandler(searchTreeEntry, context); &#125; &#125;&#125; 遇到的问题描边问题style 的描边是边线宽度，因此在大小不变的情况下会影响原来内容的大小，所以描边后对原大小和位置都做了修正。 输入框文字样式修改输入框 TextField 本身是由两个元素组成，一个是 Label , 另一个是 TextInput 。 因此修改输入框样式就不能在 TextField 直接修改。 字体的颜色可以在 TextInput 修改，但是字体大小就要在下一层的 TextElement 修改。 如果允许多行显示的话，TextInput 下面会多一层 VisualElement ，因此为了正确获取修改的对象，前面要多获取一层 UI 元素。 即：单行输入框共三层嵌套，多行输入框共四层嵌套。多行比单行多的一层嵌套在 TextInput 和 TextElement 之间。 点击事件的元素ClickEvent 返回的 target 不是真正点击到的对象。 因此本项目使用 panel.Pick (Vector2) 来获取点击的目标对象。 GraphView 的鼠标按下事件GraphView 无法监听 MouseDownEvent 的鼠标左键事件，因此本项目使用 PointerDownEvent 来监听指针事件。 数据反序列化反序列化一开始没有单独做类型处理，结果返回的都是 JToken 数据，在使用数据的时候还需要手动做转换。后面在反序列化的时候直接处理了数据类型。 代码AttributeNodeGraph数据类 GraphNode GraphNode12345678910111213141516171819202122232425262728using System;namespace GraphViewExtension&#123; [AttributeUsage(AttributeTargets.Field)] public class GraphNode: Attribute &#123; private NodeTypeEnum _type; private string[] _extra; public GraphNode(NodeTypeEnum type,params string[] extra) &#123; _type = type; _extra = extra; &#125; public NodeTypeEnum Type() &#123; return _type; &#125; public string[] GetExtra() &#123; return _extra; &#125; &#125;&#125; GName 1234567891011121314151617181920using System;namespace GraphViewExtension&#123; [AttributeUsage(AttributeTargets.Field)] public class GName: Attribute &#123; private string _name; public GName(string name) &#123; _name = name; &#125; public string GetName() &#123; return _name; &#125; &#125;&#125; GColor GColor123456789101112131415161718192021using System;using UnityEngine;namespace GraphViewExtension&#123; [AttributeUsage(AttributeTargets.Field)] public class GColor: Attribute &#123; private Color color; public GColor(float r,float g,float b,float a = 1) &#123; color = new Color(r, g, b, a); &#125; public Color GetColor() &#123; return color; &#125; &#125;&#125; GWidth GWidth123456789101112131415161718192021using System;using UnityEngine.UIElements;namespace GraphViewExtension&#123; [AttributeUsage(AttributeTargets.Field)] public class GWidth: Attribute &#123; private Length _length; public GWidth(float width,LengthUnit type) &#123; _length = new Length(width,type); &#125; public Length GetLength() &#123; return _length; &#125; &#125;&#125; NodeTypeEnum NodeTypeEnum12345678910111213141516namespace GraphViewExtension&#123; public enum NodeTypeEnum &#123; Label, Input, Note, Enum, Slide, Toggle, Radio, Box, Color, Texture &#125;&#125; RootNode RootNode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920using System;using System.Dynamic;using System.Linq;using System.Reflection;using UnityEditor;using UnityEditor.Experimental.GraphView;using UnityEngine;using UnityEngine.UIElements;namespace GraphViewExtension&#123; public delegate void SetFieldDelegate(object target, object value); public class RootNode : Node &#123; /// &lt;summary&gt; /// 所属的 GraphView /// &lt;/summary&gt; private GGraph _graph; Port _inputPort; Port _outputPort; /// &lt;summary&gt; /// 反射范围标记 /// &lt;/summary&gt; private readonly BindingFlags _flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly; /// &lt;summary&gt; /// 唯一标识符 /// &lt;/summary&gt; public string guid; /// &lt;summary&gt; /// 是否完成渲染初始化 /// &lt;/summary&gt; private bool _inited = false; /// &lt;summary&gt; /// 当前类类型 /// &lt;/summary&gt; private Type _type; /// &lt;summary&gt; /// 默认尺寸 /// &lt;/summary&gt; private Vector2 _defSize; /// &lt;summary&gt; /// 当前尺寸 /// &lt;/summary&gt; private Vector2 _curSize; /// &lt;summary&gt; /// 默认位置 /// &lt;/summary&gt; private Vector2 _defPos; /// &lt;summary&gt; /// 默认高度 /// &lt;/summary&gt; private float _defHeight; /// &lt;summary&gt; /// 鼠标按下时坐标 /// &lt;/summary&gt; private Vector2 _mouseOffset; /// &lt;summary&gt; /// 是否正在调整大小 /// &lt;/summary&gt; private bool _isResizing = false; /// &lt;summary&gt; /// 是否已描边 /// &lt;/summary&gt; private bool _isBordered = false; /// &lt;summary&gt; /// 之前的状态是否描边 /// &lt;/summary&gt; private bool _lastBordered = false; /// &lt;summary&gt; /// 默认字体尺寸 /// &lt;/summary&gt; private int _fontSize = 16; /// &lt;summary&gt; /// 描边补正 /// &lt;/summary&gt; private float _borderOffset = 0; /// &lt;summary&gt; /// 是否执行到当前节点 /// &lt;/summary&gt; private bool _isRun = false; /// &lt;summary&gt; /// 是否选中当前节点 /// &lt;/summary&gt; private bool _isSelected = false; //----- 描边颜色 ------ start protected Color _selectColor = Color.red; protected Color _parentColor = Color.green; protected Color _runColor = Color.green; protected Color _passColor = Color.yellow; //----- 描边颜色 ------ end /// &lt;summary&gt; /// 节点数据 /// &lt;/summary&gt; protected dynamic _data = new ExpandoObject(); /// &lt;summary&gt; /// 是否设置了数据 /// &lt;/summary&gt; protected bool _isSet = false; /// &lt;summary&gt; /// 数据节点 /// &lt;/summary&gt; GDataNode _dataNode = new GDataNode(); public RootNode() &#123; title = &quot;默认节点&quot;; _type = GetType(); // 生成唯一标识 guid = GUID.Generate().ToString(); // 添加输入端口 _inputPort = InstantiatePort(Orientation.Horizontal, Direction.Input, Port.Capacity.Multi, typeof(Node)); _inputPort.portName = &quot;Parent&quot;; inputContainer.Add(_inputPort); // 添加输出端口 _outputPort = InstantiatePort(Orientation.Horizontal, Direction.Output, Port.Capacity.Multi, typeof(Node)); _outputPort.portName = &quot;Child&quot;; outputContainer.Add(_outputPort); // 注册鼠标按下监听 RegisterCallback&lt;MouseDownEvent&gt;(ResizeStart); // 注册界面改变监听 RegisterCallback&lt;GeometryChangedEvent&gt;(OnEnable); &#125; /// &lt;summary&gt; /// 界面改变回调 /// &lt;/summary&gt; /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt; private void OnEnable(GeometryChangedEvent evt) &#123; Debug.Log (&quot;创建完成，开始渲染&quot; + layout.size); // 保存默认高度 _defHeight = titleContainer.layout.height + _outputPort.layout.height; // 保存默认位置 _defPos = layout.position; // 如果设置了数据（即通过打开文件创建的节点），则把数据填充到 UI if (_isSet) &#123; ResetData(); &#125; // 初始化 UI Init(); CustomUI(); // 延迟更新节点大小 schedule.Execute(() =&gt; &#123; UpdateNodeSize(); _inited = true; &#125;).StartingIn(1); // 刷新 不然会有显示 BUG RefreshExpandedState(); RefreshPorts(); // 注销界面改变监听，使该方法只执行一次 UnregisterCallback&lt;GeometryChangedEvent&gt;(OnEnable); &#125; /// &lt;summary&gt; /// 设置数据 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; public void SetData(ExpandoObject data) &#123; _data = data; _isSet = true; &#125; /// &lt;summary&gt; /// 设置尺寸，该方法会保存默认尺寸 /// &lt;/summary&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; public void SetSize(Vector2 size) &#123; style.width = size.x; style.height = size.y; _defSize = size; &#125; /// &lt;summary&gt; /// 在 GraphView 注册鼠标移动和抬起事件 /// 用于节点界面尺寸的修改 /// 在 GraphView 是为了能够在节点外响应事件 /// &lt;/summary&gt; /// &lt;param name=&quot;graph&quot;&gt;&lt;/param&gt; public void RegistResize(GGraph graph) &#123; _graph = graph; _graph.RegisterCallback&lt;MouseMoveEvent&gt;(ResizeMove); _graph.RegisterCallback&lt;MouseUpEvent&gt;(ResizeEnd); &#125; /// &lt;summary&gt; /// 获取输入端口 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public Port GetInput() &#123; return _inputPort; &#125; /// &lt;summary&gt; /// 获取输出端口 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public Port GetOutput() &#123; return _outputPort; &#125; /// &lt;summary&gt; /// 设置运行状态，请在执行到该节点时调用 /// &lt;/summary&gt; /// &lt;param name=&quot;run&quot;&gt;&lt;/param&gt; public void SetRun(bool run) &#123; if (run) &#123; _isRun = true; SetBorder(_runColor, 5); &#125; else &#123; if (_isRun) &#123; SetBorder(_passColor, 5); &#125; else &#123; SetBorder(Color.white, 0); &#125; _isRun = false; &#125; &#125; /// &lt;summary&gt; /// 清除所有运行状态 /// &lt;/summary&gt; public void ClearRunState() &#123; // 执行两次确保完全清除 SetRun(false); SetRun(false); // 遍历节点 var connections = _outputPort.connections; foreach (var edge in connections) &#123; RootNode node = edge.input.node as RootNode; node?.ClearRunState(); &#125; &#125; /// &lt;summary&gt; /// 选中节点描边 /// &lt;/summary&gt; /// &lt;param name=&quot;leaf&quot;&gt;&lt;/param&gt; public void Selected(RootNode leaf = null) &#123; if (leaf == null) &#123; SetBorder(_selectColor, 5); &#125; else &#123; SetBorder(_parentColor, 5); &#125; // 遍历节点 var connections = _inputPort.connections; foreach (var edge in connections) &#123; RootNode node = edge.output.node as RootNode; node?.Selected(node); &#125; &#125; /// &lt;summary&gt; /// 取消选中节点描边 /// &lt;/summary&gt; public void UnSelected() &#123; SetBorder(_selectColor, 0); // 遍历节点 var connections = _inputPort.connections; foreach (var edge in connections) &#123; RootNode node = edge.output.node as RootNode; node?.UnSelected(); &#125; &#125; /// &lt;summary&gt; /// 判断是否有前置节点 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool HasParent() &#123; return _inputPort.connections.Any(); &#125; /// &lt;summary&gt; /// 保存数据 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public GDataNode SaveData() &#123; // 保存基本数据 _data.guid = guid; _data.pos = _defPos.ToString(); _data.size = (_curSize.Equals(Vector2.zero) ? _defSize : _curSize).ToString(); _dataNode.SetNodeType(_type.FullName); // 保存额外数据，用户自定义 SetData(); _dataNode.SetData(_data); // 遍历子节点 var connections = _outputPort.connections; foreach (var edge in connections) &#123; RootNode node = edge.input.node as RootNode; _dataNode.AddChild(node?.SaveData()); &#125; return _dataNode; &#125; /// &lt;summary&gt; /// 设置描边颜色，最好是在所有初始化完成后再调用 /// &lt;/summary&gt; /// &lt;param name=&quot;color&quot;&gt;&lt;/param&gt; private void SetBorder(Color color, float width) &#123; style.borderBottomWidth = width; style.borderBottomColor = color; style.borderLeftWidth = width; style.borderLeftColor = color; style.borderRightWidth = width; style.borderRightColor = color; style.borderTopWidth = width; style.borderTopColor = color; style.borderBottomLeftRadius = 10; style.borderBottomRightRadius = 10; style.borderTopLeftRadius = 10; style.borderTopRightRadius = 10; _borderOffset = width * 2; if (_inited) &#123; UpdateBorderSize(); &#125; &#125; /// &lt;summary&gt; /// 移除连线 /// &lt;/summary&gt; public void RemoveEdges() &#123; foreach (var edge in _outputPort.connections) &#123; _graph.RemoveElement(edge); &#125; &#125; /// &lt;summary&gt; /// 节点尺寸调节鼠标按下回调 /// &lt;/summary&gt; /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt; private void ResizeStart(MouseDownEvent evt) &#123; if (evt.button == 0) &#123; // 判断改大小 if (IsResizeArea(evt.localMousePosition)) &#123; _mouseOffset = evt.mousePosition - layout.size; _isResizing = true; evt.StopPropagation(); &#125; &#125; &#125; /// &lt;summary&gt; /// 节点尺寸调节鼠标移动回调 /// &lt;/summary&gt; /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt; private void ResizeMove(MouseMoveEvent evt) &#123; if (_isResizing) &#123; Vector2 newSize = evt.mousePosition - _mouseOffset; newSize = Vector2.Max(_defSize, newSize); // 更新节点的大小 UpdateSize(newSize); evt.StopPropagation(); &#125; &#125; /// &lt;summary&gt; /// 节点尺寸调节鼠标抬起回调 /// &lt;/summary&gt; /// &lt;param name=&quot;evt&quot;&gt;&lt;/param&gt; private void ResizeEnd(MouseUpEvent evt) &#123; if (_isResizing) &#123; Debug.Log(layout.size); _isResizing = false; evt.StopPropagation(); &#125; _defPos = layout.position + new Vector2(_borderOffset * 0.5f, _borderOffset * 0.5f); &#125; /// &lt;summary&gt; /// 是否在节点右下角区域 /// &lt;/summary&gt; /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private bool IsResizeArea(Vector2 position) &#123; // 根据需要定义 resizer 区域，这里以右下角为例 return position.x &gt;= layout.width - 10f - _borderOffset &amp;&amp; position.y &gt;= layout.height - 10f - _borderOffset; &#125; /// &lt;summary&gt; /// 初始化 UI /// &lt;/summary&gt; private void Init() &#123; InitConfig(); // 添加 GUID Label lbGuid = new Label(guid); lbGuid.style.position = Position.Absolute; lbGuid.style.top = -20; lbGuid.style.alignSelf = Align.Center; Add(lbGuid); // 获得类型 _type = GetType(); FieldInfo[] fields = _type.GetFields(_flag); // 设置标题颜色 Label lbTitle = mainContainer.Q&lt;Label&gt;(&quot;title-label&quot;, (string)null); lbTitle.style.color = Color.black; lbTitle.style.fontSize = 18; lbTitle.style.unityFontStyleAndWeight = FontStyle.Bold; // 固定 titleContainer 大小 titleContainer.style.minHeight = 25; titleContainer.style.maxHeight = 25; //mainContainer 着色 mainContainer.style.backgroundColor = new Color(0.5f, 0.5f, 0.5f, 1f); mainContainer.style.color = Color.black; mainContainer.style.flexGrow = 1; //extensionContainer 自动高度 extensionContainer.style.height = StyleKeyword.Auto; // extensionContainer.style.backgroundColor = new Color(0.55f, 1.00f, 0.78f, 0.8f); //ui box 分割。没有 box 标签的情况下都在默认的第一个 box 中添加 ui int boxCount = -1; var box = new VisualElement(); extensionContainer.Add(box); foreach (var field in fields) &#123; GraphNode attr = field.GetCustomAttribute&lt;GraphNode&gt;(); if (attr != null) &#123; // 辅助名称 GName gName = field.GetCustomAttribute&lt;GName&gt;(); string fieldName = field.Name.Replace(&quot;_&quot;, &quot;&quot;); string subName = gName != null ? gName.GetName() : fieldName.Substring(0, 1).ToUpper() + fieldName.Substring(1); // 容器宽度 GWidth gWidth = field.GetCustomAttribute&lt;GWidth&gt;(); Length len = gWidth != null ? gWidth.GetLength() : new Length(96, LengthUnit.Percent); // 判断是否需要增加 ui box if (boxCount == 0) &#123; box = new VisualElement(); extensionContainer.Add(box); &#125; if (boxCount &gt; -1) &#123; boxCount--; &#125; object value = field.GetValue(this); // 添加当前 UI 类型的父容器 VisualElement ele = new VisualElement(); ele.style.width = len; ele.style.marginTop = 8; ele.style.alignSelf = Align.Center; // 辅助标签 Label foreLabel; // 非注释 UI 情况下，UI 父容器底部描白边 if (attr.Type() != NodeTypeEnum.Note) &#123; ele.style.borderBottomColor = Color.white; ele.style.borderBottomWidth = 2; ele.style.paddingBottom = 3; &#125; // 设置值的委托函数 SetFieldDelegate setValue = (SetFieldDelegate)Delegate.CreateDelegate(typeof(SetFieldDelegate), field, &quot;SetValue&quot;, false); string[] extra = attr.GetExtra(); // 创建 UI switch (attr.Type()) &#123; case NodeTypeEnum.Label: Label label = new Label(); label.style.fontSize = _fontSize; label.text = value.ToString(); ele.Add(label); break; case NodeTypeEnum.Input: ele.style.flexDirection = FlexDirection.Row; foreLabel = new Label(); foreLabel.style.fontSize = _fontSize; foreLabel.text = subName; ele.Add(foreLabel); TextField text = new TextField(); text.style.flexGrow = 1; text.style.height = _fontSize * 1.2f; var fontChild = text.Children().FirstOrDefault().Children().FirstOrDefault(); fontChild.style.fontSize = _fontSize; text.RegisterValueChangedCallback(evt =&gt; &#123; setValue(this, evt.newValue); &#125;); ele.Add(text); break; case NodeTypeEnum.Note: // 创建注释背景 ele.style.flexDirection = FlexDirection.Column; ele.style.alignItems = Align.Center; ele.style.justifyContent = Justify.Center; ele.style.backgroundColor = new Color(0.64f, 0.78f, 1f, 1f); ele.style.borderBottomLeftRadius = 5; ele.style.borderBottomRightRadius = 5; ele.style.borderTopLeftRadius = 5; ele.style.borderTopRightRadius = 5; // 固定注释和可修改注释的情况 if (extra.Length &gt; 0 &amp;&amp; extra[0] == &quot;Custom&quot;) &#123; TextField note = new TextField(); note.value = value.ToString(); note.style.width = ele.style.width; note.style.height = StyleKeyword.Auto; note.multiline = true; note.style.whiteSpace = WhiteSpace.Normal; note.style.height = StyleKeyword.Auto; var child = note.Children().FirstOrDefault(); child.style.backgroundColor = Color.clear; child.style.borderBottomColor = Color.clear; child.style.borderTopColor = Color.clear; child.style.borderLeftColor = Color.clear; child.style.borderRightColor = Color.clear; child.style.borderBottomWidth = 0; child.style.borderTopWidth = 0; child.style.borderLeftWidth = 0; child.style.borderRightWidth = 0; child.style.color = Color.black; child.style.unityTextAlign = TextAnchor.MiddleCenter; fontChild = child.Children().FirstOrDefault().Children().FirstOrDefault(); fontChild.style.fontSize = _fontSize; note.RegisterValueChangedCallback((evt) =&gt; &#123; setValue(this, evt.newValue); &#125;); note.RegisterCallback&lt;FocusOutEvent&gt;(evt =&gt; &#123; UpdateNodeSize(); &#125;); ele.Add(note); &#125; else &#123; Label note = new Label(); note.style.fontSize = _fontSize; note.style.width = StyleKeyword.Auto; note.style.height = StyleKeyword.Auto; note.text = value.ToString(); note.style.whiteSpace = WhiteSpace.Normal; ele.Add(note); &#125; break; case NodeTypeEnum.Enum: ele.style.flexDirection = FlexDirection.Row; foreLabel = new Label(); foreLabel.style.fontSize = _fontSize; foreLabel.text = subName; ele.Add(foreLabel); EnumField enumField = new EnumField(value as Enum); enumField.style.flexGrow = 1; enumField.RegisterValueChangedCallback(evt =&gt; setValue(this, evt.newValue)); ele.Add(enumField); break; case NodeTypeEnum.Slide: ele.style.flexDirection = FlexDirection.Row; foreLabel = new Label(); foreLabel.style.fontSize = _fontSize; foreLabel.text = subName; ele.Add(foreLabel); bool isInt = extra[0] == &quot;Int&quot;; Label num = new Label(); num.style.fontSize = _fontSize; num.style.width = _fontSize * 3; num.style.unityTextAlign = TextAnchor.MiddleRight; if (isInt) &#123; SliderInt slider = new SliderInt(int.Parse(extra[1]), int.Parse(extra[2])); num.text = extra[1]; slider.value = 0; slider.style.flexGrow = 1; slider.RegisterValueChangedCallback(evt =&gt; &#123; setValue(this, evt.newValue); num.text = evt.newValue.ToString(); &#125;); ele.Add(slider); &#125; else &#123; Slider slider = new Slider(float.Parse(extra[0]), float.Parse(extra[1])); num.text = extra[0]; slider.value = 0; slider.style.flexGrow = 1; slider.RegisterValueChangedCallback(evt =&gt; &#123; setValue(this, evt.newValue); num.text = evt.newValue.ToString(); &#125;); ele.Add(slider); &#125; ele.Add(num); break; case NodeTypeEnum.Radio: RadioButtonGroup radioButtonGroup = new RadioButtonGroup(); radioButtonGroup.value = 0; ele.Add(radioButtonGroup); foreach (var selection in extra) &#123; RadioButton radio = new RadioButton(); radio.Children().FirstOrDefault().style.flexGrow = 0; Label lbRadio = new Label(); lbRadio.style.fontSize = _fontSize; lbRadio.text = selection; radio.Add(lbRadio); radioButtonGroup.Add(radio); &#125; radioButtonGroup.RegisterValueChangedCallback(evt =&gt; &#123; setValue(this, evt.newValue); &#125;); break; case NodeTypeEnum.Toggle: Toggle toggle = new Toggle(); toggle.style.width = StyleKeyword.Auto; toggle.Children().FirstOrDefault().style.flexGrow = 0; toggle.RegisterValueChangedCallback(evt =&gt; &#123; setValue(this, evt.newValue); &#125;); ele.Add(toggle); foreLabel = new Label(); foreLabel.style.fontSize = _fontSize; foreLabel.text = subName; toggle.Add(foreLabel); break; case NodeTypeEnum.Box: if (gName != null) &#123; foreLabel = new Label(); foreLabel.style.fontSize = _fontSize * 0.8f; foreLabel.text = subName; ele.Add(foreLabel); &#125; Color color = Color.yellow; GColor gColor = field.GetCustomAttribute&lt;GColor&gt;(); if (gColor != null) &#123; color = gColor.GetColor(); &#125; box = new VisualElement(); box.style.backgroundColor = color; box.style.marginTop = 8; box.style.width = new Length(96, LengthUnit.Percent); box.style.alignSelf = Align.Center; box.style.borderBottomLeftRadius = 5; box.style.borderBottomRightRadius = 5; box.style.borderTopLeftRadius = 5; box.style.borderTopRightRadius = 5; box.style.flexDirection = extra.Length &gt; 1 &amp;&amp; extra[1] == &quot;Column&quot; ? FlexDirection.Column : FlexDirection.Row; box.style.flexWrap = Wrap.Wrap; extensionContainer.Add(box); boxCount = int.Parse(extra[0]); break; &#125; box.Add(ele); &#125; &#125; &#125; /// &lt;summary&gt; /// 刷新尺寸 /// &lt;/summary&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; public void UpdateSize(Vector2 size) &#123; style.width = size.x; style.height = size.y; if (_isBordered) &#123; _curSize = size - new Vector2(_borderOffset, _borderOffset); &#125; else &#123; _curSize = size; &#125; &#125; /// &lt;summary&gt; /// 更新节点尺寸 /// &lt;/summary&gt; private void UpdateNodeSize() &#123; // 未手动调整过大小才自动更新 if (_curSize.Equals(Vector2.zero)) &#123; // 计算内容的总高度 float contentHeight = _defHeight + extensionContainer.layout.height + 10; // 设置 Node 的新高度 SetSize(new Vector2(_defSize.x, contentHeight)); DrawBorder(); &#125; &#125; /// &lt;summary&gt; /// 更新带描边的节点尺寸 /// &lt;/summary&gt; private void UpdateBorderSize() &#123; if (_borderOffset == 0) &#123; _isBordered = false; DrawBorder(); &#125; else if (!_isBordered) &#123; _isBordered = true; DrawBorder(); &#125; &#125; /// &lt;summary&gt; /// 描边 /// &lt;/summary&gt; private void DrawBorder() &#123; if (_isBordered) &#123; if (_curSize.Equals(Vector2.zero)) &#123; style.width = _defSize.x + _borderOffset; style.height = _defSize.y + _borderOffset; &#125; else &#123; style.width = _curSize.x + _borderOffset; style.height = _curSize.y + _borderOffset; &#125; _defPos = new Vector2(style.left.value.value, style.top.value.value); // 如果没描过边，则调整节点坐标位置以防止错位 if (_lastBordered != _isBordered) &#123; style.left = _defPos.x - _borderOffset * 0.5f; style.top = _defPos.y - _borderOffset * 0.5f; &#125; &#125; else &#123; if (_curSize.Equals(Vector2.zero)) &#123; style.width = _defSize.x; style.height = _defSize.y; &#125; else &#123; style.width = _curSize.x; style.height = _curSize.y; &#125; // 还原节点默认位置 style.left = _defPos.x; style.top = _defPos.y; &#125; _lastBordered = _isBordered; &#125; /// &lt;summary&gt; /// 初始化配置 /// &lt;/summary&gt; protected virtual void InitConfig() &#123; &#125; /// &lt;summary&gt; /// 保存数据 /// &lt;/summary&gt; protected virtual void SetData() &#123; &#125; /// &lt;summary&gt; /// 还原数据 /// &lt;/summary&gt; protected virtual void ResetData() &#123; &#125; /// &lt;summary&gt; /// 自定义 UI，如果有复杂的需求无法通过 Attribute 完成，则可以在这里拓展 /// &lt;/summary&gt; protected virtual void CustomUI() &#123; &#125; &#125;&#125; GSearchWindow GSearchWindow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384using System;using System.Collections.Generic;using System.Linq;using Unity.Plastic.Newtonsoft.Json;using Unity.Plastic.Newtonsoft.Json.Linq;using UnityEditor;using UnityEditor.Experimental.GraphView;using UnityEngine;namespace GraphViewExtension&#123; public class GSearchWindow: ScriptableObject,ISearchWindowProvider &#123; public delegate bool SelectHandle(SearchTreeEntry searchTreeEntry, SearchWindowContext context); public SelectHandle onSelectEntryHandler; private bool _inited; private JArray _menu; public List&lt;SearchTreeEntry&gt; entries = new List&lt;SearchTreeEntry&gt;() &#123; new SearchTreeGroupEntry (new GUIContent (&quot;创建节点&quot;)) &#125;; private void BuildTree() &#123; InitJson(); foreach (var token in _menu) &#123; CreateMenu(token); &#125; _inited = true; &#125; private void InitJson() &#123; string json = EditorGUIUtility.Load(&quot;Assets/Editor/GraphViewExtension/Graph/Menu.json&quot;).ToString(); _menu = JArray.Parse(json); &#125; private void CreateMenu(JToken obj,int level = 1) &#123; string menuName = obj[&quot;name&quot;].ToString(); string menuType = &quot;GraphViewExtension.&quot; + obj[&quot;type&quot;]; JToken children = obj[&quot;child&quot;]; bool isChild = children?.Count() &gt; 0; if (isChild) &#123; entries.Add(new SearchTreeGroupEntry(new GUIContent(menuName))&#123;level = level&#125;); foreach (var child in children) &#123; CreateMenu(child, level + 1); &#125; &#125; else &#123; entries.Add(new SearchTreeEntry(new GUIContent(menuName))&#123;level = level,userData = Type.GetType(menuType)&#125;); &#125; &#125; public List&lt;SearchTreeEntry&gt; CreateSearchTree(SearchWindowContext context) &#123; if (!_inited) &#123; BuildTree(); &#125; return entries; &#125; public bool OnSelectEntry(SearchTreeEntry searchTreeEntry, SearchWindowContext context) &#123; if (onSelectEntryHandler == null) return false; return onSelectEntryHandler(searchTreeEntry, context); &#125; &#125;&#125; GGraph GGraph123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558using System;using System.Collections.Generic;using System.Dynamic;using System.IO;using Unity.Plastic.Newtonsoft.Json;using Unity.Plastic.Newtonsoft.Json.Linq;using UnityEditor;using UnityEditor.Experimental.GraphView;using UnityEditor.UIElements;using UnityEngine;using UnityEngine.UIElements;namespace GraphViewExtension&#123; public class GGraph : GraphView &#123; /// &lt;summary&gt; /// 所属编辑器 /// &lt;/summary&gt; private EditorWindow _editorWindow; /// &lt;summary&gt; /// 右键创建节点的可搜索多级菜单 /// &lt;/summary&gt; private GSearchWindow _seachWindow; /// &lt;summary&gt; /// 默认节点大小 /// &lt;/summary&gt; private Vector2 _defaultNodeSize = new Vector2(200, 102); /// &lt;summary&gt; /// 当前点击节点 /// &lt;/summary&gt; private RootNode _clickNode; /// &lt;summary&gt; /// 打开的文件路径 /// &lt;/summary&gt; private string _filePath = &quot;&quot;; /// &lt;summary&gt; /// 是否打开一个文件 /// &lt;/summary&gt; private bool _isOpen = false; /// &lt;summary&gt; /// 是否在选择 /// &lt;/summary&gt; private bool _isSelect = false; /// &lt;summary&gt; /// 鼠标是否按下 /// &lt;/summary&gt; private bool _isDown = false; /// &lt;summary&gt; /// 鼠标是否移动了 /// &lt;/summary&gt; private bool _isMoved = false; private Dictionary&lt;string, RootNode&gt; _allNodes = new Dictionary&lt;string, RootNode&gt;(); public GGraph(EditorWindow editorWindow, GSearchWindow provider) &#123; _editorWindow = editorWindow; _seachWindow = provider; // 在右键菜单中添加节点 provider.onSelectEntryHandler = (searchTreeEntry, searchWindowContext) =&gt; &#123; var windowRoot = _editorWindow.rootVisualElement; var windowMousePosition = windowRoot.ChangeCoordinatesTo(windowRoot, searchWindowContext.screenMousePosition - _editorWindow.position.position); var graphMousePosition = contentViewContainer.WorldToLocal(windowMousePosition); var type = searchTreeEntry.userData as Type; CreateNode(type, graphMousePosition); return true; &#125;; // 监听创建节点 nodeCreationRequest += context =&gt; &#123; // 打开搜索框 SearchWindow.Open(new SearchWindowContext(context.screenMousePosition), provider); &#125;; // 监听节点删除 graphViewChanged += evt =&gt; &#123; if (evt.elementsToRemove != null) &#123; foreach (var element in evt.elementsToRemove) &#123; if (element is RootNode node) &#123; _allNodes.Remove(node.guid); &#125; &#125; &#125; return evt; &#125;; // 尺寸和父控件相同 this.StretchToParentSize(); // 滚轮缩放 SetupZoom(ContentZoomer.DefaultMinScale, ContentZoomer.DefaultMaxScale); // 窗口内容拖动 this.AddManipulator(new ContentDragger()); // 选中 Node 移动功能 this.AddManipulator(new SelectionDragger()); // 多个 node 框选功能 this.AddManipulator(new RectangleSelector()); // 加载样式表和网格 var styleSheet = EditorGUIUtility.Load(&quot;Assets/Editor/GraphViewExtension/Graph/GridBackground.uss&quot;) as StyleSheet; styleSheets.Add(styleSheet); var grid = new GridBackground(); Insert(0, grid); grid.StretchToParentSize(); SetupToolbar(); RegisterCallback&lt;PointerDownEvent&gt;(evt =&gt; &#123; if (evt.button == 0) &#123; _isDown = true; &#125; &#125;); RegisterCallback&lt;PointerMoveEvent&gt;(evt =&gt; &#123; if (_isDown) &#123; _isMoved = true; &#125; &#125;); // 监听点击的节点 RegisterCallback&lt;ClickEvent&gt;(evt =&gt; &#123; if (!_isMoved) &#123; Vector2 localMousePosition = evt.position - new Vector3(layout.xMin, layout.yMin); // 获取当前被选中的对象 var currentSelection = panel.Pick(localMousePosition); if (currentSelection == null) &#123; if (_clickNode != null) &#123; _clickNode.UnSelected(); _clickNode = null; &#125; &#125; else &#123; bool isInput = false; while (currentSelection != null &amp;&amp; currentSelection is not RootNode) &#123; if (IsInputField(currentSelection)) &#123; isInput = true; break; &#125; currentSelection = currentSelection.parent; &#125; if (currentSelection == null) &#123; if (_clickNode != null) &#123; _clickNode.UnSelected(); _clickNode = null; &#125; &#125; else &#123; if (isInput) return; if (_clickNode != null &amp;&amp; currentSelection != _clickNode &amp;&amp; currentSelection is not RootNode) &#123; _clickNode.UnSelected(); _clickNode = null; &#125; else &#123; _clickNode?.UnSelected(); _clickNode = currentSelection as RootNode; _clickNode?.Selected(); &#125; &#125; &#125; &#125; _isMoved = false; _isDown = false; &#125;); // 监听保存组合键 RegisterCallback&lt;KeyUpEvent&gt;(OnKeyUp); &#125; public override List&lt;Port&gt; GetCompatiblePorts(Port startPort, NodeAdapter nodeAdapter) &#123; // 存储符合条件的兼容的端口 List&lt;Port&gt; compatiblePorts = new List&lt;Port&gt;(); // 遍历 Graphview 中所有的 Port 从中寻找 ports.ForEach( (port) =&gt; &#123; if (startPort.node != port.node &amp;&amp; startPort.direction != port.direction) &#123; compatiblePorts.Add(port); &#125; &#125; ); return compatiblePorts; &#125; public RootNode CreateNode(Type type, Vector2 position) &#123; RootNode node = Activator.CreateInstance(type) as RootNode; // 这里只用到了 position node.SetPosition(new Rect(position, Vector2.zero)); node.RegistResize(this); node.SetSize(_defaultNodeSize); AddElement(node); _allNodes.Add(node.guid, node); return node; &#125; public RootNode CreateNode(Type type, string guid, Vector2 position, Vector2 size) &#123; RootNode node = Activator.CreateInstance(type) as RootNode; // 这里只用到了 position node.SetPosition(new Rect(position, Vector2.zero)); node.RegistResize(this); node.SetSize(_defaultNodeSize); node.UpdateSize(size); AddElement(node); node.guid = guid; _allNodes.Add(guid, node); // 创建节点标记为打开文件 _isOpen = true; return node; &#125; public Edge MakeEdge(Port oput, Port iput) &#123; var edge = new Edge &#123; output = oput, input = iput &#125;; edge?.input.Connect(edge); edge?.output.Connect(edge); AddElement(edge); return edge; &#125; public void ClearGraph() &#123; foreach (var node in _allNodes) &#123; node.Value.RemoveEdges(); RemoveElement(node.Value); &#125; _allNodes.Clear(); _isOpen = false; _filePath = &quot;&quot;; &#125; /// &lt;summary&gt; /// 是否可输入 UI /// &lt;/summary&gt; /// &lt;param name=&quot;element&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private bool IsInputField(VisualElement element) &#123; // 判断元素是否是 BaseField&lt;T&gt; 或其派生类的实例 return HasBaseField(element.GetType()); &#125; bool HasBaseField(Type type) &#123; if (type.Name.IndexOf(&quot;BaseField&quot;) != -1) &#123; return true; &#125; // 检查当前类型的基类的字段 if (type.BaseType != null) &#123; return HasBaseField(type.BaseType); &#125; return false; &#125; /// &lt;summary&gt; /// 保存数据 /// &lt;/summary&gt; public List&lt;GDataNode&gt; SaveData() &#123; List&lt;GDataNode&gt; list = new List&lt;GDataNode&gt;(); foreach (var nodeData in _allNodes) &#123; RootNode node = nodeData.Value; if (!node.HasParent()) &#123; GDataNode dataNode = node.SaveData(); list.Add(dataNode); &#125; &#125; return list; &#125; /// &lt;summary&gt; /// 当前是否打开文件 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool GetOpen() &#123; return _isOpen; &#125; public void SetFilePath(string filePath) &#123; _filePath = filePath; &#125; public void OpenData(List&lt;GDataNode&gt; datas, RootNode parent = null) &#123; foreach (var data in datas) &#123; Type type = Type.GetType(data.GetNodeType()); dynamic nodeData = data.GetData(); string[] pos = nodeData.pos.Trim(&#x27;(&#x27;, &#x27;)&#x27;).Split(&#x27;,&#x27;); string[] size = nodeData.size.Trim(&#x27;(&#x27;, &#x27;)&#x27;).Split(&#x27;,&#x27;); RootNode newNode = CreateNode(type, nodeData.guid, new Vector2(float.Parse(pos[0]), float.Parse(pos[1])), new Vector2(float.Parse(size[0]), float.Parse(size[1]))); newNode.SetData(nodeData); if (parent != null) &#123; // 连线 MakeEdge(parent.GetOutput(), newNode.GetInput()); &#125; OpenData(data.GetChildren(), newNode); &#125; &#125; protected virtual void SetupToolbar() &#123; var toolbar = new Toolbar(); var openBtn = new ToolbarButton &#123;text = &quot;打开&quot;&#125;; openBtn.clicked += Open; var saveBtn = new ToolbarButton &#123;text = &quot;保存&quot;&#125;; saveBtn.clicked += Save; var closeBtn = new ToolbarButton &#123;text = &quot;关闭&quot;&#125;; closeBtn.clicked += Close; toolbar.Add(openBtn); toolbar.Add(saveBtn); toolbar.Add(closeBtn); Add(toolbar); &#125; private void Open() &#123; bool isOpen = GetOpen(); if (isOpen) &#123; bool res = EditorUtility.DisplayDialog (&quot;打开新文件&quot;, &quot;是否打开一个新的文件，当前内容未保存的部分会消失。&quot;, &quot;确定&quot;, &quot;取消&quot;); if (res) &#123; ClearGraph(); &#125; else &#123; return; &#125; &#125; string filePath = EditorUtility.OpenFilePanel (&quot;打开 ScriptableObject&quot;, &quot;Assets/Json&quot;, &quot;json&quot;); if (filePath != &quot;&quot;) &#123; string jsonData = &quot;&quot;; StreamReader sr = File.OpenText(filePath); while (sr.ReadLine() is &#123; &#125; nextLine) &#123; jsonData += nextLine; &#125; sr.Close(); List&lt;SaveJson&gt; json = JsonConvert.DeserializeObject&lt;List&lt;SaveJson&gt;&gt;(jsonData); List&lt;GDataNode&gt; list = new List&lt;GDataNode&gt;(); foreach (var data in json) &#123; list.Add(ToGDataNode(data)); &#125; SetFilePath(filePath); OpenData(list); &#125; &#125; private void Save() &#123; string filePath = EditorUtility.SaveFilePanel (&quot;保存到本地&quot;, Application.dataPath + &quot;/Json&quot;, &quot;NewFile&quot;, &quot;json&quot;); if (filePath != &quot;&quot;) &#123; SetFilePath(filePath); List&lt;GDataNode&gt; list = SaveData(); List&lt;SaveJson&gt; listJson = new List&lt;SaveJson&gt;(); foreach (var data in list) &#123; listJson.Add(ToJson(data)); &#125; string jsonData = JsonConvert.SerializeObject(listJson); FileInfo myFile = new FileInfo(filePath); StreamWriter sw = myFile.CreateText(); foreach (var s in jsonData) &#123; sw.Write(s); &#125; sw.Close(); _editorWindow.ShowNotification (new GUIContent (&quot;保存成功，路径为:&quot; + filePath)); &#125; &#125; private void Close() &#123; ClearGraph(); &#125; private void OnKeyUp(KeyUpEvent evt) &#123; // 检查是否按下了 Ctrl 键和 S 键 if (evt.keyCode == KeyCode.S &amp;&amp; evt.ctrlKey) &#123; if (_filePath == &quot;&quot;) &#123; Save(); return; &#125; Debug.Log(&quot;Ctrl + S pressed. Saving...&quot;); // 执行保存操作 List&lt;GDataNode&gt; list = SaveData(); List&lt;SaveJson&gt; listJson = new List&lt;SaveJson&gt;(); foreach (var data in list) &#123; listJson.Add(ToJson(data)); &#125; string jsonData = JsonConvert.SerializeObject(listJson); FileInfo myFile = new FileInfo(_filePath); StreamWriter sw = myFile.CreateText(); foreach (var s in jsonData) &#123; sw.Write(s); &#125; sw.Close(); // 这里可以添加你的保存逻辑 evt.StopPropagation (); // 阻止事件传递，避免触发其他事件 &#125; &#125; /// &lt;summary&gt; /// 转换为 JSON /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public SaveJson ToJson(GDataNode data) &#123; SaveJson save = new SaveJson(); save.type = data.GetNodeType(); save.data = data.GetData(); foreach (var child in data.GetChildren()) &#123; save.children.Add(ToJson(child)); &#125; return save; &#125; /// &lt;summary&gt; /// 转换为节点数据 /// &lt;/summary&gt; /// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public GDataNode ToGDataNode(SaveJson json) &#123; GDataNode data = new GDataNode(); data.SetNodeType(json.type); dynamic obj = new ExpandoObject(); foreach (var res in (json.data as JObject).Properties()) &#123; JTokenType jType = res.Value.Type; switch (jType) &#123; case JTokenType.String: ((IDictionary&lt;string, object&gt;)obj)[res.Name] = res.Value.Value&lt;string&gt;(); break; case JTokenType.Float: ((IDictionary&lt;string, object&gt;)obj)[res.Name] = res.Value.Value&lt;float&gt;(); break; case JTokenType.Boolean: ((IDictionary&lt;string, object&gt;)obj)[res.Name] = res.Value.Value&lt;bool&gt;(); break; &#125; &#125; data.SetData(obj); foreach (var child in json.children) &#123; data.AddChild(ToGDataNode(child)); &#125; return data; &#125; &#125;&#125; 背景 uss GridBackground123456GridBackground &#123; --grid-background-color : #222222; --line-color: rgba(193,196,192,0.1); --thick-line-color: rgba(193,196,192,0.1); --spacing: 25;&#125; 菜单配置文件格式 菜单配置文件1234567891011121314151617181920212223[ &#123; &quot;name&quot;: &quot;装饰节点&quot;, &quot;child&quot;: [ &#123; &quot;name&quot;: &quot;胜利节点&quot;, &quot;type&quot;: &quot;DNodeSuccess&quot; &#125;, &#123; &quot;name&quot;: &quot;失败节点&quot;, &quot;type&quot;: &quot;DNodeFail&quot; &#125;, &#123; &quot;name&quot;: &quot;反转节点&quot;, &quot;type&quot;: &quot;DNodeReverse&quot; &#125; ] &#125;, &#123; &quot;name&quot;: &quot;测试节点&quot;, &quot;type&quot;: &quot;TestNode&quot; &#125;] GDataNode GDataNode12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System.Collections.Generic;namespace GraphViewExtension&#123; public class GDataNode &#123; private List&lt;GDataNode&gt; _children = new List&lt;GDataNode&gt;(); private dynamic _data; private string _type; public void SetData(dynamic data) &#123; _data = data; &#125; public void SetNodeType(string type) &#123; _type = type; &#125; public void AddChild(GDataNode node) &#123; if (!_children.Contains(node)) &#123; _children.Add(node); &#125; &#125; public List&lt;GDataNode&gt; GetChildren() &#123; return _children; &#125; public dynamic GetData() &#123; return _data; &#125; public string GetNodeType() &#123; return _type; &#125; &#125;&#125; SaveJson SaveJson12345678910111213using System.Collections.Generic;namespace GraphViewExtension&#123; public class SaveJson &#123; public List&lt;SaveJson&gt; children = new List&lt;SaveJson&gt;(); public dynamic data; public string type; &#125;&#125; 测试编辑器 编辑器1234567891011121314151617181920212223242526using UnityEditor;namespace GraphViewExtension&#123; [EName (&quot;测试工具&quot;)] public class TestEditor : BaseEditor&lt;TestEditor&gt; &#123; private GGraph _view; [MenuItem(&quot;GraphView/Editor&quot;)] public static void ShowWindow() &#123; var window = GetWindow&lt;TestEditor&gt;(); window.Show(); window.InitGraph(); &#125; public void InitGraph() &#123; var provider = CreateInstance&lt;GSearchWindow&gt;(); var graph = new GGraph(this, provider); rootVisualElement.Add(graph); _view = graph; &#125; &#125;&#125; 项目仓库 更新日志2024-05-13 更新基本内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"框架","slug":"框架","permalink":"https://busyogg.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"GraphView","slug":"GraphView","permalink":"https://busyogg.github.io/tags/GraphView/"}]},{"title":"视频批量转换脚本","slug":"视频批量转换脚本","date":"2024-04-27T10:37:09.000Z","updated":"2024-05-18T15:38:22.229Z","comments":true,"path":"article/f07bd054d1b2/","link":"","permalink":"https://busyogg.github.io/article/f07bd054d1b2/","excerpt":"","text":"简介用于把视频转为以时间为标题的 MOV 格式。通过 ffmpeg 实现。 支持批量操作，但是任务之间以单线程形式执行。 演示 功能 重命名标题。 转换格式为 MOV。 可以通过修改源代码实现自己需要的需求。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@echo offsetlocal enabledelayedexpansionREM 检查是否拖拽了文件到脚本上if &quot;%~1&quot;==&quot;&quot; ( echo Usage: %0 ^&lt;input_file1^&gt; [^&lt;input_file2^&gt; ...] exit /b 1)REM 获取批处理文件所在的目录set &quot;script_dir=%~dp0&quot;:process_filesREM 如果有文件待处理则继续，否则退出脚本if &quot;%~1&quot;==&quot;&quot; ( exit /b 0)REM 获取当前日期和时间，并去除空格set year=%date:~0,4%set month=%date:~5,2%set day=%date:~8,2%set hour=%time:~0,2%if &quot;!hour:~0,1!&quot;==&quot; &quot; set &quot;hour=0!hour:~1,1!&quot;set minute=%time:~3,2%set second=%time:~6,2%set datetime=!year!-!month!-!day!-!hour!-!minute!-!second!REM 获取第一个待处理的文件set &quot;input_file=%~1&quot;REM 使用当前时间生成文件名set &quot;output_file=%datetime%&quot;REM 移除文件名中不合法的字符set &quot;output_file=%output_file:&quot;=%&quot; REM 移除双引号set &quot;output_file=%output_file:&amp;=and%&quot; REM 替换 &amp; 符号为 &quot;and&quot;REM 检查输出文件是否已存在，如果存在则增加后缀if exist &quot;%script_dir%!output_file!.mov&quot; ( set /a count=1 :loop if exist &quot;%script_dir%!output_file%_!count!.mov&quot; ( set /a count+=1 goto :loop ) set &quot;output_file=!output_file!_!count!&quot;) else ( REM 添加文件扩展名 set &quot;output_file=%output_file%.mov&quot;)REM 使用FFmpeg进行转码，并保存在批处理文件夹下ffmpeg -i &quot;!input_file!&quot; -c:v libx264 -crf 24 -c:a copy &quot;%script_dir%!output_file!&quot;REM 等待一秒timeout /t 1 &gt;nulREM 处理下一个文件shiftgoto :process_files","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://busyogg.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://busyogg.github.io/tags/ffmpeg/"}]},{"title":"Shader-草地","slug":"Shader-草地","date":"2024-04-17T09:06:29.000Z","updated":"2024-05-30T12:28:06.218Z","comments":true,"path":"article/3306b5965f83/","link":"","permalink":"https://busyogg.github.io/article/3306b5965f83/","excerpt":"","text":"简介草地 Shader，根据噪声图控制摆动，支持风向和风力调整，可交互。有若干可以控制的参数调整整体的效果。 原理风场利用噪声图保存的向量信息使顶点进行偏移。噪声图的颜色信息的 rgb 分量即对应方向向量的 xyz 分量。 在顶点着色器中，我们使用 tex2Dlod 方法对噪声图进行采样，采样的 uv 使用顶点的世界坐标，这样可以在所有模型上保持连贯性。 利用内置 _Time 参数进行采样数据的变化： 123456//计算世界坐标float4 worldPos = mul(unity_ObjectToWorld, v.vertex);//计算uvfloat2 offsetUV = (worldPos.xz * 1 / _sampleScale) * _Time.x;//采样float4 sample = tex2Dlod(_sample, float4(offsetUV, 0, 0)); 其中 _sampleScale 用于缩放采样尺度，越小变化越快。 为了能够改变风向，我们设置一个风向参数（范围为 0 - 360 度），因绕 Y 轴的旋转矩阵为： $$ \\left[ \\begin{matrix} cos(θ) &amp; 0 &amp; sin(θ) &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -sin(θ) &amp; 0 &amp; cos(θ) &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right]$$ 把风向转为弧度并填入其中就能得到该方向的旋转矩阵。 最后把旋转矩阵乘以偏移量就能得到正确的方向了。 为了使草地底部顶点不偏移，我们计算顶点相对于底部的高度，为了适配不同中心点的模型，我们单独设置一个参数 _Bottom 来校准。 12345678//计算模型顶点相对于底部顶点的高度float bottom = v.vertex.y - _Bottom;//计算xz方向偏移float2 offset = sample.xz * bottom * _WindStrength;//改变xz顶点坐标v.vertex.xz += offset * 0.1;//改变y顶点坐标v.vertex.y -= sample.y * bottom * 0.1 * _WindStrength; 顶点偏移的规则可以根据自己的需要修改。 交互此处交互只做了单个对象的交互，使用全局坐标。多个对象可以使用 RenderTexture 来实现。 通过获取随意一个草地材质的 sharedMaterial 并设置 _GlobalPos 参数，我们就可以在所有的草地 shader 上同步交互物体坐标。 然后通过自定义的规则进行顶点交互偏移。 123456789101112131415//获取改变后顶点坐标的世界空间float3 newWoldPos = mul(unity_ObjectToWorld, v.vertex);//计算交互方向float2 interactiveVec = newWoldPos.xz - _GlobalPos.xz;//计算顶点与交互物体坐标的距离float dist = length(interactiveVec);//计算交互距离比率float distRatio = clamp(0, 1, dist / _InteractiveRadius);//计算交互方向法线float2 interactiveOffset = normalize(interactiveVec.xy);//计算最终交互向量float2 interactiveOffsetFinal = clamp(0,0.4,interactiveOffset * (1 - distRatio) * bottom);//更新顶点坐标v.vertex.xz += interactiveOffsetFinal;v.vertex.y -= bottom * (1 - distRatio); 如果有不止一种草地 Shader 的话，还是使用 RenderTexture 来实现比较好，以后有空再更新。 投影投影需要新增一个 Pass，顶点着色器也要进行顶点变化，这样才能显示正确的阴影。 代码草地Shader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226Shader &quot;Custom/Plant&quot;&#123; Properties &#123; _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20 _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125; _Bottom(&quot;Bottom&quot;,Range(-1,0)) = 0.0 _WindStrength(&quot;WindStrength&quot;,Range(0,45)) = 0.0 _WindDirection(&quot;WindDirection&quot;,Range(0,360)) = 0.0 _sample(&quot;sample (RGB)&quot;,2D) = &quot;black&quot; &#123;&#125; _sampleScale(&quot;sampleScale&quot;,Range(0,100)) = 1.0 _InteractiveRadius(&quot;InteractiveRadius&quot;,Float) = 1.0 _GlobalPos(&quot;GlobalPos&quot;,Vector) = (0,0,0) &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; Cull Back CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fwdbase #include &quot;UnityCG.cginc&quot; #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; sampler2D _MainTex; sampler2D _sample; float _WindStrength; float _WindDirection; float _sampleScale; float _InteractiveRadius; float3 _GlobalPos; float _Bottom; struct v2f &#123; float4 pos : SV_POSITION; fixed4 uv : TEXCOORD0; fixed4 worldPos : TEXCOORD1; float3 worldNormal : TEXCOORD2; SHADOW_COORDS(3) &#125;; v2f vert(appdata_base v) &#123; v2f o; //计算世界坐标 float4 worldPos = mul(unity_ObjectToWorld, v.vertex); //计算uv float2 offsetUV = (worldPos.xz * 1 / _sampleScale) * _Time.x; //采样 float4 sample = tex2Dlod(_sample, float4(offsetUV, 0, 0)); //风向 float rad = _WindDirection * UNITY_PI / 180; float4x4 rot = float4x4( cos(rad),0,sin(rad),0, 0,1,0,0, -sin(rad),0,cos(rad),0, 0,0,0,1 ); //旋转采样 sample = mul(rot,sample); //计算模型顶点相对于底部顶点的高度 float bottom = v.vertex.y - _Bottom; //计算xz方向偏移 float2 offset = sample.xz * bottom * _WindStrength; //改变xz顶点坐标 v.vertex.xz += offset * 0.1; //改变y顶点坐标 v.vertex.y -= sample.y * bottom * 0.1 * _WindStrength; //获取改变后顶点坐标的世界空间 float3 newWoldPos = mul(unity_ObjectToWorld, v.vertex); //计算交互方向 float2 interactiveVec = newWoldPos.xz - _GlobalPos.xz; //计算顶点与交互物体坐标的距离 float dist = length(interactiveVec); //计算交互距离比率 float distRatio = clamp(0, 1, dist / _InteractiveRadius); //计算交互方向法线 float2 interactiveOffset = normalize(interactiveVec.xy); //计算最终交互向量 float2 interactiveOffsetFinal = clamp(0,0.4,interactiveOffset * (1 - distRatio) * bottom); //更新顶点坐标 v.vertex.xz += interactiveOffsetFinal; v.vertex.y -= bottom * (1 - distRatio); o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord; o.worldPos = worldPos; o.worldNormal = UnityObjectToWorldNormal(v.normal); // o.worldNormal = UnityObjectToWorldNormal(mul(rotX, mul(rotZ, v.normal))); TRANSFER_SHADOW(o); return o; &#125; float4 frag(v2f i) : SV_Target &#123; //texture采样 fixed4 color = tex2D(_MainTex, i.uv); // color *= _Diffuse; fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); fixed atten = 1.0; //光照衰减 fixed shadow = SHADOW_ATTENUATION(i); return fixed4(color.xyz * (ambient + (diffuse + specular) * atten * shadow), 1.0); &#125; ENDCG &#125; Pass &#123; Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_shadowcaster #include &quot;UnityCG.cginc&quot; struct v2f &#123; V2F_SHADOW_CASTER; // float4 pos : SV_POSITION; // float3 worldPos : TEXCOORD0; &#125;; sampler2D _sample; float _WindStrength; float _WindDirection; float _sampleScale; float _InteractiveRadius; float3 _GlobalPos; float _Bottom; v2f vert(appdata_base v) &#123; v2f o; float4 worldPos = mul(unity_ObjectToWorld, v.vertex); float2 offsetUV = (worldPos.xz * 1 / _sampleScale) * _Time.x; //采样 float4 sample = tex2Dlod(_sample, float4(offsetUV, 0, 0)); float rad = _WindDirection * UNITY_PI / 180; //风向 float4x4 rot = float4x4( cos(rad),0,sin(rad),0, 0,1,0,0, -sin(rad),0,cos(rad),0, 0,0,0,1 ); sample = mul(rot,sample); float bottom = v.vertex.y - _Bottom; float2 offset = sample.xz * bottom * _WindStrength; v.vertex.xz += offset * 0.1; v.vertex.y -= sample.y * bottom * 0.1 * _WindStrength; float3 newWoldPos = mul(unity_ObjectToWorld, v.vertex); //计算交互方向 float2 interactiveVec = newWoldPos.xz - _GlobalPos.xz; //计算顶点与交互物体坐标的距离 float dist = length(interactiveVec); //计算交互距离比率 float distRatio = clamp(0, 1, dist / _InteractiveRadius); float2 interactiveOffset = normalize(interactiveVec.xy); float2 interactiveOffsetFinal = clamp(0,0.4,interactiveOffset * (1 - distRatio) * bottom); v.vertex.xz += interactiveOffsetFinal; v.vertex.y -= bottom * (1 - distRatio); TRANSFER_SHADOW_CASTER(o); return o; &#125; float4 frag(v2f i) : SV_Target &#123; SHADOW_CASTER_FRAGMENT(i) &#125; ENDCG &#125; &#125; FallBack &quot;Diffuse&quot;&#125; 交互坐标更新123456789101112131415161718using System;using UnityEngine;public class PosUpdate : MonoBehaviour&#123; private Material _grass; private void Awake() &#123; //自己获取草地的sharedMaterial，此处偷懒直接查找了 _grass = GameObject.Find(&quot;uploads_files_3639591_Grass&quot;).transform.GetChild(0).GetComponent&lt;Renderer&gt;().sharedMaterial; &#125; private void Update() &#123; _grass.SetVector(&quot;_GlobalPos&quot;,transform.position); &#125;&#125; 项目工程 更新日志2024-04-17 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"Shader","slug":"Unity/Shader","permalink":"https://busyogg.github.io/categories/Unity/Shader/"}],"tags":[{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Shader-进度条","slug":"Shader-进度条","date":"2024-04-01T12:29:36.000Z","updated":"2024-05-30T12:28:01.898Z","comments":true,"path":"article/919acd35c6df/","link":"","permalink":"https://busyogg.github.io/article/919acd35c6df/","excerpt":"","text":"简介进度条 Shader，拥有如下特性： 可以控制进度条的颜色和背景颜色，包括透明度控制。 可以选择进度条的方向。 通过传入进度值来更新进度条。 效果如下： 原理限定形状传入带有透明通道的贴图并采样，判断当前 uv 是否为透明像素，是的话就渲染为透明，不是的话就按照相应的规则渲染。 渲染进度条通过 atan2 函数计算当前 XZ 平面的模型坐标相对于 x 轴的旋转角度。 因为 atan2 函数在 Z 方向上为正的时候，夹角为 0 - 180，为负时夹角为 0 - -180，因此我们在夹角为负的时候加上 360，使其在总体上夹角为 0 - 360 范围。 以上是正方向进度条的调整，如果是负方向的话就在夹角为正的时候减去 360，然后取绝对值。 透明度混合 前景色透明度和背景色透明度相加，并限制范围为 0 - 255。 判断当前像素属于已经走过的进度条还是没走过的，已走过就取步骤 1 的透明度，否则用背景色透明度。 判断当前 uv 是否为透明像素，即限定形状，不透明就用步骤 2 的透明度，否则透明度为 0。 代码进度条Shader1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889Shader &quot;Unlit/Progress&quot;&#123; Properties &#123; _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125; _Progress (&quot;Progress&quot;,Range(0,1)) = 0 _BackgroundColor (&quot;BackgroundColor&quot;,Color) = (0,0,0,0) _ForegroundColor (&quot;ForegroundColor&quot;,Color) = (0,1,0,1) [Toggle(_True)]_Forward(&quot;Forward&quot;, Int) = 1 &#125; SubShader &#123; Tags &#123; &quot;RenderType&quot;=&quot;Transparent&quot; &#125; Blend SrcAlpha OneMinusSrcAlpha // 使用标准的透明混合模式 LOD 100 Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag // make fog work #pragma multi_compile_fog #include &quot;UnityCG.cginc&quot; struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; float3 pos: TEXCOORD1; &#125;; sampler2D _MainTex; float4 _MainTex_ST; float _Progress; float4 _BackgroundColor; float4 _ForegroundColor; int _Forward; v2f vert(appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); o.pos = v.vertex.xyz; return o; &#125; fixed4 frag(v2f i) : SV_Target &#123; //贴图采样 只用贴图的a通道 fixed4 col = tex2D(_MainTex, i.uv); //计算前景色和背景色的透明度和 fixed4 final = fixed4(0, 0, 0, 0); //计算原点到坐标点相对于x轴的角度 float angle = atan2(i.pos.z, i.pos.x) * (180 / 3.14159); //计算顺时针和逆时针角度 angle = _Forward == 0 ? (angle &lt; 0 ? angle + 360 : angle) : abs(angle &gt; 0 ? angle - 360 : angle); //根据当前坐标角度和目标角度的大小关系渲染进度条 const float curAngle = _Progress * 360; final.rgb = curAngle &gt;= angle ? _ForegroundColor.xyz * _ForegroundColor.a + _BackgroundColor.xyz * (1 - _ForegroundColor.a) : _BackgroundColor.xyz; //计算透明度和混色 const float quadFinalAlpha = clamp(0,255,_BackgroundColor.a + _ForegroundColor.a) ; const float semiFinalAlpha = curAngle &gt;= angle ? quadFinalAlpha: _BackgroundColor.a; final.a = step(1 - col.a, 0.5) == 1 ? semiFinalAlpha : 0; return final; &#125; ENDCG &#125; &#125;&#125; 项目工程 更新日志2024-04-01 更新基本内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"Shader","slug":"Unity/Shader","permalink":"https://busyogg.github.io/categories/Unity/Shader/"}],"tags":[{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Shader-描边","slug":"Shader-描边","date":"2024-04-01T09:30:30.000Z","updated":"2024-05-30T12:27:58.483Z","comments":true,"path":"article/b7477ac748d2/","link":"","permalink":"https://busyogg.github.io/article/b7477ac748d2/","excerpt":"","text":"简介给物体描边的 Shader，实现的方法有多种，例如顶点扩大、法线与视线点积、后处理等。不同的方法有其对应的优缺点和适用范围。 本文采用顶点扩大的方法。 原理顶点扩大顶点扩大的原理很简单。 描边 Shader 包含两个 Pass，一个 Pass 正常渲染物体，另一个 Pass 渲染描边。 正常的 Pass 剔除背面，描边的 Pass 剔除正面。 描边的 Pass 把原来模型的顶点沿法线方向移动一定距离，也就是扩大模型顶点，这样就有一个轮廓套在原来的模型外面。 如图所示，把原模型（蓝色）顶点向外扩展到红色大小，这样红色和蓝色之间的区域就是描边。 描边粗细固定由于顶点的变化在 NDC（标准设备坐标）空间中的变化不会受到相机距离的影响，因此我们把顶点扩大放在这里进行。 又因为 NDC 空间是 -1 到 1 的归一化坐标空间，因此我们需要计算屏幕的宽高比，然后令变化后的顶点 X 坐标乘以宽高比得到正确的坐标，否则在现实的时候 X 方向的粗细会不均匀。 常见问题当模型某些顶点在多个面存在的时候，描边就会产生断开的现象。最典型的例子就是立方体。 网图 如图所示。 这时候我们就要平滑法线。我们把存在于多个面的顶点的法线相加，得到一个最终的法线方向，这样就能避免这个问题。 平滑法线的过程可以放在运行前，提前处理模型数据，也可以放在运行时，不过运行时处理会造成额外的性能开销。 本文把平滑法线的过程放在运行时，结果写入切线中（写入法线可能会造成光影计算出问题），读取的时候也是从切线读取。 代码描边Shader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129Shader &quot;Custom/Outline&quot;&#123; Properties &#123; _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1) _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1) _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20 _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125; _OutlineWidth (&quot;OutlineWidth&quot;, Range(0,1)) = 0.1 _OutlineColor (&quot;OutlineColor&quot;, Color) = (0,0,0,1) &#125; SubShader &#123; Pass &#123; Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125; Cull Back CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile_fwdbase #include &quot;UnityCG.cginc&quot; #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; sampler2D _MainTex; struct v2f &#123; float4 pos : SV_POSITION; fixed4 uv : TEXCOORD0; fixed4 worldPos : TEXCOORD1; float3 worldNormal : TEXCOORD2; SHADOW_COORDS(3) &#125;; v2f vert(appdata_base v) &#123; v2f o; //顶点转为裁剪空间坐标 o.pos = UnityObjectToClipPos(v.vertex); o.uv = v.texcoord; o.worldPos = mul(unity_ObjectToWorld,v.vertex.xyz); o.worldNormal = UnityObjectToWorldNormal(v.normal); TRANSFER_SHADOW(o); return o; &#125; float4 frag(v2f i) : SV_Target &#123; //texture采样 fixed4 color = tex2D(_MainTex,i.uv); //光影计算 fixed3 worldNormal = normalize(i.worldNormal); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); fixed atten = 1.0;//光照衰减 fixed shadow = SHADOW_ATTENUATION(i); return fixed4(color * (ambient + (diffuse + specular) * atten * shadow), 1.0); &#125; ENDCG &#125; Pass &#123; Cull Front CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct v2f &#123; float4 pos : SV_POSITION; &#125;; float _OutlineWidth; fixed4 _OutlineColor; v2f vert(appdata_tan v) &#123; v2f o; //把顶点转换到裁剪空间 float4 pos = UnityObjectToClipPos(v.vertex); //把法线转换到ndc空间 float3 ndcNormal = normalize(mul((float3x3)unity_MatrixMVP, v.tangent.xyz)) * pos.w; //将近裁剪面右上角位置的顶点变换到观察空间 float4 nearUpperRight = mul(unity_CameraInvProjection, float2(1, 1)); //求得屏幕宽高比 const float aspect = abs(nearUpperRight.y / nearUpperRight.x); //使法线方向正确适配屏幕宽高比 ndcNormal.x *= aspect; //顶点扩张 pos.xy += 0.1 * _OutlineWidth * ndcNormal.xy; o.pos = pos; return o; &#125; float4 frag(v2f i) : SV_Target &#123; return _OutlineColor; &#125; ENDCG &#125; &#125; FallBack &quot;Diffuse&quot;&#125; 平滑法线运行时脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using System.Collections.Generic;using UnityEngine;public class SmoothOutline : MonoBehaviour&#123; Mesh MeshNormalAverage(Mesh mesh) &#123; //存储顶点和对应的索引 Dictionary&lt;Vector3, List&lt;int&gt;&gt; map = new Dictionary&lt;Vector3, List&lt;int&gt;&gt;(); for (int v = 0; v &lt; mesh.vertexCount; ++v) &#123; if (!map.ContainsKey(mesh.vertices[v])) &#123; map.Add(mesh.vertices[v], new List&lt;int&gt;()); &#125; map[mesh.vertices[v]].Add(v); &#125; Vector3[] normals = mesh.normals; Vector3 normal; foreach(var p in map) &#123; normal = Vector3.zero; //根据顶点所有对应索引计算法线总方向 foreach (var n in p.Value) &#123; normal += mesh.normals[n]; &#125; //归一化 normal /= p.Value.Count; foreach (var n in p.Value) &#123; normals[n] = normal; &#125; &#125; //把平滑后的顶点法线信息存入切线信息 var tangents = new Vector4[mesh.vertexCount]; for (var j = 0; j &lt; mesh.vertexCount; j++) &#123; tangents[j] = new Vector4(normals[j].x, normals[j].y, normals[j].z, 0); &#125; mesh.tangents= tangents; return mesh; &#125; void Awake() &#123; if (GetComponent&lt;MeshFilter&gt;()) &#123; Mesh tempMesh = (Mesh)Instantiate(GetComponent&lt;MeshFilter&gt;().sharedMesh); tempMesh=MeshNormalAverage(tempMesh); gameObject.GetComponent&lt;MeshFilter&gt;().sharedMesh = tempMesh; &#125; if (GetComponent&lt;SkinnedMeshRenderer&gt;()) &#123; Mesh tempMesh = (Mesh)Instantiate(GetComponent&lt;SkinnedMeshRenderer&gt;().sharedMesh); tempMesh = MeshNormalAverage(tempMesh); gameObject.GetComponent&lt;SkinnedMeshRenderer&gt;().sharedMesh = tempMesh; &#125; &#125;&#125; 项目工程 更新日志2024-04-01 更新基本内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"Shader","slug":"Unity/Shader","permalink":"https://busyogg.github.io/categories/Unity/Shader/"}],"tags":[{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Cloudflare 优选 IP","slug":"Cloudflare优选IP","date":"2024-03-20T11:09:10.000Z","updated":"2024-05-30T12:27:33.047Z","comments":true,"path":"article/8583c53078ec/","link":"","permalink":"https://busyogg.github.io/article/8583c53078ec/","excerpt":"","text":"简介利用优选 IP 加快 Cloudflare 的访问速度，防止因为 IP 被墙导致的无法访问或者访问缓慢。 原理通过修改 Cloudflare 的 A 记录 IP 地址，或者 CNAME 域名地址两种方法，我们可以使套了 CF 的网站的访问速度达到正常的水平。 优选 IP首先我们需要一个优选 IP，本文使用 monitor.gacjie.cn 提供的 API 来获取，也可以通过其他方式获取。 手动更新的情况我们直接访问该网站查看即可。 更新 Cloudflare 域名 DNS上文说到我们可以更新 A 记录，也可以更新 CNAME，此处我们选择更新 A 记录。 进入网站后修改箭头处的数据。CNAME 的修改也是一样的，只不过前面的 A 记录改成 CNAME。修改完成后保存即可。 你可以选择自己想要修改的网址，此处我修改的是 root 记录。 定时自动更新要实现定时自动更新，我们可以借助 Cloudflare 的 API 来修改 A 记录。 基本执行单元 本文使用 python 代码来更新： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import requestsimport json# Cloudflare API 密钥API_KEY = &#x27;本文使用 Global API Key&#x27;# Cloudflare 账户邮箱EMAIL = &#x27;你的 CF 账户邮箱&#x27;# 域名DOMAIN = &#x27;你的域名&#x27;# A 记录名称RECORD_NAME = &#x27;你的 A 记录名称&#x27;# Cloudflare Zone IDZONE_ID = &#x27;你的域名的 ZONE ID&#x27;# Cloudflare API 请求头headers = &#123; &#x27;X-Auth-Email&#x27;: EMAIL, &#x27;X-Auth-Key&#x27;: API_KEY, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;# 发送请求获取 IP 地址response = requests.get(&#x27;https://monitor.gacjie.cn/api/client/get_ip_address&#x27;)if response.status_code == 200: data = response.json() if data[&#x27;status&#x27;]: # 从返回的数据中选择 delay 最小的 IP 地址 min_delay_ip = min(data[&#x27;info&#x27;][&#x27;CM&#x27;] + data[&#x27;info&#x27;][&#x27;CU&#x27;] + data[&#x27;info&#x27;][&#x27;CT&#x27;], key=lambda x: x[&#x27;delay&#x27;]) NEW_IP = min_delay_ip[&#x27;ip&#x27;] print(&#x27;API 请求成功 新 IP:&#x27;, NEW_IP) else: print(&#x27;API 请求失败：&#x27;, data[&#x27;msg&#x27;])else: print(&#x27;获取 IP 地址失败：&#x27;, response.status_code)# 获取 DNS# Cloudflare API 请求头headers_get = &#123; &#x27;X-Auth-Email&#x27;: EMAIL, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;url = &#x27;https://api.cloudflare.com/client/v4/zones/&#123;ZONE_ID&#125;/dns_records&#x27;;url = url.replace(&#x27;&#123;ZONE_ID&#125;&#x27;, ZONE_ID)response = requests.request(&quot;GET&quot;, url, headers=headers)resJson = json.loads(response.text)# print(resJson)if resJson[&#x27;result&#x27;]: data = resJson if data[&#x27;result&#x27;]: # 从返回的数据中选择 域名 for record in data[&#x27;result&#x27;]: if record[&#x27;name&#x27;] == RECORD_NAME and record[&#x27;type&#x27;] == &#x27;A&#x27;: # 找到匹配的记录，打印其 ID DNS_ID=record[&#x27;id&#x27;] print(&quot;A 记录名称为&quot;,RECORD_NAME,&quot;的 ID 为：&quot;, record[&#x27;id&#x27;]) break # print(&#x27;DNS 请求成功 :&#x27;, data[&#x27;result&#x27;]) else: print(&#x27;DNS 请求失败：&#x27;, data[&#x27;msg&#x27;])else: print(&#x27;获取 DNS 失败：&#x27;, response.status_code)# 设置 DNS# 构建 API 请求体data = &#123; &#x27;type&#x27;: &#x27;A&#x27;, &#x27;name&#x27;: RECORD_NAME, &#x27;content&#x27;: NEW_IP, &quot;proxied&quot;: True&#125;url = &#x27;https://api.cloudflare.com/client/v4/zones/&#123;ZONE_ID&#125;/dns_records/&#123;RECORD_ID&#125;&#x27;url = url.replace(&#x27;&#123;ZONE_ID&#125;&#x27;, ZONE_ID)url = url.replace(&#x27;&#123;RECORD_ID&#125;&#x27;, DNS_ID)# 发送 API 请求response = requests.request(&quot;PUT&quot;,url, json=data, headers=headers)# 处理 API 响应if response.status_code == 200: print(&#x27;A 记录 IP 修改成功！&#x27;)else: print(f&#x27;错误：&#123;response.status_code&#125; - &#123;response.text&#125;&#x27;) 其中 API_KEY 可以在如下地址找到： ZONE_ID 可以在如下地址找到： 这样我们就有了一个基本执行单元了。 定时任务 然后我们就需要设置定时任务。我们可以在本地或者 VPS 上执行定时任务，不过本文选择托管到 Github 上，并使用 Action 来定时执行任务。 要启用 Github 的 Action 工作流，我们需要进行如下步骤： 创建仓库，可以选择私有仓库。 克隆项目到本地，在根目录下创建一个 .github 文件夹，然后在 .github 文件夹里面创建一个 workflows 文件夹。 在 workflows 文件夹创建一个 yaml 文件，名字随意。 编写工作流代码： 12345678910111213141516171819202122232425name: Update Scripton: # push schedule: - cron: &quot;*/15 * * * *&quot; # 每 15 分钟执行一次jobs: update: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v4 with: python-version: &quot;3.8&quot; # 指定 Python 版本 - name: Install dependencies run: pip install -r requirements.txt # 如果有依赖，需安装 - name: Execute Python script run: python update.py # 运行你的 Python 脚本 把刚刚的 python 脚本放到根目录下，此处我 python 脚本的名字叫 update。 在根目录新建 requirements.txt 文件，里面写我们需要引用的库，只需要在里面写 requests 就行了。 推送到 Github。 这样每隔 15 分钟就会更新一次 IP 了。如果你需要修改间隔时间，请搜索 crontab 相关内容，Github 的 cron 和 Linux 的 cron 是一致的。 代码基本执行单元1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import requestsimport json# Cloudflare API 密钥API_KEY = &#x27;本文使用 Global API Key&#x27;# Cloudflare 账户邮箱EMAIL = &#x27;你的 CF 账户邮箱&#x27;# 域名DOMAIN = &#x27;你的域名&#x27;# A 记录名称RECORD_NAME = &#x27;你的 A 记录名称&#x27;# Cloudflare Zone IDZONE_ID = &#x27;你的域名的 ZONE ID&#x27;# Cloudflare API 请求头headers = &#123; &#x27;X-Auth-Email&#x27;: EMAIL, &#x27;X-Auth-Key&#x27;: API_KEY, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;# 发送请求获取 IP 地址response = requests.get(&#x27;https://monitor.gacjie.cn/api/client/get_ip_address&#x27;)if response.status_code == 200: data = response.json() if data[&#x27;status&#x27;]: # 从返回的数据中选择 delay 最小的 IP 地址 min_delay_ip = min(data[&#x27;info&#x27;][&#x27;CM&#x27;] + data[&#x27;info&#x27;][&#x27;CU&#x27;] + data[&#x27;info&#x27;][&#x27;CT&#x27;], key=lambda x: x[&#x27;delay&#x27;]) NEW_IP = min_delay_ip[&#x27;ip&#x27;] print(&#x27;API 请求成功 新 IP:&#x27;, NEW_IP) else: print(&#x27;API 请求失败：&#x27;, data[&#x27;msg&#x27;])else: print(&#x27;获取 IP 地址失败：&#x27;, response.status_code)# 获取 DNS# Cloudflare API 请求头headers_get = &#123; &#x27;X-Auth-Email&#x27;: EMAIL, &#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;url = &#x27;https://api.cloudflare.com/client/v4/zones/&#123;ZONE_ID&#125;/dns_records&#x27;;url = url.replace(&#x27;&#123;ZONE_ID&#125;&#x27;, ZONE_ID)response = requests.request(&quot;GET&quot;, url, headers=headers)resJson = json.loads(response.text)# print(resJson)if resJson[&#x27;result&#x27;]: data = resJson if data[&#x27;result&#x27;]: # 从返回的数据中选择 域名 for record in data[&#x27;result&#x27;]: if record[&#x27;name&#x27;] == RECORD_NAME and record[&#x27;type&#x27;] == &#x27;A&#x27;: # 找到匹配的记录，打印其 ID DNS_ID=record[&#x27;id&#x27;] print(&quot;A 记录名称为&quot;,RECORD_NAME,&quot;的 ID 为：&quot;, record[&#x27;id&#x27;]) break # print(&#x27;DNS 请求成功 :&#x27;, data[&#x27;result&#x27;]) else: print(&#x27;DNS 请求失败：&#x27;, data[&#x27;msg&#x27;])else: print(&#x27;获取 DNS 失败：&#x27;, response.status_code)# 设置 DNS# 构建 API 请求体data = &#123; &#x27;type&#x27;: &#x27;A&#x27;, &#x27;name&#x27;: RECORD_NAME, &#x27;content&#x27;: NEW_IP, &quot;proxied&quot;: True&#125;url = &#x27;https://api.cloudflare.com/client/v4/zones/&#123;ZONE_ID&#125;/dns_records/&#123;RECORD_ID&#125;&#x27;url = url.replace(&#x27;&#123;ZONE_ID&#125;&#x27;, ZONE_ID)url = url.replace(&#x27;&#123;RECORD_ID&#125;&#x27;, DNS_ID)# 发送 API 请求response = requests.request(&quot;PUT&quot;,url, json=data, headers=headers)# 处理 API 响应if response.status_code == 200: print(&#x27;A 记录 IP 修改成功！&#x27;)else: print(f&#x27;错误：&#123;response.status_code&#125; - &#123;response.text&#125;&#x27;) Action 工作流脚本12345678910111213141516171819202122232425name: Update Scripton: # push schedule: - cron: &quot;*/15 * * * *&quot; # 每 15 分钟执行一次jobs: update: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v4 with: python-version: &quot;3.8&quot; # 指定 Python 版本 - name: Install dependencies run: pip install -r requirements.txt # 如果有依赖，需安装 - name: Execute Python script run: python update.py # 运行你的 Python 脚本 更新日志2024-03-20 更新基本内容。","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://busyogg.github.io/tags/Cloudflare/"}]},{"title":"Unity-编辑器 UI 开发优化框架 EditorUIExtension IMGUI 篇","slug":"Unity-编辑器UI开发优化框架EditorUIExtension","date":"2024-03-16T19:59:41.000Z","updated":"2024-05-31T08:26:21.870Z","comments":true,"path":"article/497b56da32cd/","link":"","permalink":"https://busyogg.github.io/article/497b56da32cd/","excerpt":"","text":"简介基于 IMGUI 的编辑器 UI 框架，目的是简化编辑器开发时的 UI 构建。利用特性标签进行 UI 的初始化。 对于变量，我们只需要打上对应的标签，就能够在 UI 面板上显示对应的 UI。 对于方法，我们只需要打上 Button 标签，就能够生成一个实现该方法的按钮。 同时，本框架还支持对 UI 的样式和布局进行有限的修改，同样也是通过特性实现。 UI 界面的渲染顺序按照编辑器脚本对象的声明顺序排序，布局的结构也要按照顺序声明，可以看作是以代码的形式绘制 UI。 本框架支持自定义拓展功能，具体的使用说明和拓展规则见： EditorUIExtention 文档 原理初始化特性我们通过基类初始化获取 Type，然后通过 Type 获取 members 并且按照声明顺序排序，之后通过遍历，在其循环体内根据对应的特性类别进行 UI 的渲染函数初始化。 为了防止频繁反射，因此所有的 UI 都在编辑器展示的时候构造，数据的获取和存储都从反射转为委托。又因为 IMGUI 构造 UI 的方法无法在 OnGUI 以外的地方使用，因此我们在初始化时得到的是构造对应 UI 的方法函数。 特性声明我们在定义特性的时候需要传入一个 [CallerLineNumber] int 类型的变量，该变量用于获取调用特性构造函数的行号，其中 [CallerLineNumber] 也是一个特性，用于获取调用方代码的行号。 只有通过这个方法才能自动获取到正确的声明顺序。如果你不想用这个方法，也可以在特性显示声明一个表明顺序的变量，然后手动传参，并且修改编辑器初始化函数中的排序方法。 渲染渲染函数初始化UI 渲染结构 为了支持布局的修改，我们就要规划好整个渲染的结构和顺序。 布局作为最外层的框架，需要把属于该布局的 UI 包裹在其中，并且可能存在布局套布局的情况。因此我们使用树结构来存储布局以及对应的 UI。 我们把 UI 的渲染函数或布局的节点存储在同一个 object 列表中，以便在渲染时按照正确的顺序渲染。 同时，我们设置一个函数委托，用于在渲染布局的时候先把外层的布局 UI 渲染好，然后我们再渲染内部的具体 UI。 UI 渲染具体过程 为了能够在 OnGUI 之外的地方使用 GUI 相关的方法，我们需要把具体的渲染行为封装为函数，之后在 OnGUI 中执行。 本框架把函数渲染分为三个部分： UI 渲染。 Style 渲染。 GUILayout 渲染。 UI 渲染负责生成 UI 对象，Style 渲染负责生成 GUIStyle 对象，而 GUILayout 渲染负责生成 GUILayout 数组。 最后在组合 UI 的时候把 GUIStyle 和 GUILayout 数组传入 UI 渲染函数。 例： 1234Action&lt;GUIStyle, GUILayoutOption[]&gt; label = (GUIStyle style, GUILayoutOption[] options) =&gt;&#123; GUILayout.Label(labelName(), style, options);&#125;; 在上面的函数中，UI 渲染函数就是这个 Action 委托，Style 渲染函数在 OnGUI 执行传入 GUIStyle style ，GUILayout 渲染函数在 OnGUI 执行传入 GUILayoutOption[] options。最后我们执行完 UI 渲染函数就能够得到对应的 UI。 布局渲染函数的初始化需要传入具体的渲染方法，默认有两种，一种 NormalRender；另一种是 FlexRender 。这两种都在 BaseEditor 中定义。一般情况下只需要用到第一种，第二种是流式布局专用的。如果有其他需要也可以自己新增渲染函数。 具体的生成过程请参考项目工程和项目文档。 渲染函数执行渲染函数在 OnGUI 中执行，分为两种情况： 当前对象为布局节点，则执行节点内的 _layout 函数。 当前对象为 UI，则执行 NormalRender。 渲染执行函数123456789101112private void Render(LayoutNode node)&#123; if (node._layout != null) &#123; node._layout(); &#125; else &#123; NormalRender(node)(); &#125;&#125; 以 NormalRender 来说，遍历对象 List，如果是布局节点，则递归调用 Render 方法渲染；如果是 UI，则执行对应的渲染委托函数。 普通渲染函数123456789101112131415161718192021222324/// &lt;summary&gt;/// 普通渲染/// &lt;/summary&gt;/// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Action NormalRender(LayoutNode node)&#123; Action action = () =&gt; &#123; foreach (var ui in node._list) &#123; if (ui is LayoutNode) &#123; Render((LayoutNode)ui); &#125; else &#123; UIListData data = (UIListData)ui; data.action(data.style(), data.options()); &#125; &#125; &#125;; return action;&#125; 项目由于本项目代码较多，因此请移步 GitHub 查看详细代码。 更新日志2024-05-30 修改部分说明。 2024-03-18 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"框架","slug":"框架","permalink":"https://busyogg.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"IMGUI","slug":"IMGUI","permalink":"https://busyogg.github.io/tags/IMGUI/"}]},{"title":"Unity-Inspector 序列化字典","slug":"Unity-Inspector序列化字典","date":"2024-03-10T15:56:13.000Z","updated":"2024-05-30T12:19:36.207Z","comments":true,"path":"article/e8fee5b5f443/","link":"","permalink":"https://busyogg.github.io/article/e8fee5b5f443/","excerpt":"","text":"简介众所周知，Unity 无法在 Inspector 面板上序列化显示字典的内容，因此我们需要用别的方法曲线救国。 Unity 是可以序列化显示 List 的，因此我们的目标就是用 List 的方式来序列化字典。 原理使用 List 模拟字典的键值对，内部使用一个字典存储键的索引，在运行时更改字典可将修改反映到 List（Inspector）上，并使用 ReorderableList 和 PropertyDrawer 自定义绘制方法。（参考文献原文） 序列化字典简单来说就是把字典分为两个部分： 新的序列化字典类内部的 List。 一个是 List 内模拟键值对的类。 然后 List 的类型设为模拟键值对的类。这样我们就得到了一个基本容器。 为了方便拓展，我把原文模拟键值对的类提取出来： SKeyValue1234567891011121314using System;[Serializable]public struct SKeyValue&lt;TKey,TValue&gt;&#123; public TKey Key; public TValue Value; public SKeyValue(TKey key, TValue value) &#123; Key = key; Value = value; &#125;&#125; 该类标记为可序列化，里面的内容就可以在 Inspector 面板上显示。 然后我们在序列化字典类中定义 List： 1[SerializeField] private List&lt;SKeyValue&lt;TKey,TValue&gt;&gt; list = new List&lt;SKeyValue&lt;TKey, TValue&gt;&gt;(); 然后我们需要额外定义一个字典来存储 Key 在 List 中的索引。 1234//属性private Dictionary&lt;TKey, int&gt; KeyPositions =&gt; _keyPositions.Value;//懒字典private Lazy&lt;Dictionary&lt;TKey, int&gt;&gt; _keyPositions; 这样我们对于字典的操作就可以分为两个步骤： 获取 Key 在 List 中的索引。 获取对应索引的 Value。 其他操作就和普通的字典一样了。 面板绘制如果使用默认的绘制，Value 值如果是嵌套的列表或字典，就会额外多出一个 List 标识。 原文例图 要去掉 List，我们就需要自己重新绘制面板。 利用 EditorGUI.PropertyField 方法，我们可以绘制出对应类型的面板。 我们还要重写 GetPropertyHeight 方法，使其能够递归的获取属性的高度。 123public override float GetPropertyHeight(SerializedProperty property, GUIContent label) &#123; return EditorGUI.GetPropertyHeight(getListProperty(property), true); &#125; 最后的效果就是这样： 原文例图 番外Unity 的 List 在嵌套的情况下也无法在面板上进行序列化，因此我们可以仿照序列化字典的做法定义序列化 List。 定义值类： 123456789101112using System;[Serializable]public struct SValue&lt;TValue&gt;&#123; public TValue Value; public SValue(TValue value) &#123; Value = value; &#125;&#125; 序列化 List 不需要存储 Key 索引，因此我们只需要 [SerializeField] private List&lt;SValue&lt;TValue&gt;&gt; list = new List&lt;SValue&lt;TValue&gt;&gt;(); 注意 如果你不需要对面板进行额外拓展的话，可以直接使用原文的代码。 需要序列化复杂的数据不要用 Unity 原生的 Dictionary 和 List 作为类型传递。 代码标记为 Editor 的需要放在 Editor 文件夹下。 序列化字典序列化 ListSKeyValue1234567891011121314using System;[Serializable]public struct SKeyValue&lt;TKey,TValue&gt;&#123; public TKey Key; public TValue Value; public SKeyValue(TKey key, TValue value) &#123; Key = key; Value = value; &#125;&#125; SDictionary123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160using System;using System.Collections;using System.Collections.Generic;using System.Linq;using UnityEngine;public class SDictionary &#123; &#125;[Serializable]public class SDictionary&lt;TKey, TValue&gt; : SDictionary, ISerializationCallbackReceiver, IDictionary&lt;TKey, TValue&gt;&#123; [SerializeField] private List&lt;SKeyValue&lt;TKey,TValue&gt;&gt; list = new List&lt;SKeyValue&lt;TKey, TValue&gt;&gt;(); private Dictionary&lt;TKey, int&gt; KeyPositions =&gt; _keyPositions.Value; private Lazy&lt;Dictionary&lt;TKey, int&gt;&gt; _keyPositions; public SDictionary() &#123; _keyPositions = new Lazy&lt;Dictionary&lt;TKey, int&gt;&gt;(MakeKeyPositions); &#125; private Dictionary&lt;TKey, int&gt; MakeKeyPositions() &#123; var dictionary = new Dictionary&lt;TKey, int&gt;(list.Count); for (var i = 0; i &lt; list.Count; i++) &#123; dictionary[list[i].Key] = i; &#125; return dictionary; &#125; public void OnBeforeSerialize() &#123; &#125; public void OnAfterDeserialize() &#123; _keyPositions = new Lazy&lt;Dictionary&lt;TKey, int&gt;&gt;(MakeKeyPositions); &#125; #region IDictionary&lt;TKey, TValue&gt; public TValue this[TKey key] &#123; get =&gt; list[KeyPositions[key]].Value; set &#123; var pair = new SKeyValue&lt;TKey,TValue&gt;(key, value); if (KeyPositions.ContainsKey(key)) &#123; list[KeyPositions[key]] = pair; &#125; else &#123; KeyPositions[key] = list.Count; list.Add(pair); &#125; &#125; &#125; public ICollection&lt;TKey&gt; Keys =&gt; list.Select(tuple =&gt; tuple.Key).ToArray(); public ICollection&lt;TValue&gt; Values =&gt; list.Select(tuple =&gt; tuple.Value).ToArray(); public void Add(TKey key, TValue value) &#123; if (KeyPositions.ContainsKey(key)) throw new ArgumentException(&quot;An element with the same key already exists in the dictionary.&quot;); else &#123; KeyPositions[key] = list.Count; list.Add(new SKeyValue&lt;TKey, TValue&gt;(key, value)); &#125; &#125; public bool ContainsKey(TKey key) =&gt; KeyPositions.ContainsKey(key); public bool Remove(TKey key) &#123; if (KeyPositions.TryGetValue(key, out var index)) &#123; KeyPositions.Remove(key); list.RemoveAt(index); for (var i = index; i &lt; list.Count; i++) KeyPositions[list[i].Key] = i; return true; &#125; else return false; &#125; public bool TryGetValue(TKey key, out TValue value) &#123; if (KeyPositions.TryGetValue(key, out var index)) &#123; value = list[index].Value; return true; &#125; else &#123; value = default; return false; &#125; &#125; #endregion #region ICollection &lt;KeyValuePair&lt;TKey, TValue&gt;&gt; public int Count =&gt; list.Count; public bool IsReadOnly =&gt; false; public void Add(KeyValuePair&lt;TKey, TValue&gt; kvp) =&gt; Add(kvp.Key, kvp.Value); public void Clear() =&gt; list.Clear(); public bool Contains(KeyValuePair&lt;TKey, TValue&gt; kvp) =&gt; KeyPositions.ContainsKey(kvp.Key); public void CopyTo(KeyValuePair&lt;TKey, TValue&gt;[] array, int arrayIndex) &#123; var numKeys = list.Count; if (array.Length - arrayIndex &lt; numKeys) throw new ArgumentException(&quot;arrayIndex&quot;); for (var i = 0; i &lt; numKeys; i++, arrayIndex++) &#123; var entry = list[i]; array[arrayIndex] = new KeyValuePair&lt;TKey, TValue&gt;(entry.Key, entry.Value); &#125; &#125; public bool Remove(KeyValuePair&lt;TKey, TValue&gt; kvp) =&gt; Remove(kvp.Key); public Dictionary&lt;TKey, TValue&gt; ToDictionary() &#123; Dictionary&lt;TKey, TValue&gt; dic = new Dictionary&lt;TKey, TValue&gt;(); foreach(var kvp in list) &#123; dic.Add(kvp.Key, kvp.Value); &#125; return dic; &#125; #endregion #region IEnumerable &lt;KeyValuePair&lt;TKey, TValue&gt;&gt; public IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator() &#123; return list.Select(ToKeyValuePair).GetEnumerator(); static KeyValuePair&lt;TKey, TValue&gt; ToKeyValuePair(SKeyValue&lt;TKey, TValue&gt; skvp) &#123; return new KeyValuePair&lt;TKey, TValue&gt;(skvp.Key, skvp.Value); &#125; &#125; IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator(); #endregion&#125; Editor SDictionaryDrawer123456789101112131415161718192021using UnityEngine;using UnityEditor;[CustomPropertyDrawer(typeof(SDictionary&lt;,&gt;))]public class SDictionaryDrawer : PropertyDrawer&#123; private SerializedProperty listProperty; private SerializedProperty getListProperty(SerializedProperty property) =&gt; listProperty ??= property.FindPropertyRelative(&quot;list&quot;); public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) &#123; EditorGUI.PropertyField(position, getListProperty(property), label, true); &#125; public override float GetPropertyHeight(SerializedProperty property, GUIContent label) &#123; return EditorGUI.GetPropertyHeight(getListProperty(property), true); &#125;&#125;SValue12345678910111213using System;[Serializable]public struct SValue&lt;TValue&gt;&#123; public TValue Value; public SValue(TValue value) &#123; Value = value; &#125;&#125; SList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using UnityEngine;[Serializable]public class SList&lt;TValue&gt; : ISerializationCallbackReceiver, IList&lt;TValue&gt;&#123; [SerializeField] private List&lt;SValue&lt;TValue&gt;&gt; list = new List&lt;SValue&lt;TValue&gt;&gt;(); public SList() &#123; &#125; public void OnBeforeSerialize() &#123; &#125; public void OnAfterDeserialize() &#123; &#125; public int Count =&gt; list.Count; public bool IsReadOnly =&gt; false; public TValue this[int index] &#123; get =&gt; list[index].Value; set &#123; if (index &lt; list.Count) &#123; SValue&lt;TValue&gt; v = list[index]; v.Value = value; list[index] = v; &#125; else &#123; list.Add(new SValue&lt;TValue&gt;(value)); &#125; &#125; &#125; #region IEnumerable &lt;KeyValuePair&lt;TKey, TValue&gt;&gt; public IEnumerator&lt;TValue&gt; GetEnumerator() &#123; return list.Select(ToKeyValuePair).GetEnumerator(); static TValue ToKeyValuePair(SValue&lt;TValue&gt; sb) &#123; return sb.Value; &#125; &#125; IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator(); #endregion public int IndexOf(TValue item) &#123; for (int i = 0; i &lt; list.Count; i++) &#123; if (list[i].Value.Equals(item)) &#123; return i; &#125; &#125; return -1; &#125; public void Insert(int index, TValue item) &#123; list.Insert(index, new SValue&lt;TValue&gt;(item)); &#125; public void RemoveAt(int index) &#123; list.RemoveAt(index); &#125; public void Add(TValue item) &#123; list.Add(new SValue&lt;TValue&gt;(item)); &#125; public void Clear() &#123; list.Clear(); &#125; public bool Contains(TValue item) &#123; int res = IndexOf(item); return res != -1; &#125; public void CopyTo(TValue[] array, int arrayIndex) &#123; var numKeys = list.Count; if (array.Length - arrayIndex &lt; numKeys) throw new ArgumentException(&quot;arrayIndex&quot;); for (var i = 0; i &lt; numKeys; i++, arrayIndex++) &#123; var entry = list[i]; array[arrayIndex] = entry.value; &#125; &#125; public bool Remove(TValue item) &#123; int res = IndexOf(item); if (res != -1) &#123; list.RemoveAt(res); return true; &#125; return false; &#125; public List&lt;TValue&gt; ToList() &#123; List&lt;TValue&gt; l = new List&lt;TValue&gt;(); foreach (var item in list) &#123; l.Add(item.Value); &#125; return l; &#125;&#125; Editor SListDrawer123456789101112131415161718192021using UnityEngine;using UnityEditor;[CustomPropertyDrawer(typeof(SList&lt;&gt;))]public class SListDrawer : PropertyDrawer&#123; private SerializedProperty listProperty; private SerializedProperty getListProperty(SerializedProperty property) =&gt; listProperty ??= property.FindPropertyRelative(&quot;list&quot;); public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) &#123; EditorGUI.PropertyField(position, getListProperty(property), label, true); &#125; public override float GetPropertyHeight(SerializedProperty property, GUIContent label) &#123; return EditorGUI.GetPropertyHeight(getListProperty(property), true); &#125;&#125; 项目工程 更新日志 2024-03-22 修复 SList 方法 CopyTo 错误。 2024-03-11 新增基本内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Untiy","slug":"Untiy","permalink":"https://busyogg.github.io/tags/Untiy/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"序列化","slug":"序列化","permalink":"https://busyogg.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"字典","slug":"字典","permalink":"https://busyogg.github.io/tags/%E5%AD%97%E5%85%B8/"}]},{"title":"Unity-ECS 框架","slug":"Unity-ECS框架","date":"2024-03-07T16:03:54.000Z","updated":"2024-05-30T12:29:01.952Z","comments":true,"path":"article/2f23b744011e/","link":"","permalink":"https://busyogg.github.io/article/2f23b744011e/","excerpt":"","text":"简介ECS 架构是 实体（Entity）- 组件（Component）- 系统（System）组成的架构，主要目的是对数据和逻辑进行解耦以便更好的维护系统。其运行的原理也能提高 CPU 的缓存命中，即可以提高游戏运行的性能。 原理ECS 架构简单来说就是用实体来组合组件，用组件来保存数据，用系统来进行运算。单一的实体没有任何意义，只有在组合组件之后这个实体才有意义。组件只能用于保存数据，不能自己进行任何的运算。系统只负责运算，不会持久化保存任何数据。这样就把数据和逻辑分离开来，通过组合的方式实现特定的功能，实现数据和逻辑的解耦，以及逻辑与逻辑之间的解耦。 大致示意图如下： 组件组件是 ECS 架构的基础，实体需要组件，系统也根据组件处理逻辑。组件的设计很简单，我们只需要以下基础属性和方法： 组件 id，每个组件都拥有一个属于自己的 id，这个 id 是全局唯一的。 组件名，每个组件都拥有一个属于自己的名字，这个名字是全局唯一的。 是否可以被回收，有些组件在实体移除后需要回收，有些则不从实体回收。 重置方法，用于回收组件之后进行组件的重置。 因此我们可以定义一个组件抽象类 Comp，Comp 类不关心组件的具体信息，只关心组件的基本属性、组件的初始化和重置方法。 Comp12345678910public abstract class Comp&#123; public int compId &#123; get; set; &#125; public string compName &#123; get; set; &#125; public Comp() &#123; Reset(); &#125; public abstract void Reset();&#125; 然后我们就可以定义实际的 Comp 类来保存我们需要的数据。 实体实体是组件的合集，虽然实体的概念很简单，但是实体的实现却比较复杂。实体需要实现组件的添加和移除，也要在添加移除组件的时候通知对应系统进行处理，同时实体也要提供组件的查询功能。当然，实体自身也要提供移除的方法。 掩码工具由于实体需要查询组件，系统也需要查询组件，因此我们需要先设计对应的功能。此处我们选择用二进制数来制作掩码系统保存组件信息。 这里我们使用一个二进制数组来保存，用数组的目的是如果组件数超过二进制数大小，就在数组增加一个二进制数来保存。在 32 位二进制数中，由于与（&amp;）操作符最大只能操作 30 位数（一位符号位，一位进位），因此一个数只保存 30 个组件。 由于组件的数量在游戏的最开始就初始化完成，因此 Mask 实例的组件总数是固定的。 当我们进行掩码运算时，传入的组件 id 转为二进制数和当前的掩码进行比较，例如我们设置组件时，假设当前掩码为 0000 0000 0000 0000 ，传入的组件 id 为 3，则我们把组件 id 化为 1 &lt;&lt; (3 % 31)，即 1 左移 3 位，得到 1000 ，0000 0000 0000 0000 &amp; 1000 = 0000 0000 0000 1000，最终的组件就保存下来了。 也就是说 32 位掩码就是插槽，组件的 id 就是往哪个插槽插入组件，这样就能表示保存的组件了。 ECSMask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using System.Collections.Generic;using UnityEngine;public class ECSMask&#123; private List&lt;int&gt; _mask; private int _size; public ECSMask() &#123; _size = Mathf.CeilToInt(ECSManager.Ins().GetTotalCompNum() / 31f); _mask = new List&lt;int&gt;(_size); int data = 0; _mask.Add(data); &#125; public void Set(int id) &#123; _mask[id / 31] |= (1 &lt;&lt; (id % 31)); &#125; public void Remove(int id) &#123; _mask[id / 31] &amp;= ~(1 &lt;&lt; (id % 31)); &#125; public bool Has(int id) &#123; return (_mask[id / 31] &amp; (1 &lt;&lt; (id % 31))) &gt; 0; &#125; //和其他mask比较 public bool Or(ECSMask other) &#123; for (int i = 0; i &lt; _size; ++i) &#123; if ((_mask[i] &amp; other._mask[i]) &gt; 0) &#123; return true; &#125; &#125; return false; &#125; public bool And(ECSMask other) &#123; for (int i = 0; i &lt; _size; ++i) &#123; if ((_mask[i] &amp; other._mask[i]) != _mask[i]) &#123; return false; &#125; &#125; return true; &#125; public void Clear() &#123; for(int i = 0; i &lt; _size; ++i) &#123; _mask[i] = 0; &#125; &#125;&#125; 筛选工具因为系统以实体进行遍历的，所以有了掩码之后，我们就可以对实体进行筛选了，通过比较实体的组件掩码和筛选工具的组件掩码，我们就可以筛选出系统需要的实体。 首先我们定义一个匹配规则类，匹配规则类的构造函数根据传入的规则和组件设置掩码，并且按顺序保存组件 id。 判断是否匹配只需要调用掩码定义的规则即可。 ECSRule12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;using System.Collections.Generic;/// &lt;summary&gt;/// ECS规则匹配类型/// &lt;/summary&gt;public enum ECSRuleType&#123; AllOf, AnyOf, ExcludeOf&#125;public class ECSRule&#123; int compId = -1; private ECSMask _mask = new ECSMask(); private ECSRuleType _type; private List&lt;int&gt; _compIds = new List&lt;int&gt;(); public ECSRule(ECSRuleType ecsType, params Type[] comps) &#123; _type = ecsType; foreach (var comp in comps) &#123; compId = ECSManager.Ins().GetCompId(comp); if (compId == -1) &#123; ConsoleUtils.Warn(&quot;存在未注册组件&quot;, compId); &#125; else &#123; _mask.Set(compId); _compIds.Add(compId); &#125; &#125; if(_compIds.Count &gt; 0) &#123; _compIds.Sort((a,b) =&gt; &#123; return a.CompareTo(b); &#125;); &#125; &#125; public List&lt;int&gt; GetCompIds() &#123; return _compIds; &#125; /// &lt;summary&gt; /// 是否匹配 /// &lt;/summary&gt; /// &lt;param name=&quot;entity&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool isMatch(Entity entity) &#123; switch (_type) &#123; case ECSRuleType.AllOf: return _mask.And(entity.mask); case ECSRuleType.AnyOf: return _mask.Or(entity.mask); case ECSRuleType.ExcludeOf: return !_mask.Or(entity.mask); &#125; return false; &#125;&#125; 然后我们定义匹配器，匹配器可以包含复数规则，即匹配器是规则的集合，是所有匹配的实际执行类。匹配器也需要一个全局唯一的 id，给后面的 Group 使用。 ECSMatcher1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System;using System.Collections.Generic;using System.Linq;public class ECSMatcher&#123; public static int _matcherId = 0; public int _mid = _matcherId++; private List&lt;ECSRule&gt; _rules = new List&lt;ECSRule&gt;(); public ECSMatcher AnyOf(params Type[] comps) &#123; _rules.Add(new ECSRule(ECSRuleType.AnyOf, comps)); return this; &#125; public ECSMatcher AllOf(params Type[] comps) &#123; _rules.Add(new ECSRule(ECSRuleType.AllOf, comps)); return this; &#125; public ECSMatcher ExcludeOf(params Type[] comps) &#123; _rules.Add(new ECSRule(ECSRuleType.ExcludeOf, comps)); return this; &#125; public ECSMatcher OnlyOf(params Type[] comps) &#123; _rules.Add(new ECSRule(ECSRuleType.AllOf, comps)); List&lt;Type&gt; compList = new List&lt;Type&gt;(); foreach (var comp in comps) &#123; if (!comps.Contains(comp)) &#123; compList.Add(comp); &#125; &#125; Type[] compArray = compList.ToArray(); _rules.Add(new ECSRule(ECSRuleType.ExcludeOf,compArray)); return this; &#125; public bool IsMatch(Entity entity) &#123; foreach (var rule in _rules) &#123; if (!rule.isMatch(entity)) &#123; return false; &#125; &#125; return true; &#125; public List&lt;int&gt; GetCompIds() &#123; List&lt;int&gt; result = null; foreach (var rule in _rules) &#123; List&lt;int&gt; ids = rule.GetCompIds(); if(result == null) &#123; result = ids; &#125; else &#123; result.AddRange(ids); &#125; &#125; return result; &#125;&#125; 大致的关系如下图所示 实体类现在我们可以实现实体类了。 大概的思路如图所示（本图为 TS 版本，Unity 版本没有重新添加组件，也没有设置组件实例为 null） 首先是组件的增加。 我们设置一个字典 _compsInEntity 来保存当前实体的组件，设置一个字典 _compsRemoved 用来保存已经移除但没有回收的组件。 首先我们判断组件是否已注册，已注册并且已存在的情况下返回当前组件，否则就创建新组件，然后把组件添加到实体掩码，并且添加到已保存的组件字典中。 添加完成之后，我们还需要广播增删事件给系统。 然后是组件的移除。 组件的移除和添加类似。 首先判断组件是否存在，是的话标记存在，取出当前组件的实例，然后判断是否需要回收，需要回收的话执行组件初始化操作并回收，不需要的话就把组件放到移除列表中。 最后我们执行掩码的移除和组件存在列表的移除，并且广播通知系统执行对应操作。 接着是组件的查找。 组件的查找很简单，可以用掩码也可以用字典，根据自己的需要即可。组件的获取同理，可以用字典也可以用属性，自己决定即可。 最后是实体的移除。 实体移除的时候要移除所有组件，包括存在的和移除的列表。然后实体可以放入对象池。 Entity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236using System;using System.Collections;using System.Collections.Generic;using System.Linq;using UnityEngine;using static Unity.Burst.Intrinsics.X86.Avx;public class Entity&#123; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; public ECSMask mask &#123; get; set; &#125; private Dictionary&lt;Type, Comp&gt; _compsInEntity = new Dictionary&lt;Type, Comp&gt;(); private Dictionary&lt;Type, Comp&gt; _compsRemoved = new Dictionary&lt;Type, Comp&gt;(); public Entity() &#123; mask = new ECSMask(); &#125; /// &lt;summary&gt; /// 添加组件 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Add&lt;T&gt;() where T : Comp &#123; //Comp comp; Type comp = typeof(T); Comp instance; int compId = ECSManager.Ins().GetCompId(comp); if (mask.Has(compId)) &#123; instance = _compsInEntity[comp]; return instance as T; &#125; if (_compsRemoved.ContainsKey(comp)) &#123; instance = _compsRemoved[comp]; _compsRemoved.Remove(comp); &#125; else &#123; instance = ECSManager.Ins().CreateComp(comp); &#125; if (instance == null) &#123; ConsoleUtils.Warn(&quot;组件未注册&quot;); &#125; else &#123; _compsInEntity.Add(comp, instance); mask.Set(compId); ECSManager.Ins().CompChangeBroadcast(this, compId); &#125; return instance as T; &#125; /// &lt;summary&gt; /// 添加组件 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public void Add(Type comp) &#123; //Comp comp; Comp instance; int compId = ECSManager.Ins().GetCompId(comp); if (mask.Has(compId)) &#123; return; &#125; if (_compsRemoved.ContainsKey(comp)) &#123; instance = _compsRemoved[comp]; _compsRemoved.Remove(comp); &#125; else &#123; instance = ECSManager.Ins().CreateComp(comp); &#125; if (instance == null) &#123; ConsoleUtils.Warn(&quot;组件未注册&quot;); &#125; else &#123; _compsInEntity.Add(comp, instance); mask.Set(compId); ECSManager.Ins().CompChangeBroadcast(this, compId); &#125; &#125; /// &lt;summary&gt; /// 添加组件 /// &lt;/summary&gt; /// &lt;param name=&quot;compIds&quot;&gt;&lt;/param&gt; public void AddComps(params Type[] comps) &#123; foreach (Type comp in comps) &#123; Add(comp); &#125; &#125; /// &lt;summary&gt; /// 获取组件 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;compId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T Get&lt;T&gt;() where T : Comp &#123; Comp instance; _compsInEntity.TryGetValue(typeof(T), out instance); return instance as T; &#125; /// &lt;summary&gt; /// 是否有组件 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool Has&lt;T&gt;() &#123; Type comp = typeof(T); int compId = ECSManager.Ins().GetCompId(comp); return mask.Has(compId); &#125; /// &lt;summary&gt; /// 移除组件 /// &lt;/summary&gt; /// &lt;param name=&quot;compId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;recycle&quot;&gt;&lt;/param&gt; public void Remove&lt;T&gt;(bool recycle = true) &#123; Type comp = typeof(T); int compId = ECSManager.Ins().GetCompId(comp); if (mask.Has(compId)) &#123; Comp instance = _compsInEntity[comp]; if (recycle) &#123; ECSManager.Ins().RemoveComp(instance); &#125; else &#123; _compsRemoved.Add(comp, instance); &#125; _compsInEntity.Remove(comp); mask.Remove(compId); ECSManager.Ins().CompChangeBroadcast(this, compId); &#125; else &#123; ConsoleUtils.Warn(&quot;组件不存在&quot;); &#125; &#125; /// &lt;summary&gt; /// 移除组件 /// &lt;/summary&gt; /// &lt;param name=&quot;compId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;recycle&quot;&gt;&lt;/param&gt; public void Remove(Type comp, bool recycle = true) &#123; int compId = ECSManager.Ins().GetCompId(comp); if (mask.Has(compId)) &#123; Comp instance = _compsInEntity[comp]; if (recycle) &#123; ECSManager.Ins().RemoveComp(instance); &#125; else &#123; _compsRemoved.Add(comp, instance); &#125; _compsInEntity.Remove(comp); mask.Remove(compId); ECSManager.Ins().CompChangeBroadcast(this, compId); &#125; else &#123; ConsoleUtils.Warn(&quot;组件不存在&quot;); &#125; &#125; public void RemoveComps(bool recycle, params Type[] comps) &#123; foreach (Type comp in comps) &#123; Remove(comp, recycle); &#125; &#125; public void Clear() &#123; foreach(var data in _compsInEntity.ToList()) &#123; Remove(data.Key); &#125; foreach(var data in _compsRemoved.ToList()) &#123; ECSManager.Ins().RemoveComp(data.Value); &#125; _compsInEntity.Clear(); _compsRemoved.Clear(); mask.Clear(); &#125;&#125; 系统系统根据所需要的组件来筛选实体，有时候不同系统需要的组件相同，因此我们使用组 Group 来管理系统。 系统的结构如下图所示 群组群组包含一个匹配器，如前文所说，匹配器的 id 也是群组的 id。群组只关心组件匹配的实体，操作的对象也都是实体。 我们保存一个字典 _entities 用于在系统运行时遍历当前组内的所有实体。 我们定义两个委托，用于监听实体变化，一个是实体进入该组，一个是实体移出该组： 123public delegate void EnterListener(Entity entity);public delegate void RemoveListener(Entity entity); 然后我们通过如下方法添加和移除委托： 1234567891011public void AddEntityListener(EnterListener enter, RemoveListener remove)&#123; _enterListener += enter; _removeListener += remove;&#125;public void RemoveEntityListener(EnterListener enter, RemoveListener remove)&#123; _enterListener -= enter; _removeListener -= remove;&#125; 整个组的类如下： Group12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public delegate void EnterListener(Entity entity);public delegate void RemoveListener(Entity entity);public class Group&#123; private ECSMatcher _matcher; private EnterListener _enterListener; private RemoveListener _removeListener; private List&lt;Entity&gt; _entities = new List&lt;Entity&gt;(); public Group(ECSMatcher matcher) &#123; _matcher = matcher; &#125; public void OnCompChange(Entity entity) &#123; if(_matcher.IsMatch(entity)) &#123; _enterListener.Invoke(entity); _entities.Add(entity); &#125; else &#123; _removeListener.Invoke(entity); _entities.Remove(entity); &#125; &#125; public void AddEntityListener(EnterListener enter, RemoveListener remove) &#123; _enterListener += enter; _removeListener += remove; &#125; public void RemoveEntityListener(EnterListener enter, RemoveListener remove) &#123; _enterListener -= enter; _removeListener -= remove; &#125; public List&lt;Entity&gt; GetEntities() &#123; return _entities; &#125; public void Clear() &#123; _entities.Clear(); &#125;&#125; 系统实现系统实现分为两个部分，一个部分是系统的具体实现，还有一个部分是世界。 系统的具体实现核心目标是实现实体进入时的逻辑处理，每帧逻辑处理和实体移除时的逻辑处理。 首先我们定义两个数组 _enters 和 _removes 用于保存进入和移出当前系统的实体。 然后我们通过如下方法注册和反注册实体进入和移出数组的监听： 12345678910111213141516171819202122232425public ECSSystem()&#123; _group = ECSManager.Ins().CreateGroup(Filter()); _group.AddEntityListener(EntityEnter, EntityRemove);&#125;private void EntityRemove(Entity entity)&#123; List&lt;Entity&gt; entities = _group.GetEntities(); if (entities.Contains(entity)) &#123; _removes.Add(entity); &#125;&#125;private void EntityEnter(Entity entity)&#123; _enters.Add(entity);&#125;public virtual void OnDestroy()&#123; _group.RemoveEntityListener(EntityEnter, EntityRemove);&#125; 通过在构造函数中注册监听，每当组内实体发生变化的时候，组内注册的所有系统的实体进入和移出数组的方法， EntityEnter 和 EntityRemove，都会执行，也就是把实体添加或移除到当前系统中。 然后就是系统的遍历处理了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections.Generic;public abstract class ECSSystem&#123; private Group _group; protected float _dt = 0; private List&lt;Entity&gt; _enters = new List&lt;Entity&gt;(); private List&lt;Entity&gt; _removes = new List&lt;Entity&gt;(); public ECSSystem() &#123; _group = ECSManager.Ins().CreateGroup(Filter()); _group.AddEntityListener(EntityEnter, EntityRemove); &#125; public void Execute(float dt) &#123; _dt = dt; List&lt;Entity&gt; entities = _group.GetEntities(); OnEnter(_enters); OnUpdate(entities); OnRemove(_removes); _removes.Clear(); _enters.Clear(); &#125; public void DrawGizmos() &#123; List&lt;Entity&gt; entities = _group.GetEntities(); OnDrawGizmos(entities); &#125; private void EntityEnter(Entity entity) &#123; _enters.Add(entity); &#125; private void EntityRemove(Entity entity) &#123; List&lt;Entity&gt; entities = _group.GetEntities(); if (entities.Contains(entity)) &#123; _removes.Add(entity); &#125; &#125; public virtual void Init() &#123; &#125; public virtual void OnDestroy() &#123; _group.RemoveEntityListener(EntityEnter, EntityRemove); &#125; public virtual void OnEnter(List&lt;Entity&gt; entities) &#123; &#125; public virtual void OnRemove(List&lt;Entity&gt; entities) &#123; &#125; public virtual void OnDrawGizmos(List&lt;Entity&gt; entities) &#123; &#125; public abstract ECSMatcher Filter(); public abstract void OnUpdate(List&lt;Entity&gt; entities);&#125; 在核心处理函数 Execute 中我们按照顺序处理 OnEnter、OnUpdate 和 OnRemove ，然后我们把 _enters 和 _removes 清空，防止多次执行。 所有的系统实现，最后我们都要用世界来使用。 世界生命周期提供一个 Init 方法，来遍历所有系统并且调用对应系统的初始化；提供一个 Update 方法来遍历所有系统，执行每帧更新的内容；提供一个 Clear 方法来遍历所有系统，调用系统销毁时的 OnDestroy 方法。 然后就是 Add 方法，传入系统时直接加入 _systems 。添加新系统我们需要重写 SystemAdd 方法，所有的添加行为都在这个方法里执行。 所有的方法在我们自定义世界的时候都不需要修改，只需要在 SystemAdd 中 Add 新的系统即可。 ECSWorld123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System.Collections.Generic;using UnityEngine;public abstract class ECSWorld&#123; private List&lt;ECSSystem&gt; _systems = new List&lt;ECSSystem&gt;(); private float _time = 0; public ECSWorld() &#123; SystemAdd(); Init(); &#125; public void Init() &#123; _time = Time.time; foreach (var system in _systems) &#123; system.Init(); &#125; &#125; public abstract void SystemAdd(); public void Update() &#123; float dt = Time.time - _time; foreach (var system in _systems) &#123; system.Execute(dt); &#125; _time += dt; //ConsoleUtils.Log(&quot;间隔时间&quot;,dt); &#125; public void DrawGrizmos() &#123; foreach (var system in _systems) &#123; system.DrawGizmos(); &#125; &#125; public void Add(ECSSystem system) &#123; _systems.Add(system); &#125; public void Remove(ECSSystem system) &#123; _systems.Remove(system); &#125; public void Clear() &#123; _systems.Clear(); &#125;&#125; 管理器ECS 的基本框架搭建好后，我们还需要一个管理器来管理 ECS 框架的一些操作。下面是本项目的分类，也可以根据需求自己设计。 ECS 管理器的核心功能简单概括如下图所示（Unity 版本取消标签，取消判断实例化并直接走是分支） 组件注册我们在使用组件之前，都要对组件进行注册。 我们通过特性 Attribute 来实现组件类的预注册。 CompRegister123456789101112131415161718using System;[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct)]public class CompRegister : Attribute&#123; public CompRegister(Type type) &#123; Register(type); &#125; public void Register(Type type) &#123; int id = ECSManager.Ins().GetCompId(); ECSManager.Ins().CompRegister(type, id); &#125;&#125; 启动Attribute1234567891011121314public void Init()&#123; Assembly assembly = Assembly.GetAssembly(typeof(ECSManager)); Type[] types = assembly.GetTypes(); foreach (Type type in types) &#123; //获取自定义特性的过程中自动执行构造函数 var attr = type.GetCustomAttribute&lt;CompRegister&gt;(); if (attr != null) &#123; _total++; &#125; &#125;&#125; 组件功能组件的功能很简单，只是运用了对象池的概念。我们定义一个实体池_comps用于保存当前所有的组件 id，定义一个组件实例缓存池_compPool用来当组件的对象池。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/// &lt;summary&gt;/// 注册组件/// &lt;/summary&gt;/// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;compId&quot;&gt;&lt;/param&gt;public void CompRegister(Type comp, int compId)&#123; _comps.Add(comp, compId); _compPool.Add(compId, new Stack&lt;Comp&gt;()); ConsoleUtils.Log(&quot;注册类:&quot;, compId, comp);&#125;/// &lt;summary&gt;/// 创建组件/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;/// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public Comp CreateComp(Type comp)&#123; if (!_comps.ContainsKey(comp)) &#123; ConsoleUtils.Warn(&quot;未找到对应组件:&quot;, comp); return null; &#125; else &#123; int compId = _comps[comp]; Comp instance; Stack&lt;Comp&gt; queue; _compPool.TryGetValue(compId, out queue); if (queue == null || queue.Count == 0) &#123; instance = ClassFactory.CreateClass&lt;Comp&gt;(comp); instance.compId = compId; &#125; else &#123; instance = queue.Pop(); &#125; return instance; &#125;&#125;/// &lt;summary&gt;/// 回收组件/// &lt;/summary&gt;/// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt;public void RemoveComp(Comp comp)&#123; Stack&lt;Comp&gt; queue; _compPool.TryGetValue(comp.compId, out queue); if (queue == null) &#123; queue = new Stack&lt;Comp&gt;(); _compPool.Add(comp.compId, queue); &#125; comp.Reset(); queue.Push(comp);&#125; 实体功能实体的功能也很简单，我们定义一个实体池_entities用于保存当前所有的实体实例，定义一个实体实例缓存池_entityPool用来当实体的对象池。 123456789101112131415161718192021222324252627282930public Entity CreateEntity()&#123; if (_entityPool.Count == 0) &#123; Entity entity = new Entity(); entity.id = _entityId++; _entities.Add(entity.id,entity); return entity; &#125; else &#123; Entity entity = _entityPool.Pop(); _entities.Add(entity.id, entity); return _entityPool.Pop(); &#125;&#125;public Entity GetEntity(int id)&#123; Entity entity; _entities.TryGetValue(id, out entity); return entity;&#125;public void RemoveEntity(Entity entity)&#123; entity.Clear(); _entityPool.Push(entity); _entities.Remove(entity.id);&#125; 系统功能系统功能包括群组功能，过滤功能和组件变化的通知。 组件变化的监听是在创建群组的时候就绑定好的。通过获取对应组件 id 的组件变化数组，存入群组的监听函数，就可以在每次组件变化的时候通知所有监听该组件的群组执行对应的函数。 其他功能就是对上文现有功能的再包装。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public Group CreateGroup(ECSMatcher matcher)&#123; Group res; _groups.TryGetValue(matcher, out res); if (res == null) &#123; res = new Group(matcher); _groups.Add(matcher, res); List&lt;int&gt; compIds = matcher.GetCompIds(); foreach (int compId in compIds) &#123; List&lt;Action&lt;Entity&gt;&gt; actionList; _onCompChangeAction.TryGetValue(compId, out actionList); if (actionList == null) &#123; actionList = new List&lt;Action&lt;Entity&gt;&gt;(); _onCompChangeAction.Add(compId, actionList); &#125; actionList.Add(res.OnCompChange); &#125; &#125; return res;&#125;public void CompChangeBroadcast(Entity entity, int compId)&#123; List&lt;Action&lt;Entity&gt;&gt; actionList; _onCompChangeAction.TryGetValue(compId, out actionList); if (actionList != null) &#123; foreach (Action&lt;Entity&gt; action in actionList) &#123; action.Invoke(entity); &#125; &#125;&#125;public ECSMatcher AnyOf(params Type[] comps)&#123; return new ECSMatcher().AnyOf(comps);&#125;public ECSMatcher AllOf(params Type[] comps)&#123; return new ECSMatcher().AllOf(comps);&#125;public ECSMatcher ExcludeOf(params Type[] comps)&#123; return new ECSMatcher().ExcludeOf(comps);&#125;public ECSMatcher OnlyOf(params Type[] comps)&#123; return new ECSMatcher().OnlyOf(comps);&#125; 总的 ECS 管理类代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229using System;using System.Collections.Generic;using System.Reflection;using System.Runtime.Remoting.Metadata.W3cXsd2001;using System.Security.Cryptography;using Unity.VisualScripting;public class ECSManager : Singleton&lt;ECSManager&gt;&#123; private int _compId = 1; private int _entityId = 0; private int _total = 0; private Dictionary&lt;Type, int&gt; _comps = new Dictionary&lt;Type, int&gt;(); private Dictionary&lt;ECSMatcher, Group&gt; _groups = new Dictionary&lt;ECSMatcher, Group&gt;(); /// &lt;summary&gt; /// 组件变化监听字典 /// &lt;/summary&gt; private Dictionary&lt;int, List&lt;Action&lt;Entity&gt;&gt;&gt; _onCompChangeAction = new Dictionary&lt;int, List&lt;Action&lt;Entity&gt;&gt;&gt;(); /// &lt;summary&gt; /// 实体对象池 /// &lt;/summary&gt; private Stack&lt;Entity&gt; _entityPool = new Stack&lt;Entity&gt;(); /// &lt;summary&gt; /// 实体对象 /// &lt;/summary&gt; private Dictionary&lt;int, Entity&gt; _entities = new Dictionary&lt;int, Entity&gt;(); private Dictionary&lt;int, Stack&lt;Comp&gt;&gt; _compPool = new Dictionary&lt;int, Stack&lt;Comp&gt;&gt;(); public void Init() &#123; Assembly assembly = Assembly.GetAssembly(typeof(ECSManager)); Type[] types = assembly.GetTypes(); foreach (Type type in types) &#123; //获取自定义特性的过程中自动执行构造函数 var attr = type.GetCustomAttribute&lt;CompRegister&gt;(); if(attr != null) &#123; _total++; &#125; &#125; &#125; public void SetTotalCompNum(int num) &#123; _total = num; &#125; public int GetTotalCompNum() &#123; return _total; &#125; public int GetCompId() &#123; return _compId++; &#125; public int GetCompId(Type comp) &#123; return _comps[comp]; &#125; public Dictionary&lt;Type, int&gt; GetAllCompTypes() &#123; return _comps; &#125; /// &lt;summary&gt; /// 注册组件 /// &lt;/summary&gt; /// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;compId&quot;&gt;&lt;/param&gt; public void CompRegister(Type comp, int compId) &#123; _comps.Add(comp, compId); _compPool.Add(compId, new Stack&lt;Comp&gt;()); ConsoleUtils.Log(&quot;注册类:&quot;, compId, comp); &#125; /// &lt;summary&gt; /// 创建组件 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Comp CreateComp(Type comp) &#123; if (!_comps.ContainsKey(comp)) &#123; ConsoleUtils.Warn(&quot;未找到对应组件:&quot;, comp); return null; &#125; else &#123; int compId = _comps[comp]; Comp instance; Stack&lt;Comp&gt; queue; _compPool.TryGetValue(compId, out queue); if (queue == null || queue.Count == 0) &#123; instance = ClassFactory.CreateClass&lt;Comp&gt;(comp); instance.compId = compId; &#125; else &#123; instance = queue.Pop(); &#125; return instance; &#125; &#125; /// &lt;summary&gt; /// 回收组件 /// &lt;/summary&gt; /// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt; public void RemoveComp(Comp comp) &#123; Stack&lt;Comp&gt; queue; _compPool.TryGetValue(comp.compId, out queue); if (queue == null) &#123; queue = new Stack&lt;Comp&gt;(); _compPool.Add(comp.compId, queue); &#125; comp.Reset(); queue.Push(comp); &#125; public Group CreateGroup(ECSMatcher matcher) &#123; Group res; _groups.TryGetValue(matcher, out res); if (res == null) &#123; res = new Group(matcher); _groups.Add(matcher, res); List&lt;int&gt; compIds = matcher.GetCompIds(); foreach (int compId in compIds) &#123; List&lt;Action&lt;Entity&gt;&gt; actionList; _onCompChangeAction.TryGetValue(compId, out actionList); if (actionList == null) &#123; actionList = new List&lt;Action&lt;Entity&gt;&gt;(); _onCompChangeAction.Add(compId, actionList); &#125; actionList.Add(res.OnCompChange); &#125; &#125; return res; &#125; public Entity CreateEntity() &#123; if (_entityPool.Count == 0) &#123; Entity entity = new Entity(); entity.id = _entityId++; _entities.Add(entity.id,entity); return entity; &#125; else &#123; Entity entity = _entityPool.Pop(); _entities.Add(entity.id, entity); return _entityPool.Pop(); &#125; &#125; public Entity GetEntity(int id) &#123; Entity entity; _entities.TryGetValue(id, out entity); return entity; &#125; public void RemoveEntity(Entity entity) &#123; entity.Clear(); _entityPool.Push(entity); _entities.Remove(entity.id); &#125; public void CompChangeBroadcast(Entity entity, int compId) &#123; List&lt;Action&lt;Entity&gt;&gt; actionList; _onCompChangeAction.TryGetValue(compId, out actionList); if (actionList != null) &#123; foreach (Action&lt;Entity&gt; action in actionList) &#123; action.Invoke(entity); &#125; &#125; &#125; public ECSMatcher AnyOf(params Type[] comps) &#123; return new ECSMatcher().AnyOf(comps); &#125; public ECSMatcher AllOf(params Type[] comps) &#123; return new ECSMatcher().AllOf(comps); &#125; public ECSMatcher ExcludeOf(params Type[] comps) &#123; return new ECSMatcher().ExcludeOf(comps); &#125; public ECSMatcher OnlyOf(params Type[] comps) &#123; return new ECSMatcher().OnlyOf(comps); &#125;&#125; 使用方法Comp示例12345678910111213141516171819202122232425262728[CompRegister(typeof(TransformComp))]public class TransformComp : Comp&#123; public Vector3 position; public Quaternion rotation; public Vector3 scale; public Vector3 lastPosition; public Quaternion lastRotation; public Vector3 lastScale; public bool changed = false; public override void Reset() &#123; position = Vector3.zero; rotation = Quaternion.identity; scale = Vector3.one; lastPosition = Vector3.zero; lastRotation = Quaternion.identity; lastScale = Vector3.one; changed = false; &#125;&#125; System示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections.Generic;using UnityEngine;public class MoveSystem : ECSSystem&#123; public override ECSMatcher Filter() &#123; return ECSManager.Ins().AllOf(typeof(TransformComp), typeof(MoveComp)); &#125; public override void OnUpdate(List&lt;Entity&gt; entities) &#123; foreach (Entity entity in entities) &#123; MoveComp move = entity.Get&lt;MoveComp&gt;(); if (move.inputForward != Vector3.zero &amp;&amp; !entity.Has&lt;ClimbUpComp&gt;() &amp;&amp; (!move.isClimb || move.isClimb &amp;&amp; move.climbJump == 0)) &#123; if (move.isClimb) &#123; move.curForwad = move.inputForward; &#125; else &#123; move.curForwad = move.forward; move.fixedForward = move.up * move.forward; &#125; move.nextPostition += move.fixedForward * move.speed; &#125; &#125; &#125; /// &lt;summary&gt; /// 辅助线 /// &lt;/summary&gt; /// &lt;param name=&quot;entities&quot;&gt;&lt;/param&gt; public override void OnDrawGizmos(List&lt;Entity&gt; entities) &#123; foreach (Entity entity in entities) &#123; MoveComp move = entity.Get&lt;MoveComp&gt;(); TransformComp transform = entity.Get&lt;TransformComp&gt;(); Gizmos.DrawLine(transform.position, transform.position + move.fixedForward * 100); &#125; &#125;&#125; World示例12345678910111213141516public class LogicWorld : ECSWorld&#123; public override void SystemAdd() &#123; Add(new TransformSystem()); Add(new ClimbSystem()); Add(new MoveSystem()); Add(new JumpSystem()); Add(new ClimbUpSystem()); Add(new QTreeSystem()); Add(new QObjFindingSystem()); Add(new WeaponSystem()); Add(new LogicAniSystem()); Add(new AniSystem()); &#125;&#125; 主循环示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107using System;using System.Collections.Generic;using UnityEditor;using UnityEngine;public class Launcher : MonoBehaviour&#123; private bool _inited = false; private int _initIndex = 0; private LogicWorld _logicWorld; private PhysicWorld _physicWorld; private RenderWorld _renderWorld; void Start() &#123; InitNext(); &#125; private void Update() &#123; if (_inited) &#123; _renderWorld.Update(); &#125; &#125; private void FixedUpdate() &#123; if (_inited) &#123; _logicWorld.Update(); _physicWorld.Update(); &#125; &#125; void OnDrawGizmos() &#123; if (_inited) &#123; _logicWorld.DrawGrizmos(); _physicWorld.DrawGrizmos(); _renderWorld.DrawGrizmos(); &#125; &#125; private void InitNext() &#123; ConsoleUtils.Log(&quot;当前步骤&quot;,_initIndex); switch (_initIndex++) &#123; case 0: InitUtils(); break; case 1: LoadRes(); break; case 2: InitManager(); break; case 3: StartGame(); break; case 4: InitGlobals(); break; case 5: _inited = true; UIManager.Ins().Hide(_loadingView); break; &#125; &#125; private void LoadRes() &#123; InitNext(); &#125; private void InitGlobals() &#123; InitNext(); &#125; private void InitUtils() &#123; InitNext(); &#125; private void InitManager() &#123; ECSManager.Ins().Init(); InitNext(); &#125; private void StartGame() &#123; _logicWorld = new LogicWorld(); _physicWorld = new PhysicWorld(); _renderWorld = new RenderWorld(); InitNext(); &#125;&#125; 项目工程由于本项目代码较多，因此请移步 GitHub 查看详细代码。 注意事项本文的 ECS 架构并未做多线程或并行处理，这部分内容请自行改造。 本文内容与TS 实现 ECS 架构一文基本相同，只是做了 Unity 版本的移植和调整并且修复一些 bug，不过建议以本文为主。 更新日志2024-03-08 更新 ECS 基本内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"碰撞检测之胶囊体与其他","slug":"碰撞检测之胶囊体与其他","date":"2024-03-05T08:04:10.000Z","updated":"2024-05-30T12:26:04.173Z","comments":true,"path":"article/f9709c7609f9/","link":"","permalink":"https://busyogg.github.io/article/f9709c7609f9/","excerpt":"","text":"简介本文主要阐述胶囊体与其他包围盒的碰撞检测原理和实现方式。由于其基本原理相同，因此放在同一篇讲。 原理对于胶囊体来说，碰撞检测的原理都是一样的，都是确定两个检测点，然后判断点与点之间的关系。因此我们可以参考胶囊体之间的碰撞检测得出胶囊体与其他包围盒的碰撞检测原理。 圆AABBOBB射线胶囊体与圆的碰撞，其实就是简化版的胶囊体与胶囊体的碰撞。因为在胶囊体的碰撞检测中，我们最终得到的就是圆与圆的碰撞。 因此对于胶囊体与圆来说，圆就相当于省去一个胶囊体的计算，而直接得到结果。胶囊体与 AABB 的碰撞，我们只要先拿到 AABB 中心点在胶囊体线段上的最近点，然后根据这个最近点求 AABB 表面的最近点，然后比较两点的距离是否小于胶囊体半径即可。 我们可以使用往期碰撞检测中获取最近点的方法即可。 判断碰撞的代码如下： 12345678910111213//求胶囊体半径平方float totalRadius = Mathf.Pow(data2.radius, 2);//求两个点之间的距离float distance = (closest1 - closest2).sqrMagnitude;//距离小于等于半径平方则碰撞if (distance &lt;= totalRadius)&#123; return true;&#125;else&#123; return false;&#125;胶囊体与 OBB 的碰撞，我们只要先拿到 OBB 中心点在胶囊体线段的最近点，然后根据这个最近点求 OBB 表面上的最近点，然后比较两点的距离是否小于胶囊体半径即可。 我们可以使用往期碰撞检测中获取最近点的方法即可。 判断碰撞的代码如下： 12345678910111213//求胶囊体半径平方float totalRadius = Mathf.Pow(data2.radius, 2);//求两个点之间的距离float distance = (closest1 - closest2).sqrMagnitude;//距离小于等于半径平方则碰撞if (distance &lt;= totalRadius)&#123; return true;&#125;else&#123; return false;&#125;胶囊体与射线的碰撞，我们不妨把射线看成另一个胶囊体的线段部分，根据射线的起点和终点我们可以得到线段的中心点，然后就和胶囊体碰撞检测的流程一样进行即可。 不过在最终的碰撞检测部分，逻辑要和 AABB 及 OBB 一样，如下： 12345678910111213//求胶囊体半径平方float totalRadius = Mathf.Pow(data2.radius, 2);//求两个点之间的距离float distance = (closest1 - closest2).sqrMagnitude;//距离小于等于半径平方则碰撞if (distance &lt;= totalRadius)&#123; return true;&#125;else&#123; return false;&#125; 代码工具函数求线段上最近点12345678private Vector3 GetClosestPointOnLineSegment(Vector3 start, Vector3 end, Vector3 point)&#123; Vector3 line = end - start; //dot line line 求长度平方 float ratio = Vector3.Dot(point - start, line) / Vector3.Dot(line, line); ratio = Mathf.Min(Mathf.Max(ratio, 0), 1); return start + ratio * line;&#125; 求AABB最近点123456789private Vector3 GetClosestPointAABB(Vector3 pos, CollisionData other)&#123; //Vector3 center = data1.center; Vector3 nearP = Vector3.zero; nearP.x = Mathf.Clamp(pos.x, other.min.x, other.max.x); nearP.y = Mathf.Clamp(pos.y, other.min.y, other.max.y); nearP.z = Mathf.Clamp(pos.z, other.min.z, other.max.z); return nearP;&#125; 求OBB最近点1234567891011121314151617181920212223private Vector3 GetClosestPointOBB(Vector3 pos,CollisionData other)&#123; Vector3 nearP = data2.center; //求球心与OBB中心的距离向量 从OBB中心指向球心 Vector3 center1 = pos; Vector3 center2 = data2.center; Vector3 dist = center1 - center2; float[] extents = new float[3] &#123; data2.extents.x, data2.extents.y, data2.extents.z &#125;; Vector3[] axes = data2.axes; for (int i = 0; i &lt; 3; i++) &#123; //计算距离向量到OBB坐标轴的投影长度 即距离向量在OBB坐标系中的对应坐标轴的长度 float distance = Vector3.Dot(dist, axes[i]); distance = Mathf.Clamp(distance, -extents[i], extents[i]); //还原到世界坐标 nearP.x += distance * axes[i].x; nearP.y += distance * axes[i].y; nearP.z += distance * axes[i].z; &#125; return nearP;&#125; 碰撞检测圆AABBOBB射线12345678910111213141516171819202122private void CollisionCapsule2Circle(CollisionData data1,CollisionData data2)&#123; //计算头尾点最值 Vector3 point1 = data1.center + data1.direction * data1.extents.y; Vector3 point2 = data1.center - data1.direction * data1.extents.y; Vector3 closest = GetClosestPointOnLineSegment(point1, point2, data2.center); //求两个球半径和 float totalRadius = Mathf.Pow(data1.radius + data2.radius, 2); //球两个球心之间的距离 float distance = (closest - data2.center).sqrMagnitude; //距离小于等于半径和则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; else &#123; return false; &#125;&#125;1234567891011121314151617181920212223private void CollisionCapsule2AABB(CollisionData data1,CollisionData data2)&#123; //计算头尾点最值 Vector3 pointA1 = data1.center + data1.direction * data1.extents.y; Vector3 pointA2 = data1.center - data1.direction * data1.extents.y; Vector3 closest1 = GetClosestPointOnLineSegment(pointA1, pointA2, closest2); Vector3 closest2 = GetClosestPointAABB(closest1, data2); //求胶囊体半径平方 float totalRadius = Mathf.Pow(data1.radius, 2); //求两个点之间的距离 float distance = (closest1 - closest2).sqrMagnitude; //距离小于等于半径平方则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; else &#123; return false; &#125;&#125;1234567891011121314151617181920212223private void CollisionCapsule2OBB(CollisionData data1,CollisionData data2)&#123; //计算头尾点最值 Vector3 pointA1 = data1.center + data1.direction * data1.extents.y; Vector3 pointA2 = data1.center - data1.direction * data1.extents.y; Vector3 closest1 = GetClosestPointOnLineSegment(pointA1, pointA2, closest2); Vector3 closest2 = GetClosestPointOBB(closest1, data2); //求胶囊体半径平方 float totalRadius = Mathf.Pow(data1.radius, 2); //求两个点之间的距离 float distance = (closest1 - closest2).sqrMagnitude; //距离小于等于半径平方则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; else &#123; return false; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839private void CollisionRay2Capsule(CollisionData data1,CollisionData data2)&#123; //计算头尾点最值 Vector3 pointA1 = data1.center; Vector3 pointA2 = data1.center + data1.direction * data1.radius; Vector3 pointB1 = data2.center + data2.direction * data2.extents.y; Vector3 pointB2 = data2.center - data2.direction * data2.extents.y; Vector3 center = (pointA1 + pointA2) * 0.5f; Vector3 closest2; if ((pointB1 - center).magnitude &lt;= (pointB2 - center).magnitude) &#123; closest2 = pointB1; &#125; else &#123; closest2 = pointB2; &#125; Vector3 closest1 = GetClosestPointOnLineSegment(pointA1, pointA2, closest2); closest2 = GetClosestPointOnLineSegment(pointB1, pointB2, closest1); //求胶囊体半径平方 float totalRadius = Mathf.Pow(data2.radius, 2); //求两个点之间的距离 float distance = (closest1 - closest2).sqrMagnitude; //距离小于等于半径平方则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; else &#123; return false; &#125;&#125; 项目工程 更新日志2024-05-19 修复 AABB 与 OBB 最近点检测 bug。 2024-04-18 修复 AABB 与 OBB 求最近点参数带入错误。 2024-03-05 更新胶囊体与其他碰撞检测基本内容。","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"胶囊体","slug":"胶囊体","permalink":"https://busyogg.github.io/tags/%E8%83%B6%E5%9B%8A%E4%BD%93/"}]},{"title":"碰撞检测之胶囊体","slug":"碰撞检测之胶囊体","date":"2024-03-04T17:08:06.000Z","updated":"2024-05-30T12:25:53.983Z","comments":true,"path":"article/721cc45e1056/","link":"","permalink":"https://busyogg.github.io/article/721cc45e1056/","excerpt":"","text":"简介本文主要阐述胶囊体之间的碰撞检测原理和实现方式。 原理胶囊体的表示我们使用 5 个参数来表示一个胶囊体。 center：胶囊体的中心位置。 height: 胶囊体中间圆柱部分的高度，本文使用 data.extents.y 来代替。 radius：胶囊体的上下半圆部分的半径。 rotation：胶囊体的旋转角度。 direction：胶囊体的竖直方向。 碰撞检测胶囊体的碰撞检测，主要的原理和圆的碰撞检测差不多。我们可以把胶囊体看成多个圆心在一个线段上的球。我们只要找到两个胶囊体之间最近的两个线段上的点，就能用圆的碰撞检测判断两个胶囊体是否相交。 如图所示，判断两个胶囊体碰撞，我们主要判断 A 点和 B 点的圆是否相交。 现在我们的目标就很明确了，找出两个胶囊体最适合的检测点。 首先我们要找出两个胶囊体线段的最大值和最小值，通过如下计算可得到： 123456//计算头尾点最值Vector3 pointA1 = data1.center + data1.direction * data1.extents.y;Vector3 pointA2 = data1.center - data1.direction * data1.extents.y;Vector3 pointB1 = data2.center + data2.direction * data2.extents.y;Vector3 pointB2 = data2.center - data2.direction * data2.extents.y; 然后我们计算两个胶囊体线段之间的最小距离，可以参考碰撞检测之线段检测的内容。 最后我们只需要进行圆与圆的碰撞检测就可以得到是否相交了。 代码胶囊体碰撞检测1234567891011121314151617181920212223242526private bool CollisionCapsule(CollisionData data1,CollisionData data2)&#123; //计算头尾点最值 Vector3 pointA1 = data1.center + data1.direction * data1.extents.y; Vector3 pointA2 = data1.center - data1.direction * data1.extents.y; Vector3 pointB1 = data2.center + data2.direction * data2.extents.y; Vector3 pointB2 = data2.center - data2.direction * data2.extents.y; Vector3 closest1; // 求两条线段的最短距离 float distance = GetClosestDistanceBetweenLinesSqr(pointA1, pointA2, pointB1, pointB2); //求两个球半径和 float totalRadius = Mathf.Pow(data1.radius + data2.radius, 2); //距离小于等于半径和则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; else &#123; return false; &#125;&#125; 项目地址 更新日志2024-05-19 修复胶囊体检测 bug。 2024-03-05 修改错别字。 2024-03-05 更新胶囊体检测基础内容。","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"胶囊体","slug":"胶囊体","permalink":"https://busyogg.github.io/tags/%E8%83%B6%E5%9B%8A%E4%BD%93/"}]},{"title":"Unity-利用特性反射来绑定 UI","slug":"利用特性反射来绑定UI","date":"2024-02-22T13:50:13.000Z","updated":"2024-05-30T12:25:22.927Z","comments":true,"path":"article/999bc53b642c/","link":"","permalink":"https://busyogg.github.io/article/999bc53b642c/","excerpt":"","text":"简介UI 界面在初始化的时候，我们往往需要获取 UI 组件，然后在 UI 组件的内容发生变化的时候对 UI 组件进行赋值。我们需要同时管理 UI 组件和数据，有时候会觉得很繁琐。于是我想到利用特性 Attribute 来反射初始化 UI 组件，使其和数据绑定在一起，更新数据就可以自动更新 UI。 在此基础上，我又拓展了 UI 动作绑定和 UI 监听绑定，这样只需要对方法标记特性，就可以自动完成对应的绑定工作。 本框架支持自定义拓展功能，具体的使用说明和拓展规则见： ReflectionBindUI 文档 原理UI 数据类型为了实现 UI 数据更新的同时更新 UI 界面，并且不需要我们自己在每个 UI 界面属性中设置 setter 响应事件，我们就需要一个新的类型来表示数据。 新的数据类型内容很简单，就是保存原始数据，以及设置一个数据更改时的响应函数 _onValueChange，一个 UI 更改时的响应函数 _onUIChange，在每次数据变化或 UI 变化的时候调用即可。 原理就是在值改变的时候在 set 方法中调用修改 UI 的委托；在通过 Get() 获取值的时候调用同步 UI 改变后的值的委托。 不过 List 类型有所不同，一般 List 不会在 UI 上直接修改，所以只有 _onValueChange 。 StringUIPropDoubleUIPropUIListPropUI 数据类型 String，大部分情况下的选择。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System;public class StringUIProp&#123; public string _value; private string val &#123; get &#123; return _value; &#125; set &#123; _value = value; InvokeUI(); &#125; &#125; private Action&lt;string&gt; _onValueChange = null; private Func&lt;string&gt; _onUIChange = null; public StringUIProp() &#123; &#125; public StringUIProp(string value) &#123; _value = value; &#125; public void Set(string value) &#123; this.val = value; &#125; public void Set&lt;T&gt;(T value) &#123; this.val = value.ToString(); &#125; public string Get() &#123; InvokeValue(); return this.val; &#125; public void InvokeValue() &#123; if (_onUIChange != null) &#123; _value = _onUIChange.Invoke(); &#125; &#125; public void InvokeUI() &#123; _onValueChange?.Invoke(val); &#125; public override string ToString() &#123; return val; &#125;&#125;UI 数据类型 Double，拖拽条之类的情况下使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;public class DoubleUIProp&#123; public double _value; private double val &#123; get &#123; return _value; &#125; set &#123; _value = value; InvokeUI(); &#125; &#125; private Action&lt;double&gt; _onValueChange = null; private Func&lt;double&gt; _onUIChange = null; public DoubleUIProp() &#123; &#125; public DoubleUIProp(double value) &#123; _value = value; &#125; public void Set(double value) &#123; this.val = value; &#125; public double Get() &#123; InvokeValue(); return this.val; &#125; public void InvokeValue() &#123; if (_onUIChange != null) &#123; _value = _onUIChange.Invoke(); &#125; &#125; public void InvokeUI() &#123; _onValueChange?.Invoke(val); &#125; public override string ToString() &#123; return val.ToString(); &#125;&#125;List 的 UI 数据类型，响应事件和标准 UI 类型不同，并且数据类型为泛型List&lt;T&gt;以适应各种数据类型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class UIListProp&lt;T&gt;&#123; private List&lt;T&gt; _value; private List&lt;T&gt; val &#123; get &#123; return _value; &#125; set &#123; _value = value; Invoke(); &#125; &#125; public int Count &#123; get; set; &#125; private Action&lt;int&gt; _onValueChange = null; public UIListProp() &#123; &#125; public UIListProp(List&lt;T&gt; value) &#123; //this.val = value; _value = value; &#125; public List&lt;T&gt; Get() &#123; return val; &#125; public void Set(List&lt;T&gt; value) &#123; val = value; Count = val.Count; &#125; public void Invoke() &#123; if (val != null) &#123; _onValueChange?.Invoke(val.Count); &#125; &#125; public override string ToString() &#123; string res = &quot;[&quot;; foreach (var item in val) &#123; res += item.ToString() + &quot;,&quot;; &#125; res += &quot;]&quot;; return res; &#125;&#125; 特性初始化除了用于绑定 UI 的特性外，我们还可以搭配辅助特性，例如 UIColor、UIOption 等，辅助初始化的设置，具体用法参考 使用方法。 UICompBindUIDataBindUIActionBindUIListenerBindUIClassBind绑定 UI 组件，需要传入组件类型和路径。 12345678910111213141516171819using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 绑定UI组件/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Property)]public class UICompBind :Attribute&#123; public string _type; public string _path; public UICompBind(string type,string path) &#123; _type = type; _path = path; &#125;&#125;绑定 UI 数据，需要传入组件类型和路径。 1234567891011121314151617using System;/// &lt;summary&gt;/// 绑定UI组件和数据，使其根据数据修改UI/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Property)]public class UIDataBind : Attribute&#123; public string _type; public string _path; public UIDataBind(string type, string path) &#123; _type = type; _path = path; &#125;&#125;绑定 UI 动作，需要传入组件类型和路径。 12345678910111213141516171819using System;/// &lt;summary&gt;/// 绑定UI组件和动作事件，使其支持交互/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Method)]public class UIActionBind : Attribute&#123; public string _type; public string _path; public UIActionBind(string type,string path) &#123; _type = type; _path = path; &#125;&#125;绑定 UI 监听事件，只需要传入监听事件的名称。监听事件的 id 是界面 id，自动传入。 12345678910111213141516171819using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 绑定UI监听事件/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Method)]public class UIListenerBind : Attribute&#123; public string _name; public UIListenerBind(string name) &#123; _name = name; &#125;&#125;绑定 UI 类，需要传入类行为和额外参数。 123456789101112using System;[AttributeUsage(AttributeTargets.Class)]public class UIClassBind : Attribute&#123; public UIClass type; public UIClassBind(UIClass type) &#123; this.type = type; &#125;&#125; 反射绑定我们通过基类初始化获取 Type，然后通过 Type 获取 properties 和 method（如果有需要也可以自己添加 fields），之后通过遍历属性和方法，在其循环体内获取对应属性或方法的特性标签，判断标签类型是否为 UI 绑定类型，是则进行对应的操作。 不同类型的组件绑定方法可自行添加或修改。 绑定组件绑定数据绑定行为绑定监听绑定类12345678910111213private void BindComp(PropertyInfo prop, object attr, GComponent main)&#123; UICompBind uiBind = (UICompBind)attr; switch (uiBind._type) &#123; case &quot;Comp&quot;: GComponent comp = FguiUtils.GetUI&lt;GComponent&gt;(main, uiBind._path); prop.SetValue(this, comp); break; //...... &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445private void BindData(PropertyInfo prop, object attr, GComponent main)&#123; UIDataBind uiBind = (UIDataBind)attr; var onValueChange = prop.PropertyType.GetField(&quot;_onValueChange&quot;, _flag); var onUIChange = prop.PropertyType.GetField(&quot;_onUIChange&quot;, _flag); var value = prop.GetValue(this); if (value == null) &#123; if (prop.PropertyType.Equals(typeof(UIProp))) &#123; value = new UIProp(); &#125; else &#123; Type genericType = typeof(UIListProp&lt;&gt;).MakeGenericType(prop.PropertyType.GenericTypeArguments); value = Activator.CreateInstance(genericType); &#125; prop.SetValue(this, value); &#125; switch (uiBind._type) &#123; case &quot;TextField&quot;: GTextField textField = FguiUtils.GetUI&lt;GTextField&gt;(main, uiBind._path); void ActionText(string data) &#123; if (textField != null) &#123; textField.text = data; &#125; &#125; string ActionTextUI() &#123; return textField.text; &#125; onValueChange?.SetValue(value, (Action&lt;string&gt;)ActionText); onUIChange?.SetValue(value, (Func&lt;string&gt;)ActionTextUI); break; //...... &#125;&#125;1234567891011121314151617181920212223private void BindAction(MethodInfo method, object attr, GComponent main)&#123; UIActionBind uiBind = (UIActionBind)attr; GObject obj = FguiUtils.GetUI&lt;GObject&gt;(main, uiBind._path); switch (uiBind._type) &#123; case &quot;Click&quot;: var methondParamsClick = method.GetParameters(); Delegate click = null; if (methondParamsClick.Length == 0) &#123; click = Delegate.CreateDelegate(typeof(EventCallback0), this, method); obj.onClick.Set((EventCallback0)click); &#125; else &#123; click = Delegate.CreateDelegate(typeof(EventCallback1), this, method); obj.onClick.Set((EventCallback1)click); &#125; break; //...... &#125;&#125;123456private void BindListener(MethodInfo method, object attr, string id)&#123; UIListenerBind uiBind = (UIListenerBind)attr; var eventFunc = Delegate.CreateDelegate(typeof(Action&lt;ArrayList&gt;), this, method); EventManager.AddListening(id, uiBind._name, (Action&lt;ArrayList&gt;)eventFunc);&#125;本方法与其他方法不同，其他方法在 UIBase 中初始化，本方法在 BaseView 中初始化。 123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// 绑定 类/// &lt;/summary&gt;/// &lt;param name=&quot;attr&quot;&gt;&lt;/param&gt;private void BindClass(object attr)&#123; UIClassBind uiClassBind = (UIClassBind)attr; switch (uiClassBind.type) &#123; case UIClass.Model: if (_model == null) &#123; _model = new GGraph(); _model.displayObject.gameObject.name = id + &quot;_&quot; + name + &quot;_Model&quot;; UIColor colorAttr = _type.GetCustomAttribute&lt;UIColor&gt;(); Color color = new Color(0, 0, 0, 0); if (colorAttr != null) &#123; color = colorAttr.color; &#125; Vector2 size = GRoot.inst.size; _model.DrawRect(size.x, size.y, 0, new Color(), color); &#125; UIManager.Ins().SetModel(uiNode, _model); _model.onClick.Set(() =&gt; &#123; if (uiClassBind.extra.Length &gt; 0 &amp;&amp; uiClassBind.extra[0] == &quot;Hide&quot;) &#123; Hide(); main.AddChild(_model); &#125; &#125;); break; //其他case &#125;&#125; 查找 UI绑定组件必不可少的就是查找 UI，本项目使用 FGUI，因此查找 UI 也是根据 FGUI 写的。 根据传入的路径，拆分为每一层具体的索引，然后判断索引是数字还是字符串，是数字就调用 GetChildAt，是字符串就调用 GetChild。 1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt;/// 根据路径获取UI组件/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;/// &lt;param name=&quot;comp&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static T GetUI&lt;T&gt;(GComponent comp, string path) where T : GObject&#123; string[] paths = path.Split(&#x27;/&#x27;); GObject res = null; GComponent parent = comp; foreach (string s in paths) &#123; if (s == &quot;&quot;) continue; int output; bool isNumeric = int.TryParse(s, out output); if (isNumeric) &#123; res = parent.GetChildAt(output); &#125; else &#123; res = parent.GetChild(s); &#125; if (res == null) &#123; ConsoleUtils.Error(&quot;ui路径错误&quot;, path); return null; &#125; if (res is GComponent) &#123; parent = res.asCom; &#125; else &#123; break; &#125; &#125; return res as T;&#125; 缓动动画本项目实现了一个简单的缓动动画系统，用于控制 UI 窗口的进入和退出缓动动画。 缓动动画的原理很简单，就是在持续时间内每帧做插值。 插值函数缓动单元缓动更新缓动管理类使用 Laya 引擎内的插值函数修改而成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250using System;using UnityEngine;public enum TweenEaseType&#123; Linear, SineIn, SineOut, SineInOut, QuadIn, QuadOut, QuadInOut, CubicIn, CubicOut, CubicInOut, QuartIn, QuartOut, QuartInOut, QuintIn, QuintOut, QuintInOut, ExpoIn, ExpoOut, ExpoInOut, CircIn, CircOut, CircInOut, ElasticIn, ElasticOut, ElasticInOut, BackIn, BackOut, BackInOut, BounceIn, BounceOut, BounceInOut, Custom&#125;public class EaseUtil&#123; const float _PiOver2 = Mathf.PI * 0.5f; const float _TwoPi = Mathf.PI * 2; internal static float Evaluate(TweenEaseType TweenEaseType, float time, float duration, float overshootOrAmplitude, float period) &#123; if (duration &lt;= 0) return 1; switch (TweenEaseType) &#123; case TweenEaseType.Linear: return time / duration; case TweenEaseType.SineIn: return -(float)Math.Cos(time / duration * _PiOver2) + 1; case TweenEaseType.SineOut: return (float)Math.Sin(time / duration * _PiOver2); case TweenEaseType.SineInOut: return -0.5f * ((float)Math.Cos(Mathf.PI * time / duration) - 1); case TweenEaseType.QuadIn: return (time /= duration) * time; case TweenEaseType.QuadOut: return -(time /= duration) * (time - 2); case TweenEaseType.QuadInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time; return -0.5f * ((--time) * (time - 2) - 1); case TweenEaseType.CubicIn: return (time /= duration) * time * time; case TweenEaseType.CubicOut: return ((time = time / duration - 1) * time * time + 1); case TweenEaseType.CubicInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time * time; return 0.5f * ((time -= 2) * time * time + 2); case TweenEaseType.QuartIn: return (time /= duration) * time * time * time; case TweenEaseType.QuartOut: return -((time = time / duration - 1) * time * time * time - 1); case TweenEaseType.QuartInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time * time * time; return -0.5f * ((time -= 2) * time * time * time - 2); case TweenEaseType.QuintIn: return (time /= duration) * time * time * time * time; case TweenEaseType.QuintOut: return ((time = time / duration - 1) * time * time * time * time + 1); case TweenEaseType.QuintInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time * time * time * time; return 0.5f * ((time -= 2) * time * time * time * time + 2); case TweenEaseType.ExpoIn: return (time == 0) ? 0 : (float)Math.Pow(2, 10 * (time / duration - 1)); case TweenEaseType.ExpoOut: if (time == duration) return 1; return (-(float)Math.Pow(2, -10 * time / duration) + 1); case TweenEaseType.ExpoInOut: if (time == 0) return 0; if (time == duration) return 1; if ((time /= duration * 0.5f) &lt; 1) return 0.5f * (float)Math.Pow(2, 10 * (time - 1)); return 0.5f * (-(float)Math.Pow(2, -10 * --time) + 2); case TweenEaseType.CircIn: return -((float)Math.Sqrt(1 - (time /= duration) * time) - 1); case TweenEaseType.CircOut: return (float)Math.Sqrt(1 - (time = time / duration - 1) * time); case TweenEaseType.CircInOut: if ((time /= duration * 0.5f) &lt; 1) return -0.5f * ((float)Math.Sqrt(1 - time * time) - 1); return 0.5f * ((float)Math.Sqrt(1 - (time -= 2) * time) + 1); case TweenEaseType.ElasticIn: float s0; if (time == 0) return 0; if ((time /= duration) == 1) return 1; if (period == 0) period = duration * 0.3f; if (overshootOrAmplitude &lt; 1) &#123; overshootOrAmplitude = 1; s0 = period / 4; &#125; else s0 = period / _TwoPi * (float)Math.Asin(1 / overshootOrAmplitude); return -(overshootOrAmplitude * (float)Math.Pow(2, 10 * (time -= 1)) * (float)Math.Sin((time * duration - s0) * _TwoPi / period)); case TweenEaseType.ElasticOut: float s1; if (time == 0) return 0; if ((time /= duration) == 1) return 1; if (period == 0) period = duration * 0.3f; if (overshootOrAmplitude &lt; 1) &#123; overshootOrAmplitude = 1; s1 = period / 4; &#125; else s1 = period / _TwoPi * (float)Math.Asin(1 / overshootOrAmplitude); return (overshootOrAmplitude * (float)Math.Pow(2, -10 * time) * (float)Math.Sin((time * duration - s1) * _TwoPi / period) + 1); case TweenEaseType.ElasticInOut: float s; if (time == 0) return 0; if ((time /= duration * 0.5f) == 2) return 1; if (period == 0) period = duration * (0.3f * 1.5f); if (overshootOrAmplitude &lt; 1) &#123; overshootOrAmplitude = 1; s = period / 4; &#125; else s = period / _TwoPi * (float)Math.Asin(1 / overshootOrAmplitude); if (time &lt; 1) return -0.5f * (overshootOrAmplitude * (float)Math.Pow(2, 10 * (time -= 1)) * (float)Math.Sin((time * duration - s) * _TwoPi / period)); return overshootOrAmplitude * (float)Math.Pow(2, -10 * (time -= 1)) * (float)Math.Sin((time * duration - s) * _TwoPi / period) * 0.5f + 1; case TweenEaseType.BackIn: return (time /= duration) * time * ((overshootOrAmplitude + 1) * time - overshootOrAmplitude); case TweenEaseType.BackOut: return ((time = time / duration - 1) * time * ((overshootOrAmplitude + 1) * time + overshootOrAmplitude) + 1); case TweenEaseType.BackInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * (time * time * (((overshootOrAmplitude *= (1.525f)) + 1) * time - overshootOrAmplitude)); return 0.5f * ((time -= 2) * time * (((overshootOrAmplitude *= (1.525f)) + 1) * time + overshootOrAmplitude) + 2); case TweenEaseType.BounceIn: return Bounce.EaseIn(time, duration); case TweenEaseType.BounceOut: return Bounce.EaseOut(time, duration); case TweenEaseType.BounceInOut: return Bounce.EaseInOut(time, duration); default: return -(time /= duration) * (time - 2); &#125; &#125;&#125;/// &lt;summary&gt;/// This class contains a C# port of the easing equations created by Robert Penner (http://robertpenner.com/easing)./// &lt;/summary&gt;static class Bounce&#123; /// &lt;summary&gt; /// Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in: accelerating from zero velocity. /// &lt;/summary&gt; /// &lt;param name=&quot;time&quot;&gt; /// Current time (in frames or seconds). /// &lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt; /// Expected easing duration (in frames or seconds). /// &lt;/param&gt; /// &lt;returns&gt; /// The eased value. /// &lt;/returns&gt; public static float EaseIn(float time, float duration) &#123; return 1 - EaseOut(duration - time, duration); &#125; /// &lt;summary&gt; /// Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out: decelerating from zero velocity. /// &lt;/summary&gt; /// &lt;param name=&quot;time&quot;&gt; /// Current time (in frames or seconds). /// &lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt; /// Expected easing duration (in frames or seconds). /// &lt;/param&gt; /// &lt;returns&gt; /// The eased value. /// &lt;/returns&gt; public static float EaseOut(float time, float duration) &#123; if ((time /= duration) &lt; (1 / 2.75f)) &#123; return (7.5625f * time * time); &#125; if (time &lt; (2 / 2.75f)) &#123; return (7.5625f * (time -= (1.5f / 2.75f)) * time + 0.75f); &#125; if (time &lt; (2.5f / 2.75f)) &#123; return (7.5625f * (time -= (2.25f / 2.75f)) * time + 0.9375f); &#125; return (7.5625f * (time -= (2.625f / 2.75f)) * time + 0.984375f); &#125; /// &lt;summary&gt; /// Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in/out: acceleration until halfway, then deceleration. /// &lt;/summary&gt; /// &lt;param name=&quot;time&quot;&gt; /// Current time (in frames or seconds). /// &lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt; /// Expected easing duration (in frames or seconds). /// &lt;/param&gt; /// &lt;returns&gt; /// The eased value. /// &lt;/returns&gt; public static float EaseInOut(float time, float duration) &#123; if (time &lt; duration * 0.5f) &#123; return EaseIn(time * 2, duration) * 0.5f; &#125; return EaseOut(time * 2 - duration, duration) * 0.5f + 0.5f; &#125;&#125;包含了缓动需要的所有数据和方法。 12345678910111213141516171819202122232425262728293031323334using System;using UnityEngine;public class UITween&#123; public int id; public float duration; private int _time; public bool isStop; public Action&lt;float&gt; updater; public Action callback; public void Update(int delta) &#123; _time += delta; if (_time &lt;= duration) &#123; updater?.Invoke(_time); &#125; else &#123; updater?.Invoke(duration); callback?.Invoke(); isStop = true; updater = null; callback = null; &#125; &#125;&#125;缓动动画需要依托 MonoBehaviour 来进行更新，因此我们设置一个脚本专门用于更新缓动。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Collections.Generic;using UnityEngine;public class TweenUpdater : MonoBehaviour&#123; private Dictionary&lt;int,UITween&gt; _actions = new Dictionary&lt;int,UITween&gt;(); private List&lt;int&gt; _removeActionIndexes = new List&lt;int&gt;(); void Update() &#123; int delta = (int)(Time.deltaTime * 1000); foreach (var action in _actions) &#123; UITween vt = action.Value; if (vt.isStop) &#123; _removeActionIndexes.Add(vt.id); &#125; else &#123; vt.Update(delta); &#125; &#125; for (int i = _removeActionIndexes.Count - 1; i &gt;= 0; i--) &#123; _actions.Remove(_removeActionIndexes[i]); _removeActionIndexes.RemoveAt(i); &#125; &#125; public void AddTween(UITween tween) &#123; _actions.Add(tween.id,tween); &#125; public void StopTween(int id) &#123; UITween tween; _actions.TryGetValue(id, out tween); if (tween != null) &#123; tween.isStop = true; &#125; &#125;&#125;本类为单例模式，实现了缓动的创建和停止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154using System;using FairyGUI;using UnityEngine;public class UITweenManager : Singleton&lt;UITweenManager&gt;&#123; private TweenUpdater _updater; private int _id = 0; public void Init() &#123; GameObject obj = new GameObject(); obj.name = &quot;TweenUpdater&quot;; _updater = obj.AddComponent&lt;TweenUpdater&gt;(); &#125; public int AddTween(GObject obj, TweenTarget target, float end, int duration, TweenEaseType ease = TweenEaseType.Linear, Action callback = null) &#123; UITween vt = new UITween(); vt.id = _id++; vt.duration = duration; vt.updater = GenerateUpdater(obj, target, end, duration, ease); vt.callback = callback; _updater.AddTween(vt); return vt.id; &#125; public int AddTween(GObject obj, TweenTarget target, Vector2 end, int duration, TweenEaseType ease = TweenEaseType.Linear, Action callback = null) &#123; UITween vt = new UITween(); vt.id = _id++; vt.duration = duration; vt.updater = GenerateUpdater(obj, target, end, duration, ease); vt.callback = callback; _updater.AddTween(vt); return vt.id; &#125; public void StopTween(int id) &#123; _updater.StopTween(id); &#125; private Action&lt;float&gt; GenerateUpdater(GObject obj, TweenTarget target, float end, float duration, TweenEaseType ease) &#123; float origin = 0; switch (target) &#123; case TweenTarget.X: origin = obj.x; break; case TweenTarget.Y: origin = obj.y; break; case TweenTarget.ScaleX: origin = obj.scaleX; break; case TweenTarget.ScaleY: origin = obj.scaleY; break; case TweenTarget.Rotation: origin = obj.rotation; break; case TweenTarget.Alpha: origin = obj.alpha; break; case TweenTarget.Heihgt: origin = obj.height; break; case TweenTarget.Width: origin = obj.width; break; &#125; void Action(float time) &#123; float ratio = EaseUtil.Evaluate(ease, time, duration, 1.7f, 0); switch (target) &#123; case TweenTarget.X: obj.x = origin + ratio * end; break; case TweenTarget.Y: obj.y = origin + ratio * end; break; case TweenTarget.ScaleX: obj.scaleX = origin + ratio * end; break; case TweenTarget.ScaleY: obj.scaleY = origin + ratio * end; break; case TweenTarget.Rotation: obj.rotation = origin + ratio * end; break; case TweenTarget.Alpha: obj.alpha = origin + ratio * end; break; case TweenTarget.Heihgt: obj.height = origin + ratio * end; break; case TweenTarget.Width: obj.width = origin + ratio * end; break; &#125; &#125; return Action; &#125; private Action&lt;float&gt; GenerateUpdater(GObject obj, TweenTarget target, Vector2 end, float duration, TweenEaseType ease) &#123; Vector2 origin = Vector2.zero; switch (target) &#123; case TweenTarget.Position: origin = obj.xy; break; case TweenTarget.Scale: origin = obj.scale; break; case TweenTarget.Size: origin = obj.size; break; &#125; void Action(float time) &#123; float ratio = EaseUtil.Evaluate(ease, time, duration, 1.7f, 0); switch (target) &#123; case TweenTarget.Position: obj.xy = origin + ratio * end; break; case TweenTarget.Scale: obj.scale = origin + ratio * end; break; case TweenTarget.Size: obj.size = origin + ratio * end; break; &#125; &#125; return Action; &#125;&#125; UI 管理器UI 节点UI 管理器UI 节点通过树结构进行存储。 逻辑情况下，同级 UI 在同一个节点下，子级 UI 在其添加的节点下。 UI 元素情况下，级数相同的 UI 在同一个 Layer 元素（GComponent）下。 这样就可以在同一个层级中进行置顶操作并不影响其他层级的 UI。 123456789101112131415161718192021222324using System.Collections.Generic;public class UINode&#123; /// &lt;summary&gt; /// 父节点 /// &lt;/summary&gt; public UINode parent; /// &lt;summary&gt; /// 层级索引 /// &lt;/summary&gt; public int layer; /// &lt;summary&gt; /// 所属UI /// &lt;/summary&gt; public BaseView ui; /// &lt;summary&gt; /// 子节点 /// &lt;/summary&gt; public Dictionary&lt;string, UINode&gt; children = new Dictionary&lt;string, UINode&gt;();&#125;UI 管理器封装 UI 常用操作。 展示 UI，如果传入 UINode，则在该节点下展示，否则在根节点下展示 UI。如果有保存过 UI，则直接展示保存的 UI。 隐藏 | 销毁 UI，根据树结构，遍历子节点执行相同操作。 查找 UI，如果传入 UINode，则从该节点开始查找，否则从根节点开始查找。 以下为 BaseView 自动执行的操作，无需主动调用： ResetTop，原理是利用 FGUI 的 AddChild 重新插入 UI 元素，使其置顶显示。 SetModel，设置模态背景，原理是在当前需要模态的 UI 元素的位置插入一个 GGraph 对象，当前 UI 元素会在原来索引 +1 的位置，这样就保证背景在 UI 元素下方并且不受 UI 元素窗口的影响。 SaveNode，利用字典保存 UI 界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188using System;using System.Collections.Generic;using FairyGUI;public class UIManager : Singleton&lt;UIManager&gt;&#123; private UINode _root = new UINode(); private int _id = 0; private List&lt;GComponent&gt; _layer = new List&lt;GComponent&gt;(); private Dictionary&lt;string, UINode&gt; _savedView = new Dictionary&lt;string, UINode&gt;(); /// &lt;summary&gt; /// 展示UI /// &lt;/summary&gt; /// &lt;param name=&quot;folder&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;package&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public UINode ShowUI&lt;T&gt;(string folder, string package, string name, UINode parent = null) where T : BaseView, new() &#123; //有保存的UI直接展示并返回 if (_savedView.TryGetValue(name, out var node)) &#123; node.ui.Show(); return node; &#125; //创建没保存的UI Type type = typeof(T); //包加载逻辑暂时加载Resources文件夹内文件 如有需要可自行修改 string packagePath = folder + &quot;/&quot; + package; UIPackage.AddPackage(packagePath); //创建UI T view = new T(); view.id = &quot;ui_&quot; + _id++; view.name = name; view.main = UIPackage.CreateObject(package, type.Name).asCom; //创建UI节点 UINode ui = new UINode(); ui.ui = view; if (parent != null) &#123; int layerIndex = parent.layer + 1; if (_layer.Count - 1 == parent.layer) &#123; GComponent layer = new GComponent(); layer.displayObject.gameObject.name = &quot;Layer_&quot; + layerIndex; GRoot.inst.AddChild(layer); _layer.Add(layer); &#125; _layer[layerIndex].AddChild(view.main); parent.children.Add(view.id, ui); ui.parent = parent; ui.layer = layerIndex; &#125; else &#123; if (_layer.Count == 0) &#123; GComponent layer = new GComponent(); layer.displayObject.gameObject.name = &quot;Layer_0&quot;; GRoot.inst.AddChild(layer); _layer.Add(layer); &#125; _layer[0].AddChild(view.main); _root.children.Add(view.id, ui); ui.parent = _root; ui.layer = 0; &#125; view.uiNode = ui; view.InitConfig(); view.OnAwake(); view.Show(); return ui; &#125; /// &lt;summary&gt; /// 隐藏UI /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;&lt;/param&gt; public void HideUI(UINode ui) &#123; foreach (var child in ui.children) &#123; UINode uiChild = child.Value; HideUI(uiChild); &#125; ui.ui.Hide(); &#125; /// &lt;summary&gt; /// 根据名字获取UI /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;parent&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public UINode GetUI(string name, UINode parent = null) &#123; if (parent == null) &#123; parent = _root; &#125; if (parent.ui != null &amp;&amp; name == parent.ui.name) &#123; return parent; &#125; UINode node; foreach (var child in parent.children) &#123; node = GetUI(name, child.Value); if (node != null) &#123; return node; &#125; &#125; return null; &#125; /// &lt;summary&gt; /// 销毁UI /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;&lt;/param&gt; public void DisposeUI(UINode ui) &#123; foreach (var child in ui.children) &#123; UINode uiChild = child.Value; DisposeUI(uiChild); &#125; //移除保存的节点 _savedView.Remove(ui.ui.name); ui.children = null; ui.parent = null; ui.ui.Dispose(); &#125; /// &lt;summary&gt; /// 重新置于上层 /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;&lt;/param&gt; public void ResetTop(UINode ui) &#123; _layer[ui.layer].AddChild(ui.ui.main); &#125; /// &lt;summary&gt; /// 设置模态背景 /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;model&quot;&gt;&lt;/param&gt; public void SetModel(UINode ui, GGraph model) &#123; GComponent layer = _layer[ui.layer]; int index = layer.GetChildIndex(ui.ui.main); layer.AddChildAt(model, index); &#125; /// &lt;summary&gt; /// 保存节点 需要ui名称唯一 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;ui&quot;&gt;&lt;/param&gt; public void SaveNode(string name, UINode ui) &#123; _savedView[name] = ui; &#125;&#125; BaseView 生命周期flowchart TB; subgraph A[\"OnAwake 生命周期\"] OnAwake --> Bind --> BindClass; end subgraph B[\"Show 生命周期\"] Show --> TweenIn --> OnShow; end subgraph C[\"Hide 生命周期\"] Hide --> TweenOut --> OnHide; end InitConfig --> A; A --> B; B --> C; C --> Dispose; Show 和 Hide 方法每次显示隐藏的时候都会调用。 InitConfig 和 OnAwake 方法只有在第一次创建窗口的时候会调用。 可以重写的生命周期： InitConfig: 初始化配置。 OnShow: UI 展示事件。 OnHide: UI 隐藏事件。 TweenIn: 展示缓动。 TweenOut: 隐藏缓动。 使用展示基本功能 双向绑定 拖拽 ↑ 代理拖拽 ↑ ↑ 自体拖拽 ↑ ↑ List 拖拽 | 手动设置拖拽 ↑ 窗口缓动 悬浮窗 下拉框 窗口拖拽和顶层重置 UI 树 模态窗口 使用方法请转到ReflectionBindUI 文档查看。 代码 详细代码 StringUIProp StringUIProp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using System;public class StringUIProp&#123; public string _value; private string val &#123; get &#123; return _value; &#125; set &#123; _value = value; InvokeUI(); &#125; &#125; private Action&lt;string&gt; _onValueChange = null; private Func&lt;string&gt; _onUIChange = null; public StringUIProp() &#123; &#125; public StringUIProp(string value) &#123; _value = value; &#125; public void Set(string value) &#123; this.val = value; &#125; public void Set&lt;T&gt;(T value) &#123; this.val = value.ToString(); &#125; public string Get() &#123; InvokeValue(); return this.val; &#125; public void InvokeValue() &#123; if (_onUIChange != null) &#123; _value = _onUIChange.Invoke(); &#125; &#125; public void InvokeUI() &#123; _onValueChange?.Invoke(val); &#125; public override string ToString() &#123; return val; &#125;&#125; DoubleUIProp DoubleUIProp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;public class DoubleUIProp&#123; public double _value; private double val &#123; get &#123; return _value; &#125; set &#123; _value = value; InvokeUI(); &#125; &#125; private Action&lt;double&gt; _onValueChange = null; private Func&lt;double&gt; _onUIChange = null; public DoubleUIProp() &#123; &#125; public DoubleUIProp(double value) &#123; _value = value; &#125; public void Set(double value) &#123; this.val = value; &#125; public double Get() &#123; InvokeValue(); return this.val; &#125; public void InvokeValue() &#123; if (_onUIChange != null) &#123; _value = _onUIChange.Invoke(); &#125; &#125; public void InvokeUI() &#123; _onValueChange?.Invoke(val); &#125; public override string ToString() &#123; return val.ToString(); &#125;&#125; UIListProp UIListProp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class UIListProp&lt;T&gt;&#123; private List&lt;T&gt; _value; private List&lt;T&gt; val &#123; get &#123; return _value; &#125; set &#123; _value = value; Invoke(); &#125; &#125; public int Count &#123; get; set; &#125; private Action&lt;int&gt; _onValueChange = null; public UIListProp() &#123; &#125; public UIListProp(List&lt;T&gt; value) &#123; //this.val = value; _value = value; &#125; public List&lt;T&gt; Get() &#123; return val; &#125; public void Set(List&lt;T&gt; value) &#123; val = value; Count = val.Count; &#125; public void Invoke() &#123; if (val != null) &#123; _onValueChange?.Invoke(val.Count); &#125; &#125; public override string ToString() &#123; string res = &quot;[&quot;; foreach (var item in val) &#123; res += item.ToString() + &quot;,&quot;; &#125; res += &quot;]&quot;; return res; &#125;&#125; 绑定特性 UICompBind12345678910111213141516171819using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 绑定UI组件/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Property)]public class UICompBind :Attribute&#123; public string _type; public string _path; public UICompBind(string type,string path) &#123; _type = type; _path = path; &#125;&#125;UIDataBind123456789101112131415161718using System;/// &lt;summary&gt;/// 绑定UI组件和数据，使其根据数据修改UI/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Property)]public class UIDataBind : Attribute&#123; public string _type; public string _path; public string[] _extra; public UIDataBind(string type, string path, params string[] extra) &#123; _type = type; _path = path; _extra = extra; &#125;&#125;UIActionBind12345678910111213141516171819202122using System;/// &lt;summary&gt;/// 绑定UI组件和动作事件，使其支持交互/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Method)]public class UIActionBind : Attribute&#123; public string _type; public string _path; public string[] _extra; public UIActionBind(string type,string path,params string[] extra) &#123; _type = type; _path = path; _extra = extra; &#125;&#125;UIListenerBind123456789101112131415161718using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 绑定UI监听事件/// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Method)]public class UIListenerBind : Attribute&#123; public string _name; public UIListenerBind(string name) &#123; _name = name; &#125;&#125; UIBase UIBase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840using FairyGUI;using System;using System.Collections;using System.Collections.Generic;using System.Reflection;using UnityEngine;/// &lt;summary&gt;/// UI内部元素基类/// &lt;/summary&gt;public class UIBase&#123; /// &lt;summary&gt; /// 界面UI根元素 /// &lt;/summary&gt; public GComponent main; /// &lt;summary&gt; /// 界面id /// &lt;/summary&gt; public string id; /// &lt;summary&gt; /// 界面名 /// &lt;/summary&gt; public string name; /// &lt;summary&gt; /// 当前类的类型 /// &lt;/summary&gt; protected Type _type; /// &lt;summary&gt; /// 反射范围标志 /// &lt;/summary&gt; private readonly BindingFlags _flag = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; //----- 内建私有变量 ----- /// &lt;summary&gt; /// 拖拽元素字典，用于保存元素的拖拽状态 /// &lt;/summary&gt; private readonly Dictionary&lt;string, bool&gt; _dropDic = new Dictionary&lt;string, bool&gt;(); /// &lt;summary&gt; /// 代理拖拽元素 /// &lt;/summary&gt; private GameObject _copy; /// &lt;summary&gt; /// 当前代理拖拽脚本 /// &lt;/summary&gt; private UIDrag _uiDrag; /// &lt;summary&gt; /// 拖拽数据 /// &lt;/summary&gt; private readonly ArrayList _dropData = new ArrayList(); /// &lt;summary&gt; /// 浮动窗口id /// &lt;/summary&gt; private int _floatId = 0; /// &lt;summary&gt; /// 浮动窗口字典，用于保存所有浮动窗口 /// &lt;/summary&gt; private Dictionary&lt;string, BaseView&gt; _floatViews = new Dictionary&lt;string, BaseView&gt;(); /// &lt;summary&gt; /// 正在显示的悬浮窗 /// &lt;/summary&gt; private BaseView _floatViewOnShow = null; protected void Bind() &#123; _type = GetType(); PropertyInfo[] props = _type.GetProperties(_flag); MethodInfo[] methods = _type.GetMethods(_flag); foreach (var method in methods) &#123; var methodAttrs = method.GetCustomAttributes(true); foreach (var attr in methodAttrs) &#123; if (attr is UIActionBind) &#123; BindAction(method, attr); &#125; else if (attr is UIListenerBind) &#123; BindListener(method, attr); &#125; &#125; &#125; foreach (var prop in props) &#123; var propAttrs = prop.GetCustomAttributes(true); foreach (var attr in propAttrs) &#123; if (attr is UICompBind) &#123; BindComp(prop, attr); &#125; else if (attr is UIDataBind) &#123; BindData(prop, attr); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 绑定组件 /// &lt;/summary&gt; /// &lt;param name=&quot;prop&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;attr&quot;&gt;&lt;/param&gt; private void BindComp(PropertyInfo prop, object attr) &#123; UICompBind uiBind = (UICompBind)attr; switch (uiBind._type) &#123; case UIType.Comp: GComponent comp = FguiUtils.GetUI&lt;GComponent&gt;(main, uiBind._path); prop.SetValue(this, comp); break; case UIType.TextField: GTextField textField = FguiUtils.GetUI&lt;GTextField&gt;(main, uiBind._path); prop.SetValue(this, textField); break; case UIType.TextInput: GTextInput textInput = FguiUtils.GetUI&lt;GTextInput&gt;(main, uiBind._path); prop.SetValue(this, textInput); break; case UIType.Image: GImage image = FguiUtils.GetUI&lt;GImage&gt;(main, uiBind._path); prop.SetValue(this, image); break; case UIType.Loader: GLoader loader = FguiUtils.GetUI&lt;GLoader&gt;(main, uiBind._path); prop.SetValue(this, loader); break; case UIType.List: GList list = FguiUtils.GetUI&lt;GList&gt;(main, uiBind._path); prop.SetValue(this, list); break; case UIType.Slider: GSlider slider = FguiUtils.GetUI&lt;GSlider&gt;(main, uiBind._path); prop.SetValue(this,slider); break; case UIType.ComboBox: GComboBox comboBox = FguiUtils.GetUI&lt;GComboBox&gt;(main, uiBind._path); prop.SetValue(this,comboBox); break; &#125; &#125; /// &lt;summary&gt; /// 绑定 组件-数据 /// &lt;/summary&gt; /// &lt;param name=&quot;prop&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;attr&quot;&gt;&lt;/param&gt; private void BindData(PropertyInfo prop, object attr) &#123; UIDataBind uiBind = (UIDataBind)attr; //获取双向绑定委托 var onValueChange = prop.PropertyType.GetField(&quot;_onValueChange&quot;, _flag); var onUIChange = prop.PropertyType.GetField(&quot;_onUIChange&quot;, _flag); var value = prop.GetValue(this); if (value == null) &#123; //初始化当前属性的值 Type propType = prop.PropertyType; if (propType == typeof(StringUIProp)) &#123; value = new StringUIProp(); &#125; else if (propType == typeof(DoubleUIProp)) &#123; value = new DoubleUIProp(); &#125; else &#123; //创建List Type genericType = typeof(UIListProp&lt;&gt;).MakeGenericType(prop.PropertyType.GenericTypeArguments); value = Activator.CreateInstance(genericType); &#125; prop.SetValue(this, value); &#125; switch (uiBind._type) &#123; case UIType.TextField: GTextField textField = FguiUtils.GetUI&lt;GTextField&gt;(main, uiBind._path); void ActionText(string data) &#123; textField.text = data; &#125; string ActionTextUI() &#123; return textField.text; &#125; onValueChange?.SetValue(value, (Action&lt;string&gt;)ActionText); onUIChange?.SetValue(value, (Func&lt;string&gt;)ActionTextUI); break; case UIType.TextInput: GTextInput textInput = FguiUtils.GetUI&lt;GTextInput&gt;(main, uiBind._path); void ActionInput(string data) &#123; textInput.text = data; &#125; string ActionInputUI() &#123; return textInput.text; &#125; onValueChange?.SetValue(value, (Action&lt;string&gt;)ActionInput); onUIChange?.SetValue(value, (Func&lt;string&gt;)ActionInputUI); break; case UIType.Image: GImage image = FguiUtils.GetUI&lt;GImage&gt;(main, uiBind._path); void ActionImage(string data) &#123; image.icon = data; &#125; string ActionImageUI() &#123; return image.icon; &#125; onValueChange?.SetValue(value, (Action&lt;string&gt;)ActionImage); onUIChange?.SetValue(value, (Func&lt;string&gt;)ActionImageUI); break; case UIType.Loader: GLoader loader = FguiUtils.GetUI&lt;GLoader&gt;(main, uiBind._path); void ActionLoader(string data) &#123; loader.url = data; // ConsoleUtils.Log(&quot;替换图片&quot;, loader?.url); &#125; string ActionLoaderUI() &#123; return loader.url; &#125; onValueChange?.SetValue(value, (Action&lt;string&gt;)ActionLoader); onUIChange?.SetValue(value, (Func&lt;string&gt;)ActionLoaderUI); break; case UIType.List: GList list = FguiUtils.GetUI&lt;GList&gt;(main, uiBind._path); void ActionList(int data) &#123; list.SetVirtual(); list.numItems = data; if (uiBind._extra.Length &gt; 0) &#123; switch (uiBind._extra[0]) &#123; case &quot;height&quot;: if (list.numChildren &gt; 0) &#123; list.height = data * list.GetChildAt(0).height + list.lineGap * (data - 1) + list.margin.top + list.margin.bottom; &#125; break; case &quot;width&quot;: if (list.numChildren &gt; 0) &#123; list.width = data * list.GetChildAt(0).width + list.columnGap * (data - 1) + list.margin.left + list.margin.right; &#125; break; &#125; &#125; &#125; onValueChange?.SetValue(value, (Action&lt;int&gt;)ActionList); break; case UIType.Slider: GSlider slider = FguiUtils.GetUI&lt;GSlider&gt;(main, uiBind._path); void ActionSlider(double data) &#123; slider.value = data; &#125; double ActionSliderUI() &#123; return slider.value; &#125; onValueChange?.SetValue(value, (Action&lt;double&gt;)ActionSlider); onUIChange?.SetValue(value, (Func&lt;double&gt;)ActionSliderUI); break; case UIType.ComboBox: GComboBox comboBox = FguiUtils.GetUI&lt;GComboBox&gt;(main, uiBind._path); comboBox.items = uiBind._extra; void ActionComboBox(double data) &#123; comboBox.selectedIndex = (int)data; &#125; double ActionComboBoxUI() &#123; return comboBox.selectedIndex; &#125; onValueChange?.SetValue(value, (Action&lt;double&gt;)ActionComboBox); onUIChange?.SetValue(value, (Func&lt;double&gt;)ActionComboBoxUI); break; &#125; &#125; /// &lt;summary&gt; /// 绑定 组件-行为 /// &lt;/summary&gt; /// &lt;param name=&quot;method&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;attr&quot;&gt;&lt;/param&gt; private void BindAction(MethodInfo method, object attr) &#123; UIActionBind uiBind = (UIActionBind)attr; GObject obj = FguiUtils.GetUI&lt;GObject&gt;(main, uiBind._path); //获取方法的参数 ParameterInfo[] methodParamsList; bool isAgent; Delegate action; switch (uiBind._type) &#123; case UIAction.Click: methodParamsList = method.GetParameters(); if (methodParamsList.Length == 0) &#123; action = Delegate.CreateDelegate(typeof(EventCallback0), this, method); obj.onClick.Set((EventCallback0)action); &#125; else &#123; action = Delegate.CreateDelegate(typeof(EventCallback1), this, method); obj.onClick.Set((EventCallback1)action); &#125; break; case UIAction.ListRender: action = Delegate.CreateDelegate(typeof(ListItemRenderer), this, method); obj.asList.itemRenderer = (ListItemRenderer)action; break; case UIAction.ListProvider: action = Delegate.CreateDelegate(typeof(ListItemProvider), this, method); obj.asList.itemProvider = (ListItemProvider)action; break; case UIAction.ListClick: methodParamsList = method.GetParameters(); if (methodParamsList.Length == 0) &#123; action = Delegate.CreateDelegate(typeof(EventCallback0), this, method); obj.asList.onClickItem.Set((EventCallback0)action); &#125; else &#123; action = Delegate.CreateDelegate(typeof(EventCallback1), this, method); obj.asList.onClickItem.Set((EventCallback1)action); &#125; break; case UIAction.DragStart: obj.draggable = true; isAgent = uiBind._extra.Length == 0 || uiBind._extra[0] == &quot;Self&quot;; SetDragListener(obj, 0, method, isAgent); break; case UIAction.DragHold: obj.draggable = true; isAgent = uiBind._extra.Length == 0 || uiBind._extra[0] == &quot;Self&quot;; SetDragListener(obj, 1, method, isAgent); break; case UIAction.DragEnd: obj.draggable = true; isAgent = uiBind._extra.Length == 0 || uiBind._extra[0] != &quot;Self&quot;; SetDragListener(obj, 2, method, isAgent); break; case UIAction.Drop: action = (Action&lt;object&gt;)Delegate.CreateDelegate(typeof(Action&lt;object&gt;), this, method); _dropDic[obj.id] = true; EventManager.AddListening(obj.id, &quot;OnDrop_&quot; + obj.id, data =&gt; ((Action&lt;object&gt;)action).Invoke(data)); break; case UIAction.Hover: methodParamsList = method.GetParameters(); if (methodParamsList.Length == 0) &#123; action = Delegate.CreateDelegate(typeof(EventCallback0), this, method); obj.onRollOver.Set((EventCallback0)action); &#125; else &#123; action = Delegate.CreateDelegate(typeof(EventCallback1), this, method); obj.onRollOver.Set((EventCallback1)action); &#125; obj.onRollOver.Add(() =&gt; &#123; if (_floatViewOnShow != null) &#123; if (_floatViewOnShow.main.displayObject.gameObject.GetComponent&lt;UIFollow&gt;() != null) &#123; _floatViewOnShow.main.xy = FguiUtils.GetMousePosition(); &#125; else &#123; _floatViewOnShow.main.xy = obj.xy; &#125; _floatViewOnShow.Show(); &#125; &#125;); //退出隐藏 obj.onRollOut.Set(() =&gt; &#123; _floatViewOnShow?.Hide(); _floatViewOnShow = null; &#125;); break; case UIAction.Slider: methodParamsList = method.GetParameters(); if (methodParamsList.Length == 0) &#123; action = Delegate.CreateDelegate(typeof(EventCallback0), this, method); obj.asSlider.onChanged.Set((EventCallback0)action); &#125; else &#123; action = Delegate.CreateDelegate(typeof(EventCallback1), this, method); obj.asSlider.onChanged.Set((EventCallback1)action); &#125; break; case UIAction.ComboBox: methodParamsList = method.GetParameters(); if (methodParamsList.Length == 0) &#123; action = Delegate.CreateDelegate(typeof(EventCallback0), this, method); obj.asComboBox.onChanged.Set((EventCallback0)action); &#125; else &#123; action = Delegate.CreateDelegate(typeof(EventCallback1), this, method); obj.asComboBox.onChanged.Set((EventCallback1)action); &#125; break; &#125; &#125; /// &lt;summary&gt; /// 绑定监听 /// &lt;/summary&gt; /// &lt;param name=&quot;method&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;attr&quot;&gt;&lt;/param&gt; private void BindListener(MethodInfo method, object attr) &#123; UIListenerBind uiBind = (UIListenerBind)attr; var eventFunc = Delegate.CreateDelegate(typeof(Action&lt;ArrayList&gt;), this, method); EventManager.AddListening(id, uiBind._name, (Action&lt;ArrayList&gt;)eventFunc); &#125; private void ClearDropData() &#123; _dropData.Clear(); &#125; /// &lt;summary&gt; /// 添加放置数据 /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; protected void AddDropData(object data) &#123; _dropData.Add(data); &#125; /// &lt;summary&gt; /// 设置拖拽，用于list内元素 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; protected void SetDrag(UIAction type, GObject obj, Action dragAction) &#123; obj.draggable = true; Action action = () =&gt; &#123; //停止本次滚动 obj.parent.asList.scrollPane.CancelDragging(); dragAction(); &#125;; switch (type) &#123; case UIAction.DragStart: SetDragListener(obj, 0, action); break; case UIAction.DragHold: SetDragListener(obj, 1, action); break; case UIAction.DragEnd: SetDragListener(obj, 2, action); break; &#125; &#125; protected void SetDrop(GObject obj, Action&lt;object&gt; action) &#123; _dropDic[obj.id] = true; EventManager.AddListening(obj.id, &quot;OnDrop_&quot; + obj.id, data =&gt; action(_dropData)); &#125; /// &lt;summary&gt; /// 添加放置数据 /// &lt;/summary&gt; /// &lt;param name=&quot;datas&quot;&gt;&lt;/param&gt; protected void AddDropData(params object[] datas) &#123; foreach (var data in datas) &#123; _dropData.Add(data); &#125; &#125; /// &lt;summary&gt; /// 展示悬浮窗 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;悬浮窗名&lt;/param&gt; /// &lt;param name=&quot;follow&quot;&gt;是否跟随&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; protected void ShowFloatView&lt;T&gt;(string name, bool follow = false) where T : BaseView, new() &#123; BaseView view; _floatViews.TryGetValue(name, out view); if (view == null) &#123; view = new T(); string uiName = typeof(T).Name; view.id = &quot;float_view_&quot; + _floatId++; view.name = name; view.main = UIPackage.CreateObject(&quot;Test&quot;, uiName).asCom; view.main.touchable = false; if (follow) &#123; UIFollow uiFollow = view.main.displayObject.gameObject.AddComponent&lt;UIFollow&gt;(); uiFollow.SetObj(view.main, main); &#125; main.AddChild(view.main); view.OnAwake(); _floatViews.Add(name, view); &#125; _floatViewOnShow = view; &#125; /// &lt;summary&gt; /// 添加拖拽监听代理 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;拖拽UI&lt;/param&gt; /// &lt;param name=&quot;type&quot;&gt;拖拽类型 0:start,1:hold,2:end&lt;/param&gt; /// &lt;param name=&quot;method&quot;&gt;拖拽回调&lt;/param&gt; /// &lt;param name=&quot;isAgent&quot;&gt;是否代理拖拽&lt;/param&gt; private void SetDragListener(GObject obj, int type, MethodInfo method, bool isAgent) &#123; ParameterInfo[] methodParamsList = method.GetParameters(); var drag = Delegate.CreateDelegate( methodParamsList.Length == 0 ? typeof(EventCallback0) : typeof(EventCallback1), this, method); if (isAgent) &#123; obj.onDragStart.Add(context =&gt; &#123; context.PreventDefault(); //复制UI GameObject origin = obj.displayObject.gameObject; _copy = GameObject.Instantiate(origin, main.displayObject.gameObject.transform, true); CompClone(_copy.transform, origin.transform); //同步属性 _copy.transform.localPosition = origin.transform.localPosition; _copy.transform.localScale = origin.transform.localScale; _copy.transform.localRotation = origin.transform.localRotation; //拖拽跟随逻辑 _uiDrag = _copy.AddComponent&lt;UIDrag&gt;(); _uiDrag.SetOriginMousePos(); Action action = () =&gt; &#123; //清除放置数据 ClearDropData(); if (methodParamsList.Length == 0) &#123; ((EventCallback0)drag).Invoke(); &#125; else &#123; ((EventCallback1)drag).Invoke(null); &#125; &#125;; switch (type) &#123; case 0: _uiDrag.SetStart(action); break; case 1: _uiDrag.SetUpdate(action); break; case 2: _uiDrag.SetEnd(action); break; &#125; AddDropListener(obj); RemoveDragAgent(); &#125;); &#125; else &#123; if (methodParamsList.Length == 0) &#123; EventCallback0 action = () =&gt; &#123; //清除放置数据 ClearDropData(); ((EventCallback0)drag).Invoke(); &#125;; //监听鼠标拖拽 switch (type) &#123; case 0: obj.onDragStart.Set(action); break; case 1: obj.onDragMove.Set(action); break; case 2: obj.onDragEnd.Set(action); break; &#125; &#125; else &#123; EventCallback1 action = context =&gt; &#123; //清除放置数据 ClearDropData(); ((EventCallback1)drag).Invoke(context); &#125;; //监听鼠标拖拽 switch (type) &#123; case 0: obj.onDragStart.Set(action); break; case 1: obj.onDragMove.Set(action); break; case 2: obj.onDragEnd.Set(action); break; &#125; &#125; AddDropListener(obj); &#125; &#125; /// &lt;summary&gt; /// 设置拖拽监听 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;拖拽UI&lt;/param&gt; /// &lt;param name=&quot;type&quot;&gt;拖拽类型 0:start,1:hold,2:end&lt;/param&gt; /// &lt;param name=&quot;dragAction&quot;&gt;拖拽回调&lt;/param&gt; private void SetDragListener(GObject obj, int type, Action dragAction) &#123; obj.onDragStart.Add(context =&gt; &#123; context.PreventDefault(); //复制UI GameObject origin = obj.displayObject.gameObject; _copy = GameObject.Instantiate(origin, main.displayObject.gameObject.transform, true); CompClone(_copy.transform, origin.transform); //同步属性 _copy.transform.position = origin.transform.position; _copy.transform.localScale = origin.transform.localScale; _copy.transform.rotation = origin.transform.rotation; //拖拽跟随逻辑 _uiDrag = _copy.AddComponent&lt;UIDrag&gt;(); _uiDrag.SetOriginMousePos(); Action action = () =&gt; &#123; //清除放置数据 ClearDropData(); dragAction.Invoke(); &#125;; switch (type) &#123; case 0: _uiDrag.SetStart(action); break; case 1: _uiDrag.SetUpdate(action); break; case 2: _uiDrag.SetEnd(action); break; &#125; AddDropListener(obj); RemoveDragAgent(); &#125;); &#125; /// &lt;summary&gt; /// 添加放置监听 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;放置UI&lt;/param&gt; private void AddDropListener(GObject obj) &#123; if (_uiDrag) &#123; _uiDrag.AddEnd(() =&gt; &#123; GObject target = GRoot.inst.touchTarget; while (target != null) &#123; if (_dropDic.ContainsKey(target.id)) &#123; EventManager.TriggerEvent(&quot;OnDrop_&quot; + target.id, _dropData); return; &#125; target = target.parent; &#125; &#125;); &#125; else &#123; obj.onDragEnd.Add(() =&gt; &#123; GObject target = GRoot.inst.touchTarget; while (target != null) &#123; if (_dropDic.ContainsKey(target.id)) &#123; EventManager.TriggerEvent(&quot;OnDrop_&quot; + target.id, _dropData); return; &#125; target = target.parent; &#125; &#125;); &#125; &#125; /// &lt;summary&gt; /// 移除拖拽监听代理 /// &lt;/summary&gt; private void RemoveDragAgent() &#123; if (_uiDrag) &#123; _uiDrag.AddEnd(() =&gt; &#123; _copy = null; _uiDrag = null; &#125;); &#125; &#125; /// &lt;summary&gt; /// 代理组件克隆及处理 /// &lt;/summary&gt; /// &lt;param name=&quot;transCopy&quot;&gt;克隆体transform&lt;/param&gt; /// &lt;param name=&quot;transOrigin&quot;&gt;原型transform&lt;/param&gt; private void CompClone(Transform transCopy, Transform transOrigin) &#123; MeshFilter filter = transCopy.GetComponent&lt;MeshFilter&gt;(); MeshRenderer renderer = transCopy.GetComponent&lt;MeshRenderer&gt;(); if (filter) &#123; filter.mesh = transOrigin.GetComponent&lt;MeshFilter&gt;().mesh; &#125; if (renderer) &#123; // renderer.materials = transOrigin.GetComponent&lt;MeshRenderer&gt;().materials; Material[] origin = transOrigin.GetComponent&lt;MeshRenderer&gt;().materials; Material[] copy = new Material[origin.Length]; for (int i = 0; i &lt; origin.Length; i++) &#123; copy[i] = new Material(origin[i]); &#125; renderer.materials = copy; renderer.sortingOrder = 9999; &#125; if (transCopy.childCount &gt; 0) &#123; for (int i = 0; i &lt; transCopy.childCount; i++) &#123; CompClone(transCopy.GetChild(i), transOrigin.GetChild(i)); &#125; &#125; &#125;&#125; BaseView 该类没有自动执行的方法，请自行接管生命周期BaseView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288using System;using System.Reflection;using FairyGUI;using UnityEngine;/// &lt;summary&gt;/// UI界面基类/// &lt;/summary&gt;public class BaseView : UIBase&#123; /// &lt;summary&gt; /// UI节点 /// &lt;/summary&gt; public UINode uiNode; /// &lt;summary&gt; /// 缓动最大持续时间 /// &lt;/summary&gt; private int _duration; /// &lt;summary&gt; /// 模态背景 /// &lt;/summary&gt; private GGraph _model; /// &lt;summary&gt; /// 是否保存节点 默认保存 /// &lt;/summary&gt; private bool _isSaveNode = true; public void OnAwake() &#123; if (_isSaveNode) &#123; //保存节点 UIManager.Ins().SaveNode(name, uiNode); &#125; //绑定UI元素 Bind(); //绑定类 var classAttributes = _type.GetCustomAttributes(); foreach (var attr in classAttributes) &#123; if (attr is UIClassBind) &#123; BindClass(attr); &#125; &#125; &#125; /// &lt;summary&gt; /// 展示UI /// &lt;/summary&gt; public void Show() &#123; TweenIn(); DoTween(true); &#125; /// &lt;summary&gt; /// 隐藏UI /// &lt;/summary&gt; public void Hide() &#123; TweenOut(); DoTween(false); &#125; /// &lt;summary&gt; /// 销毁UI /// &lt;/summary&gt; public void Dispose() &#123; main.Dispose(); &#125; /// &lt;summary&gt; /// 获取UI显示情况 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool GetVisible() &#123; return main.visible; &#125; /// &lt;summary&gt; /// 设置UI显示情况 /// &lt;/summary&gt; /// &lt;param name=&quot;visible&quot;&gt;&lt;/param&gt; public void SetVisible(bool visible) &#123; main.visible = visible; &#125; /// &lt;summary&gt; /// 添加缓动 /// &lt;/summary&gt; /// &lt;param name=&quot;target&quot;&gt;缓动目标属性&lt;/param&gt; /// &lt;param name=&quot;end&quot;&gt;缓动目标值&lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt;持续时间&lt;/param&gt; /// &lt;param name=&quot;ease&quot;&gt;插值函数&lt;/param&gt; /// &lt;param name=&quot;callback&quot;&gt;回调&lt;/param&gt; protected void AddTween(TweenTarget target, float end, int duration, TweenEaseType ease = TweenEaseType.Linear, Action callback = null) &#123; UITweenManager.Ins().AddTween(main, target, end, duration, ease, callback); _duration = duration &lt; _duration ? _duration : duration; &#125; /// &lt;summary&gt; /// 添加缓动 /// &lt;/summary&gt; /// &lt;param name=&quot;target&quot;&gt;缓动目标属性&lt;/param&gt; /// &lt;param name=&quot;end&quot;&gt;缓动目标值&lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt;持续时间&lt;/param&gt; /// &lt;param name=&quot;ease&quot;&gt;插值函数&lt;/param&gt; /// &lt;param name=&quot;callback&quot;&gt;回调&lt;/param&gt; protected void AddTween(TweenTarget target, Vector2 end, int duration, TweenEaseType ease = TweenEaseType.Linear, Action callback = null) &#123; UITweenManager.Ins().AddTween(main, target, end, duration, ease, callback); _duration = duration &lt; _duration ? _duration : duration; &#125; /// &lt;summary&gt; /// 每次展示的时候执行 /// &lt;/summary&gt; protected virtual void OnShow() &#123; &#125; /// &lt;summary&gt; /// 每次隐藏的时候执行 /// &lt;/summary&gt; protected virtual void OnHide() &#123; &#125; /// &lt;summary&gt; /// 进场缓动初始化方法 /// &lt;/summary&gt; protected virtual void TweenIn() &#123; &#125; /// &lt;summary&gt; /// 退场缓动初始化方法 /// &lt;/summary&gt; protected virtual void TweenOut() &#123; &#125; /// &lt;summary&gt; /// 配置初始化 /// &lt;/summary&gt; public virtual void InitConfig() &#123; &#125; /// &lt;summary&gt; /// 执行缓动 /// &lt;/summary&gt; /// &lt;param name=&quot;start&quot;&gt;进场或退场&lt;/param&gt; private void DoTween(bool start) &#123; if (start) &#123; SetVisible(true); AddTween(TweenTarget.None, 0, _duration, TweenEaseType.Linear, OnShow); &#125; else &#123; AddTween(TweenTarget.None, 0, _duration, TweenEaseType.Linear, () =&gt; &#123; main.visible = false; OnHide(); &#125;); &#125; &#125; /// &lt;summary&gt; /// 绑定 类 /// &lt;/summary&gt; /// &lt;param name=&quot;attr&quot;&gt;&lt;/param&gt; private void BindClass(object attr) &#123; UIClassBind uiClassBind = (UIClassBind)attr; switch (uiClassBind.type) &#123; case UIClass.Model: if (_model == null) &#123; //创建模态背景 _model = new GGraph(); _model.displayObject.gameObject.name = id + &quot;_&quot; + name + &quot;_Model&quot;; UIColor colorAttr = _type.GetCustomAttribute&lt;UIColor&gt;(); Color color = new Color(0, 0, 0, 0); if (colorAttr != null) &#123; color = colorAttr.color; &#125; Vector2 size = GRoot.inst.size; _model.DrawRect(size.x, size.y, 0, new Color(), color); &#125; UIManager.Ins().SetModel(uiNode, _model); if (uiClassBind.extra.Length &gt; 0 &amp;&amp; uiClassBind.extra[0] == &quot;Hide&quot;) &#123; _model.onClick.Set(() =&gt; &#123; Hide(); main.AddChild(_model); &#125;); &#125; break; case UIClass.Drag: bool retop = uiClassBind.extra.Length &gt; 0 &amp;&amp; uiClassBind.extra[0] == &quot;Retop&quot;; if (uiClassBind.extra.Length &gt; 1) &#123; GObject obj = FguiUtils.GetUI&lt;GObject&gt;(main, uiClassBind.extra[1]); obj.draggable = true; bool isTouch = false; bool isOut = true; //监听四个事件，保证拖拽的实时性和严格性 obj.onTouchBegin.Set(() =&gt; &#123; main.draggable = true; isTouch = true; &#125;); obj.onTouchEnd.Set(() =&gt; &#123; if (isOut) &#123; main.draggable = false; &#125; isTouch = false; &#125;); obj.onRollOver.Set(() =&gt; &#123; main.draggable = true; isOut = false; &#125;); obj.onRollOut.Set(() =&gt; &#123; if (!isTouch) &#123; main.draggable = false; &#125; isOut = true; &#125;); //监听置顶 if (retop) &#123; obj.onTouchBegin.Add(() =&gt; &#123; UIManager.Ins().ResetTop(uiNode); &#125;); &#125; &#125; else &#123; //整体拖拽，不需要切换拖拽状态，因此不监听事件 main.draggable = true; //监听置顶 if (retop) &#123; main.onTouchBegin.Set(() =&gt; &#123; UIManager.Ins().ResetTop(uiNode); &#125;); &#125; &#125; break; &#125; &#125;&#125; 拖拽跟随类 UIDrag123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using UnityEngine;public class UIDrag : MonoBehaviour&#123; private Vector3 _originMousePos; private Vector3 _originPos; private Action _onStart; private Action _onUpdate; private Action _onEnd; // Start is called before the first frame update void Start() &#123; _originPos = transform.localPosition; _onStart?.Invoke(); &#125; // Update is called once per frame void Update() &#123; if (Input.GetMouseButton(0)) &#123; transform.localPosition = _originPos + (Input.mousePosition - _originMousePos); _onUpdate?.Invoke(); &#125; else &#123; _onEnd?.Invoke(); Destroy(gameObject); &#125; &#125; public void SetOriginMousePos() &#123; _originMousePos = Input.mousePosition; &#125; public void AddStart(Action start) &#123; _onStart += start; &#125; public void SetStart(Action start) &#123; _onStart = start; &#125; public void AddUpdate(Action update) &#123; _onUpdate += update; &#125; public void SetUpdate(Action update) &#123; _onUpdate = update; &#125; public void AddEnd(Action end) &#123; _onEnd += end; &#125; public void SetEnd(Action end) &#123; _onEnd = end; &#125;&#125; 悬浮窗跟随类 UIFollow12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using FairyGUI;using UnityEngine;public class UIFollow : MonoBehaviour&#123; private GObject _obj; private GObject _parent; void Update() &#123; if (_obj.visible) &#123; _obj.xy = FguiUtils.GetMousePosition(_parent); &#125; &#125; public void SetObj(GObject obj,GObject parent) &#123; _obj = obj; _parent = parent; &#125;&#125; Demo TestView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137using FairyGUI;using System.Collections;using System.Collections.Generic;using UnityEngine;[UIClassBind(UIClass.Drag,&quot;Retop&quot;,&quot;n10&quot;),UIColor(1,1,1,0.5f)]public class TestView : BaseView&#123; [UIDataBind(UIType.TextField, &quot;1&quot;)] private StringUIProp _testText &#123; get; set; &#125; [UIDataBind(UIType.List, &quot;n1&quot;)] private UIListProp&lt;string&gt; _testList &#123; get; set; &#125; [UIDataBind(UIType.Loader, &quot;4&quot;)] private StringUIProp _loaderUrl &#123; get; set; &#125; [UIDataBind(UIType.Slider, &quot;5&quot;)] private DoubleUIProp _slideValue &#123; get; set; &#125; [UIDataBind(UIType.TextInput, &quot;6&quot;)] private StringUIProp _input &#123; get; set; &#125; [UIDataBind(UIType.ComboBox,&quot;9&quot;,&quot;1&quot;,&quot;b&quot;)] private DoubleUIProp _comboBoxIndex &#123; get; set; &#125; [UICompBind(UIType.Loader, &quot;4&quot;)] private GLoader _loader &#123; get; set; &#125; [UIActionBind(UIAction.ListRender, &quot;2&quot;)] private void ItemRenderer(int index, GObject item) &#123; GComponent comp = item as GComponent; GTextField content = comp.GetChildAt(0).asTextField; content.text = _testList.Get()[index]; SetDrag(UIAction.DragStart, comp, () =&gt; &#123; ConsoleUtils.Log(&quot;开始拖拽&quot;); AddDropData(index); &#125;); SetDrop(comp, (object data) =&gt; &#123; ConsoleUtils.Log(&quot;放置&quot;, data); &#125;); &#125; [UIActionBind(UIAction.Click, &quot;3&quot;)] private void OnBtnClick() &#123; ConsoleUtils.Log(&quot;点击了按钮&quot;); _comboBoxIndex.Set(1); EventManager.TriggerEvent(&quot;show_console&quot;, null); &#125; [UIActionBind(UIAction.DragEnd, &quot;3&quot;, &quot;Self&quot;)] private void OnDrag(EventContext context) &#123; //添加拖拽数据 AddDropData(1, 2, &quot;测试数据&quot;); Debug.Log(&quot;结束拖拽&quot;); Debug.Log(GRoot.inst.touchTarget); &#125; [UIActionBind(UIAction.Drop, &quot;4&quot;)] private void OnDrop(object data) &#123; ConsoleUtils.Log(&quot;拖拽放置&quot;, data); &#125; [UIListenerBind(&quot;show_console&quot;)] private void ShowConsole(ArrayList data) &#123; ConsoleUtils.Log(&quot;触发了事件&quot;); _loaderUrl.Set(&quot;ui://Test/Icon&quot;); _testList.Set(new List&lt;string&gt; &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;); // _slideValue.Set(70); ConsoleUtils.Log(_slideValue.Get(), _input.Get()); &#125; [UIActionBind(UIAction.Hover,&quot;7&quot;)] private void ShowHint() &#123; ShowFloatView&lt;HintView&gt;(&quot;input_hint&quot;,&quot;HintView&quot;,true); // ConsoleUtils.Log(&quot;显示悬浮窗&quot;); &#125; [UIActionBind(UIAction.Slider,&quot;5&quot;)] private void OnSliderChanged() &#123; ConsoleUtils.Log(&quot;滑动条&quot;,_slideValue.Get()); &#125; [UIActionBind(UIAction.ComboBox,&quot;9&quot;)] private void OnComboBoxChanged() &#123; ConsoleUtils.Log(&quot;下拉框&quot;,_comboBoxIndex.Get()); &#125; [UIActionBind(UIAction.Click,&quot;n11&quot;)] private void Close() &#123; UIManager.Ins().HideUI(uiNode); // UIManager.Ins().DisposeUI(uiNode); &#125; // protected override void TweenIn() // &#123; // main.x = -500; // AddTween(TweenTarget.X,500,2000,TweenEaseType.CircOut); // // main.y = 500; // AddTween(TweenTarget.Y,-500,2000,TweenEaseType.Linear); // // main.scaleX = 0.5f; // AddTween(TweenTarget.ScaleX,0.5f,2000,TweenEaseType.CircOut); // // AddTween(TweenTarget.Rotation,50,2000,TweenEaseType.CircOut); // &#125; // protected override void OnShow() &#123; ConsoleUtils.Log(&quot;OnShow&quot;,Time.time); &#125; protected override void OnHide() &#123; ConsoleUtils.Log(&quot;OnHide&quot;); &#125; // protected override void TweenOut() // &#123; // AddTween(TweenTarget.X,500,2000,TweenEaseType.CircOut); // &#125;&#125; 窗口缓动 缓动方法 Ease123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250using System;using UnityEngine;public enum TweenEaseType&#123; Linear, SineIn, SineOut, SineInOut, QuadIn, QuadOut, QuadInOut, CubicIn, CubicOut, CubicInOut, QuartIn, QuartOut, QuartInOut, QuintIn, QuintOut, QuintInOut, ExpoIn, ExpoOut, ExpoInOut, CircIn, CircOut, CircInOut, ElasticIn, ElasticOut, ElasticInOut, BackIn, BackOut, BackInOut, BounceIn, BounceOut, BounceInOut, Custom&#125;public class EaseUtil&#123; const float _PiOver2 = Mathf.PI * 0.5f; const float _TwoPi = Mathf.PI * 2; internal static float Evaluate(TweenEaseType TweenEaseType, float time, float duration, float overshootOrAmplitude, float period) &#123; if (duration &lt;= 0) return 1; switch (TweenEaseType) &#123; case TweenEaseType.Linear: return time / duration; case TweenEaseType.SineIn: return -(float)Math.Cos(time / duration * _PiOver2) + 1; case TweenEaseType.SineOut: return (float)Math.Sin(time / duration * _PiOver2); case TweenEaseType.SineInOut: return -0.5f * ((float)Math.Cos(Mathf.PI * time / duration) - 1); case TweenEaseType.QuadIn: return (time /= duration) * time; case TweenEaseType.QuadOut: return -(time /= duration) * (time - 2); case TweenEaseType.QuadInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time; return -0.5f * ((--time) * (time - 2) - 1); case TweenEaseType.CubicIn: return (time /= duration) * time * time; case TweenEaseType.CubicOut: return ((time = time / duration - 1) * time * time + 1); case TweenEaseType.CubicInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time * time; return 0.5f * ((time -= 2) * time * time + 2); case TweenEaseType.QuartIn: return (time /= duration) * time * time * time; case TweenEaseType.QuartOut: return -((time = time / duration - 1) * time * time * time - 1); case TweenEaseType.QuartInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time * time * time; return -0.5f * ((time -= 2) * time * time * time - 2); case TweenEaseType.QuintIn: return (time /= duration) * time * time * time * time; case TweenEaseType.QuintOut: return ((time = time / duration - 1) * time * time * time * time + 1); case TweenEaseType.QuintInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * time * time * time * time * time; return 0.5f * ((time -= 2) * time * time * time * time + 2); case TweenEaseType.ExpoIn: return (time == 0) ? 0 : (float)Math.Pow(2, 10 * (time / duration - 1)); case TweenEaseType.ExpoOut: if (time == duration) return 1; return (-(float)Math.Pow(2, -10 * time / duration) + 1); case TweenEaseType.ExpoInOut: if (time == 0) return 0; if (time == duration) return 1; if ((time /= duration * 0.5f) &lt; 1) return 0.5f * (float)Math.Pow(2, 10 * (time - 1)); return 0.5f * (-(float)Math.Pow(2, -10 * --time) + 2); case TweenEaseType.CircIn: return -((float)Math.Sqrt(1 - (time /= duration) * time) - 1); case TweenEaseType.CircOut: return (float)Math.Sqrt(1 - (time = time / duration - 1) * time); case TweenEaseType.CircInOut: if ((time /= duration * 0.5f) &lt; 1) return -0.5f * ((float)Math.Sqrt(1 - time * time) - 1); return 0.5f * ((float)Math.Sqrt(1 - (time -= 2) * time) + 1); case TweenEaseType.ElasticIn: float s0; if (time == 0) return 0; if ((time /= duration) == 1) return 1; if (period == 0) period = duration * 0.3f; if (overshootOrAmplitude &lt; 1) &#123; overshootOrAmplitude = 1; s0 = period / 4; &#125; else s0 = period / _TwoPi * (float)Math.Asin(1 / overshootOrAmplitude); return -(overshootOrAmplitude * (float)Math.Pow(2, 10 * (time -= 1)) * (float)Math.Sin((time * duration - s0) * _TwoPi / period)); case TweenEaseType.ElasticOut: float s1; if (time == 0) return 0; if ((time /= duration) == 1) return 1; if (period == 0) period = duration * 0.3f; if (overshootOrAmplitude &lt; 1) &#123; overshootOrAmplitude = 1; s1 = period / 4; &#125; else s1 = period / _TwoPi * (float)Math.Asin(1 / overshootOrAmplitude); return (overshootOrAmplitude * (float)Math.Pow(2, -10 * time) * (float)Math.Sin((time * duration - s1) * _TwoPi / period) + 1); case TweenEaseType.ElasticInOut: float s; if (time == 0) return 0; if ((time /= duration * 0.5f) == 2) return 1; if (period == 0) period = duration * (0.3f * 1.5f); if (overshootOrAmplitude &lt; 1) &#123; overshootOrAmplitude = 1; s = period / 4; &#125; else s = period / _TwoPi * (float)Math.Asin(1 / overshootOrAmplitude); if (time &lt; 1) return -0.5f * (overshootOrAmplitude * (float)Math.Pow(2, 10 * (time -= 1)) * (float)Math.Sin((time * duration - s) * _TwoPi / period)); return overshootOrAmplitude * (float)Math.Pow(2, -10 * (time -= 1)) * (float)Math.Sin((time * duration - s) * _TwoPi / period) * 0.5f + 1; case TweenEaseType.BackIn: return (time /= duration) * time * ((overshootOrAmplitude + 1) * time - overshootOrAmplitude); case TweenEaseType.BackOut: return ((time = time / duration - 1) * time * ((overshootOrAmplitude + 1) * time + overshootOrAmplitude) + 1); case TweenEaseType.BackInOut: if ((time /= duration * 0.5f) &lt; 1) return 0.5f * (time * time * (((overshootOrAmplitude *= (1.525f)) + 1) * time - overshootOrAmplitude)); return 0.5f * ((time -= 2) * time * (((overshootOrAmplitude *= (1.525f)) + 1) * time + overshootOrAmplitude) + 2); case TweenEaseType.BounceIn: return Bounce.EaseIn(time, duration); case TweenEaseType.BounceOut: return Bounce.EaseOut(time, duration); case TweenEaseType.BounceInOut: return Bounce.EaseInOut(time, duration); default: return -(time /= duration) * (time - 2); &#125; &#125;&#125;/// &lt;summary&gt;/// This class contains a C# port of the easing equations created by Robert Penner (http://robertpenner.com/easing)./// &lt;/summary&gt;static class Bounce&#123; /// &lt;summary&gt; /// Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in: accelerating from zero velocity. /// &lt;/summary&gt; /// &lt;param name=&quot;time&quot;&gt; /// Current time (in frames or seconds). /// &lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt; /// Expected easing duration (in frames or seconds). /// &lt;/param&gt; /// &lt;returns&gt; /// The eased value. /// &lt;/returns&gt; public static float EaseIn(float time, float duration) &#123; return 1 - EaseOut(duration - time, duration); &#125; /// &lt;summary&gt; /// Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out: decelerating from zero velocity. /// &lt;/summary&gt; /// &lt;param name=&quot;time&quot;&gt; /// Current time (in frames or seconds). /// &lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt; /// Expected easing duration (in frames or seconds). /// &lt;/param&gt; /// &lt;returns&gt; /// The eased value. /// &lt;/returns&gt; public static float EaseOut(float time, float duration) &#123; if ((time /= duration) &lt; (1 / 2.75f)) &#123; return (7.5625f * time * time); &#125; if (time &lt; (2 / 2.75f)) &#123; return (7.5625f * (time -= (1.5f / 2.75f)) * time + 0.75f); &#125; if (time &lt; (2.5f / 2.75f)) &#123; return (7.5625f * (time -= (2.25f / 2.75f)) * time + 0.9375f); &#125; return (7.5625f * (time -= (2.625f / 2.75f)) * time + 0.984375f); &#125; /// &lt;summary&gt; /// Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in/out: acceleration until halfway, then deceleration. /// &lt;/summary&gt; /// &lt;param name=&quot;time&quot;&gt; /// Current time (in frames or seconds). /// &lt;/param&gt; /// &lt;param name=&quot;duration&quot;&gt; /// Expected easing duration (in frames or seconds). /// &lt;/param&gt; /// &lt;returns&gt; /// The eased value. /// &lt;/returns&gt; public static float EaseInOut(float time, float duration) &#123; if (time &lt; duration * 0.5f) &#123; return EaseIn(time * 2, duration) * 0.5f; &#125; return EaseOut(time * 2 - duration, duration) * 0.5f + 0.5f; &#125;&#125; 缓动单元 UITween12345678910111213141516171819202122232425262728293031323334using System;using UnityEngine;public class UITween&#123; public int id; public float duration; private int _time; public bool isStop; public Action&lt;float&gt; updater; public Action callback; public void Update(int delta) &#123; _time += delta; if (_time &lt;= duration) &#123; updater?.Invoke(_time); &#125; else &#123; updater?.Invoke(duration); callback?.Invoke(); isStop = true; updater = null; callback = null; &#125; &#125;&#125; 缓动更新 TweenUpdater12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.Collections.Generic;using UnityEngine;public class TweenUpdater : MonoBehaviour&#123; private Dictionary&lt;int,UITween&gt; _actions = new Dictionary&lt;int,UITween&gt;(); private List&lt;int&gt; _removeActionIndexes = new List&lt;int&gt;(); void Update() &#123; int delta = (int)(Time.deltaTime * 1000); foreach (var action in _actions) &#123; UITween vt = action.Value; if (vt.isStop) &#123; _removeActionIndexes.Add(vt.id); &#125; else &#123; vt.Update(delta); &#125; &#125; for (int i = _removeActionIndexes.Count - 1; i &gt;= 0; i--) &#123; _actions.Remove(_removeActionIndexes[i]); _removeActionIndexes.RemoveAt(i); &#125; &#125; public void AddTween(UITween tween) &#123; _actions.Add(tween.id,tween); &#125; public void StopTween(int id) &#123; UITween tween; _actions.TryGetValue(id, out tween); if (tween != null) &#123; tween.isStop = true; &#125; &#125;&#125; 缓动管理 UITweenManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154using System;using FairyGUI;using UnityEngine;public class UITweenManager : Singleton&lt;UITweenManager&gt;&#123; private TweenUpdater _updater; private int _id = 0; public void Init() &#123; GameObject obj = new GameObject(); obj.name = &quot;TweenUpdater&quot;; _updater = obj.AddComponent&lt;TweenUpdater&gt;(); &#125; public int AddTween(GObject obj, TweenTarget target, float end, int duration, TweenEaseType ease = TweenEaseType.Linear, Action callback = null) &#123; UITween vt = new UITween(); vt.id = _id++; vt.duration = duration; vt.updater = GenerateUpdater(obj, target, end, duration, ease); vt.callback = callback; _updater.AddTween(vt); return vt.id; &#125; public int AddTween(GObject obj, TweenTarget target, Vector2 end, int duration, TweenEaseType ease = TweenEaseType.Linear, Action callback = null) &#123; UITween vt = new UITween(); vt.id = _id++; vt.duration = duration; vt.updater = GenerateUpdater(obj, target, end, duration, ease); vt.callback = callback; _updater.AddTween(vt); return vt.id; &#125; public void StopTween(int id) &#123; _updater.StopTween(id); &#125; private Action&lt;float&gt; GenerateUpdater(GObject obj, TweenTarget target, float end, float duration, TweenEaseType ease) &#123; float origin = 0; switch (target) &#123; case TweenTarget.X: origin = obj.x; break; case TweenTarget.Y: origin = obj.y; break; case TweenTarget.ScaleX: origin = obj.scaleX; break; case TweenTarget.ScaleY: origin = obj.scaleY; break; case TweenTarget.Rotation: origin = obj.rotation; break; case TweenTarget.Alpha: origin = obj.alpha; break; case TweenTarget.Heihgt: origin = obj.height; break; case TweenTarget.Width: origin = obj.width; break; &#125; void Action(float time) &#123; float ratio = EaseUtil.Evaluate(ease, time, duration, 1.7f, 0); switch (target) &#123; case TweenTarget.X: obj.x = origin + ratio * end; break; case TweenTarget.Y: obj.y = origin + ratio * end; break; case TweenTarget.ScaleX: obj.scaleX = origin + ratio * end; break; case TweenTarget.ScaleY: obj.scaleY = origin + ratio * end; break; case TweenTarget.Rotation: obj.rotation = origin + ratio * end; break; case TweenTarget.Alpha: obj.alpha = origin + ratio * end; break; case TweenTarget.Heihgt: obj.height = origin + ratio * end; break; case TweenTarget.Width: obj.width = origin + ratio * end; break; &#125; &#125; return Action; &#125; private Action&lt;float&gt; GenerateUpdater(GObject obj, TweenTarget target, Vector2 end, float duration, TweenEaseType ease) &#123; Vector2 origin = Vector2.zero; switch (target) &#123; case TweenTarget.Position: origin = obj.xy; break; case TweenTarget.Scale: origin = obj.scale; break; case TweenTarget.Size: origin = obj.size; break; &#125; void Action(float time) &#123; float ratio = EaseUtil.Evaluate(ease, time, duration, 1.7f, 0); switch (target) &#123; case TweenTarget.Position: obj.xy = origin + ratio * end; break; case TweenTarget.Scale: obj.scale = origin + ratio * end; break; case TweenTarget.Size: obj.size = origin + ratio * end; break; &#125; &#125; return Action; &#125;&#125; UI 管理器 UINode 123456789101112131415161718192021222324using System.Collections.Generic;public class UINode&#123; /// &lt;summary&gt; /// 父节点 /// &lt;/summary&gt; public UINode parent; /// &lt;summary&gt; /// 层级索引 /// &lt;/summary&gt; public int layer; /// &lt;summary&gt; /// 所属UI /// &lt;/summary&gt; public BaseView ui; /// &lt;summary&gt; /// 子节点 /// &lt;/summary&gt; public Dictionary&lt;string, UINode&gt; children = new Dictionary&lt;string, UINode&gt;();&#125; UIManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188using System;using System.Collections.Generic;using FairyGUI;public class UIManager : Singleton&lt;UIManager&gt;&#123; private UINode _root = new UINode(); private int _id = 0; private List&lt;GComponent&gt; _layer = new List&lt;GComponent&gt;(); private Dictionary&lt;string, UINode&gt; _savedView = new Dictionary&lt;string, UINode&gt;(); /// &lt;summary&gt; /// 展示UI /// &lt;/summary&gt; /// &lt;param name=&quot;folder&quot;&gt;UI所在文件夹&lt;/param&gt; /// &lt;param name=&quot;package&quot;&gt;UI包名&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;自定义名称&lt;/param&gt; /// &lt;param name=&quot;parent&quot;&gt;父节点&lt;/param&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;returns&gt;&lt;/returns&gt; public UINode ShowUI&lt;T&gt;(string folder, string package, string name, UINode parent = null) where T : BaseView, new() &#123; //有保存的UI直接展示并返回 if (_savedView.TryGetValue(name, out var node)) &#123; node.ui.Show(); return node; &#125; //创建没保存的UI Type type = typeof(T); //包加载逻辑暂时加载Resources文件夹内文件 如有需要可自行修改 string packagePath = folder + &quot;/&quot; + package; UIPackage.AddPackage(packagePath); //创建UI T view = new T(); view.id = &quot;ui_&quot; + _id++; view.name = name; view.main = UIPackage.CreateObject(package, type.Name).asCom; //创建UI节点 UINode ui = new UINode(); ui.ui = view; if (parent != null) &#123; int layerIndex = parent.layer + 1; if (_layer.Count - 1 == parent.layer) &#123; GComponent layer = new GComponent(); layer.displayObject.gameObject.name = &quot;Layer_&quot; + layerIndex; GRoot.inst.AddChild(layer); _layer.Add(layer); &#125; _layer[layerIndex].AddChild(view.main); parent.children.Add(view.id, ui); ui.parent = parent; ui.layer = layerIndex; &#125; else &#123; if (_layer.Count == 0) &#123; GComponent layer = new GComponent(); layer.displayObject.gameObject.name = &quot;Layer_0&quot;; GRoot.inst.AddChild(layer); _layer.Add(layer); &#125; _layer[0].AddChild(view.main); _root.children.Add(view.id, ui); ui.parent = _root; ui.layer = 0; &#125; view.uiNode = ui; view.InitConfig(); view.OnAwake(); view.Show(); return ui; &#125; /// &lt;summary&gt; /// 隐藏UI /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;UI节点&lt;/param&gt; public void HideUI(UINode ui) &#123; foreach (var child in ui.children) &#123; UINode uiChild = child.Value; HideUI(uiChild); &#125; ui.ui.Hide(); &#125; /// &lt;summary&gt; /// 根据名字获取UI /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;自定义名称&lt;/param&gt; /// &lt;param name=&quot;parent&quot;&gt;父节点&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public UINode GetUI(string name, UINode parent = null) &#123; if (parent == null) &#123; parent = _root; &#125; if (parent.ui != null &amp;&amp; name == parent.ui.name) &#123; return parent; &#125; UINode node; foreach (var child in parent.children) &#123; node = GetUI(name, child.Value); if (node != null) &#123; return node; &#125; &#125; return null; &#125; /// &lt;summary&gt; /// 销毁UI /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;UI节点&lt;/param&gt; public void DisposeUI(UINode ui) &#123; foreach (var child in ui.children) &#123; UINode uiChild = child.Value; DisposeUI(uiChild); &#125; //移除保存的节点 _savedView.Remove(ui.ui.name); ui.children = null; ui.parent = null; ui.ui.Dispose(); &#125; /// &lt;summary&gt; /// 重新置于上层 /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;UI节点&lt;/param&gt; public void ResetTop(UINode ui) &#123; _layer[ui.layer].AddChild(ui.ui.main); &#125; /// &lt;summary&gt; /// 设置模态背景 /// &lt;/summary&gt; /// &lt;param name=&quot;ui&quot;&gt;UI节点&lt;/param&gt; /// &lt;param name=&quot;model&quot;&gt;模态背景对象&lt;/param&gt; public void SetModel(UINode ui, GGraph model) &#123; GComponent layer = _layer[ui.layer]; int index = layer.GetChildIndex(ui.ui.main); layer.AddChildAt(model, index); &#125; /// &lt;summary&gt; /// 保存节点 需要ui名称唯一 /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;自定义名称&lt;/param&gt; /// &lt;param name=&quot;ui&quot;&gt;UI节点&lt;/param&gt; public void SaveNode(string name, UINode ui) &#123; _savedView[name] = ui; &#125;&#125; 项目 更新日志2024-05-30 因项目逻辑更新，修改相关说明。 2024-04-30 新增 UI 类绑定。新增模态窗口。新增拖拽窗口。新增 UI 管理器。 2024-04-27 新增滑动条 Action、Comp。新增下拉框 Data、Comp 和 Action。 2024-04-25 新增简易窗口缓动动画。新增悬浮窗 Action。 2024-04-21 新增 double 类型数据。新增 UI 数据双向绑定。新增手动设置拖拽和放置方法（用于 List Item）。 2024-04-20 更新拖拽功能。调整部分代码属性域。 2024-02-22 更新基础版本。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Untiy","slug":"Untiy","permalink":"https://busyogg.github.io/tags/Untiy/"},{"name":"UI","slug":"UI","permalink":"https://busyogg.github.io/tags/UI/"},{"name":"反射","slug":"反射","permalink":"https://busyogg.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"特性","slug":"特性","permalink":"https://busyogg.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"Attribute","slug":"Attribute","permalink":"https://busyogg.github.io/tags/Attribute/"}]},{"title":"免费对象存储 Cloudflare R2","slug":"免费对象存储Cloudflare-R2","date":"2024-01-29T20:50:02.000Z","updated":"2024-05-30T12:25:48.947Z","comments":true,"path":"article/26ad28d4c16a/","link":"","permalink":"https://busyogg.github.io/article/26ad28d4c16a/","excerpt":"","text":"缘由在某日，我突然发现博客里的视频加载速度很慢，由于我平时都是挂着 Clash，因此这也是偶然才发现。原因是 Cloudflare 不缓存视频。后来尝试了各种方法，最终选择了也是 Cloudflare 家的 R2 存储。 简介R2 是 Cloudflare 自家的对象存储服务，和其他对象存储相比，R2 不计算流量，只计算访问，因此对于大文件和小文件来说，访问一次的消耗都是一样的。 R2 免费有每月 10G 存储，100 万次 A 类操作，1000 万次 B 类操作，对于个人用户来说完全足够了。 由于 R2 是国外的，因此域名不需要备份可以直接使用。而且文件的访问速度十分不错。 设置R2 的申请按照官方的流程来就可以，在申请完成后，我们还可以进行一些设置。 存储桶设置当我们创建一个存储桶之后，转到设置界面。 我们添加一个域名来访问这个桶。点击连接域添加域名（需要挂到 Cloudflare）。这时候 Cloudflare 应该会自动进行域名的校验。 然后我们配置跨域策略，根据需求即可，这里的设置表示所有来源均可访问。 其他设置根据需要自行设置即可。 缓存设置我们来到网站设置，选择自己的域名。然后我们选择规则 - 页面规则。 红框部分需要设置，时长可以根据自己需要来定，其他的按需设置即可。 安全设置然后我们转到安全性-WAF。 我们添加三个规则 第一个规则用于记录访问信息。 第二个规则用于防非法爬虫。（网络搜集的规则） 第三个规则用于放行合法爬虫。（网络搜集的规则） 以下是三条规则的代码： (http.host contains &quot;your domain&quot; and ip.geoip.country ne &quot;CN&quot;) (cf.threat_score ge 5 and not cf.client.bot) or (not http.request.version in &#123;&quot;HTTP/1.2&quot; &quot;HTTP/2&quot; &quot;HTTP/3&quot; &quot;SPDY/3.1&quot;&#125;) or (not http.user_agent contains &quot;Mozilla/&quot;) (cf.client.bot) or (http.user_agent contains &quot;duckduckgo&quot;) or (http.user_agent contains &quot;facebookexternalhit&quot;) or (http.user_agent contains &quot;Feedfetcher-Google&quot;) or (http.user_agent contains &quot;LinkedInBot&quot;) or (http.user_agent contains &quot;Mediapartners-Google&quot;) or (http.user_agent contains &quot;msnbot&quot;) or (http.user_agent contains &quot;Slackbot&quot;) or (http.user_agent contains &quot;TwitterBot&quot;) or (http.user_agent contains &quot;ia_archive&quot;) or (http.user_agent contains &quot;yahoo&quot;) 然后是三条规则的操作： 还有一条速度限制的规则。 表达式为(http.request.uri.path contains &quot;/&quot;) 按照如图所示设置即可。 使用方法我们可以通过存储桶页面的上传按钮来上传文件，也可以使用其他方法来上传（例如 alist，请自行研究）。 当我们要访问文件的时候，可以通过刚才链接的域名来访问，只要输入your domain/filename.suffix形式的链接即可。 更新日志2024-01-30 更新基本内容。","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://busyogg.github.io/tags/Cloudflare/"},{"name":"对象存储","slug":"对象存储","permalink":"https://busyogg.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"},{"name":"OSS","slug":"OSS","permalink":"https://busyogg.github.io/tags/OSS/"}]},{"title":"定点数原理","slug":"定点数原理","date":"2024-01-27T09:48:46.000Z","updated":"2024-05-30T12:24:28.416Z","comments":true,"path":"article/fbf1414ac525/","link":"","permalink":"https://busyogg.github.io/article/fbf1414ac525/","excerpt":"","text":"简介在某些情况下，我们需要保证同样的输入得到同样的结果。因此我们要么使用整形，要么就使用定点数。 本文主要介绍定点数的原理。 什么是定点数定点数是指小数点位置固定的数，用整数来表示小数。所以本质上，定点数的运算其实就是整数的运算。由于浮点数使用的是科学计数法来表示，还原成数字的时候会产生误差，因此使用整数运算的定点数不会产生精度误差。 定点数原理我们约定定点数的名字叫做 FP。 定点数表示本文定点数用 long 长整型来表示。长整型一共 64 位，最高位表示符号，除符号位外，前 31 位表示整数部分，后 32 位表示小数部分。 定点数运算类型转换加法减法乘法除法求余其他运算符首先我们定义一个基本单位，用于计算。 12public const int FRACTIONAL_PLACES = 32;public const long ONE = 1L &lt;&lt; FRACTIONAL_PLACES; ONE 代表 FP 的一个单位大小，所以我们在类型转换的时候通过原来的数值大小乘以 ONE，就可以得到转变为 FP 类型之后的值。 在二进制的视角下，就相当于原来的数左移了 32 位。 浮点数转换的时候需要显示转换为 long。 从 FP 转换到其他类型的话只要进行相反的操作，即除以 ONE，然后如果是 int 类型就在计算完后显示转换为 int，如果是浮点类型就提前显示转换为浮点类型即可。 通过重载类型转换，我们可以在使用的时候更方便地进行类型转换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public FP(long value)&#123; _value = value;&#125;public static implicit operator FP(long value)&#123; FP res; res._value = value * ONE; return res;&#125;public static implicit operator FP(int value)&#123; FP res; res._value = value * ONE; return res;&#125;public static implicit operator FP(float value)&#123; FP res; res._value = (long)(value * ONE); return res;&#125;public static implicit operator FP(double value)&#123; FP res; res._value = (long)(value * ONE); return res;&#125;public static explicit operator int(FP fp)&#123; return (int)(fp._value / ONE);&#125;public static explicit operator long(FP fp)&#123; return fp._value &gt;&gt; FRACTIONAL_PLACES;&#125;public static explicit operator float(FP fp)&#123; return (float)fp._value / ONE;&#125;public static explicit operator double(FP fp)&#123; return (double)fp._value / ONE;&#125; 我们只要通过如下方法，就可以得到 FP 数： 12FP num = 1;FP num2 = 1.1f;我们重载加法运算符。 加法只要把两个 FP 的值相加，得到一个新的值即可。 如果相加之后出现超出 FP 能表示的最大位数，则该结果溢出，所以我们需要进行溢出判断。 溢出判断主要是对符号位进行检测。 首先我们通过异或判断 xl ^ yl 两个参数的符号位是否相同，相同情况得到的结果，符号位为 0，否则为 1。 然后我们对该结果取反，即我们检测两个参数为同号的情况。因为只有同号相加的情况，才会产生溢出，异号相加的结果只会在正负极限值之内。 接着我们判断 xl ^ sum 参数 1 与结果的符号是否相同（也可以用参数 2）。 根据前面的结果，我们接下来判断 (~(xl ^ yl) &amp; (xl ^ sum)) 符号位是否相同。这里会出现两种结果： 两个参数同号：~(xl ^ yl) 符号位为 1。由于溢出会使符号相反，因此如果 (xl ^ sum) 同号，即为 0，不溢出，则在符号位上，1 &amp; 0 = 0；如果(xl ^ sum) 异号，即为 1，溢出，则在符号位上，1 &amp; 1 = 1。 两个参数异号：~(xl ^ yl) 符号位为 0，则符号位结果必为 0。 5.最后我们跟 Min_Value 求与，Min_Value 是 float 的最小数，即最高位符号位为 1，其余都是 0。这样就能单独比较符号位的结果是否为 0，不是则溢出。 1234567891011121314public static FP operator +(FP x,FP y)&#123; var xl = x._value; var yl = y._value; var sum = xl + yl; //通过符号位判断溢出 if (((~(xl ^ yl) &amp; (xl ^ sum)) &amp; Min_Value) != 0) &#123; sum = xl &gt; 0 ? Max_Value : Min_Value; &#125; FP result; result._value = sum; return result;&#125;我们重载减法运算符。 加法只要把两个 FP 的值相减，得到一个新的值即可。 如果相加之后出现超出 FP 能表示的最大位数，则该结果溢出，所以我们需要进行溢出判断。 溢出判断主要是对符号位进行检测。 首先我们通过异或判断 xl ^ yl 两个参数的符号位是否相同，相同情况得到的结果，符号位为 0，否则为 1。 此处我们不对该结果取反，和加法相反。因为只有异号相减的情况，才会产生溢出，同号相减的结果只会在正负极限值之内。 接着我们判断 xl ^ sum 参数 1 与结果的符号是否相同（也可以用参数 2）。 根据前面的结果，我们接下来判断 ((xl ^ yl) &amp; (xl ^ sum)) 符号位是否相同。这里会出现两种结果： 两个参数异号：(xl ^ yl) 符号位为 1。由于溢出会使符号相反，因此如果 (xl ^ sum) 同号，即为 0，不溢出，则在符号位上，1 &amp; 0 = 0；如果(xl ^ sum) 异号，即为 1，溢出，则在符号位上，1 &amp; 1 = 1。 两个参数同号：(xl ^ yl) 符号位为 0，则符号位结果必为 0。 5.最后我们跟 Min_Value 求与，Min_Value 是 float 的最小数，即最高位符号位为 1，其余都是 0。这样就能单独比较符号位的结果是否为 0，不是则溢出。 1234567891011121314public static FP operator -(FP x, FP y)&#123; var xl = x._value; var yl = y._value; var diff = xl - yl; //通过符号位判断溢出 if ((((xl ^ yl) &amp; (xl ^ diff)) &amp; Min_Value) != 0) &#123; diff = xl &gt; 0 ? Max_Value : Min_Value; &#125; FP result; result._value = diff; return result;&#125;我们重载乘法运算符。 乘法运算我们分为两个部分，四个步骤进行。两个部分是整数部分和小数部分，四个步骤，是两个参数的整数和小数分别相乘。最后我们把得到的结果相加，就是乘法的结果了。 我们可以类比为竖式计算的过程，这样或许会更好理解。 比如 $1.1 \\times 1.1$ ,我们根据规则得到以下四个式子： $0.1 \\times 0.1 &#x3D; 0.01$ $1 \\times 0.1 &#x3D; 0.1$ $1 \\times 0.1 &#x3D; 0.1$ $1 \\times 1 &#x3D; 1$ 最后把结果加起来就是 $0.01+0.1+0.1+1&#x3D;1.21$ 我们对小数部分与0x00000000FFFFFFFF求与，得到小数部分表示为整数的值；对整数部分右移 32 位，得到正确的整数值（而不是定点数表示的整数值）。 小数部分相乘的情况下，得到的结果会变成 64 位，因此我们需要右移 32 位使其归位。 整数部分相乘的情况下，得到的结果左移 32 位，使其回到定点数表示的整数位置。 小数与整数相乘的情况下，不会使小数位数产生变化，进位的值也会自动进入整数位置，因此不需要进行操作。 接着我们逐个相加，每次相加都判断是否有溢出。 这里判断溢出的方式和加法不同，这里只需要判断同号的情况，因为我们已经把两个参数转为同号，所以只要判断两个参数和得到的结果是否同号即可。 最后我们通过之前判断的两个参数是否同号，决定乘法结果的正负。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static FP operator *(FP x, FP y)&#123; var xl = x._value; var yl = y._value; bool opSignsEqual = ((xl ^ yl) &amp; Min_Value) == 0; if (xl &lt; 0) &#123; xl = -xl; &#125; if(yl &lt; 0) &#123; yl = -yl; &#125; var xlo = (xl &amp; 0x00000000FFFFFFFF); var xhi = xl &gt;&gt; FRACTIONAL_PLACES; var ylo = (yl &amp; 0x00000000FFFFFFFF); var yhi = yl &gt;&gt; FRACTIONAL_PLACES; //分解计算过程 var lolo = xlo * ylo; var lohi = xlo * yhi; var hilo = xhi * ylo; var hihi = xhi * yhi; //修正位数 var loResult = lolo &gt;&gt; FRACTIONAL_PLACES; var midResult1 = hilo; var midResult2 = lohi; var hiResult = hihi &lt;&lt; FRACTIONAL_PLACES; bool overflow = false; var sum = AddOverflowHelper(loResult, midResult1, ref overflow); sum = AddOverflowHelper(sum, midResult2, ref overflow); sum = AddOverflowHelper(sum, hiResult, ref overflow); if(overflow) &#123; sum = Max_Value; &#125; if (!opSignsEqual) &#123; sum = -sum; &#125; FP result; result._value = sum; return result;&#125;/// &lt;summary&gt;/// 只在同号情况下有用，计算是否溢出/// &lt;/summary&gt;/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;overflow&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static long AddOverflowHelper(long x, long y, ref bool overflow)&#123; var sum = x + y; // x + y overflows if sign(x) ^ sign(y) != sign(sum) overflow |= ((x ^ y ^ sum) &amp; Min_Value) != 0; return sum;&#125;我们重载除法运算符。 除法的运算是模拟我们数学上除法的过程。 如果除数是 0，直接返回最大值。 我们定义余数 remainder，除数 divider，商 quotient，计算位数 bitPos。 余数初始化为参数 1，除数初始化为参数 2，商初始化为 0，计算位数初始化为 33 位。 然后我们开始计算： 先判断小数部分有没有多余的 0，此处选择每次右移 4 位（2 的 4 次幂），即一个十六进制 0。这样可以快速移动到最小计算位数。 然后我们开始循环，如果有余数并且计算位数大于等于 0 的情况，我们就进行一次除法。 我们先获得余数前导零个数，然后和需要计算的位数进行比较，防止溢出。 然后我们左移余数，这一步是为了防止在循环的过程中余数不够位数参与运算。同时我们剩余的计算位数要减去左移的位数。 接着我们求商和余数，新的余数赋值给原来的余数，商根据左移位数同样移动并且加到总商上。 判断结果有没有溢出。 余数进位，继续循环。 商 +1 并右移一位，进行舍入。 最后判断是否异号，是的话符号位就取反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public static FP operator /(FP x, FP y)&#123; var xl = x._value; var yl = y._value; if (yl == 0) &#123; return Max_Value; //throw new DivideByZeroException(); &#125; var remainder = (ulong)(xl &gt;= 0 ? xl : -xl); var divider = (ulong)(yl &gt;= 0 ? yl : -yl); var quotient = 0UL; var bitPos = Num_Bit / 2 + 1; //加速除法，减少小数部分多余的0数量 // If the divider is divisible by 2^n, take advantage of it. while ((divider &amp; 0xF) == 0 &amp;&amp; bitPos &gt;= 4) &#123; divider &gt;&gt;= 4; bitPos -= 4; &#125; //除法计算 while (remainder != 0 &amp;&amp; bitPos &gt;= 0) &#123; //计算被除数前导零数量 int shift = CountLeadingZeroes(remainder); if (shift &gt; bitPos) &#123; shift = bitPos; &#125; //移动被除数到允许的最高位 remainder &lt;&lt;= shift; bitPos -= shift; //求商和余数 var div = remainder / divider; remainder = remainder % divider; //把商加到总商中 quotient += div &lt;&lt; bitPos; // Detect overflow //0xFFFFFFFFFFFFFFFF &gt;&gt; bitPos得到64-bitPos个1 //取反得到11100....（64-bitPos个0） //如果结果不为0，说明超出最大位数，溢出 if ((div &amp; ~(0xFFFFFFFFFFFFFFFF &gt;&gt; bitPos)) != 0) &#123; return ((xl ^ yl) &amp; Min_Value) == 0 ? MaxValue : MinValue; &#125; //前进一位 remainder &lt;&lt;= 1; --bitPos; &#125; // rounding ++quotient; var result = (long)(quotient &gt;&gt; 1); if (((xl ^ yl) &amp; Min_Value) != 0) &#123; result = -result; &#125; FP r; r._value = result; return r; //return new FP(result);&#125;/// &lt;summary&gt;/// 求前导0个数/// &lt;/summary&gt;/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static int CountLeadingZeroes(ulong x)&#123; int result = 0; //如果最高四位（二进制）都为0，则左移四位，加速计算 while ((x &amp; 0xF000000000000000) == 0) &#123; result += 4; x &lt;&lt;= 4; &#125; //如果最高一位（二进制）为0，则左移一位 while ((x &amp; 0x8000000000000000) == 0) &#123; result += 1; x &lt;&lt;= 1; &#125; return result;&#125;我们重载求余运算符。 求余只增加一种情况判定，防止溢出，其他和原本的求余一样。 12345678910public static FP operator %(FP x, FP y)&#123; FP result; // 判断是否为特殊情况：被除数是最小负数且除数是-1 // 这种情况下整数溢出会导致结果为0 result._value = x._value == Min_Value &amp; y._value == -1 ? 0 : x._value % y._value; return result;&#125;1234567891011121314151617181920212223242526272829303132333435public static FP operator -(FP x)&#123; //负数比正数多表示一位，因此正数可以直接转为负数，而最小负数不能直接转为正数，而是转为最大正值 return x._value == Min_Value ? MaxValue : new FP(-x._value);&#125;public static bool operator ==(FP x, FP y)&#123; return x._value == y._value;&#125;public static bool operator !=(FP x, FP y)&#123; return x._value != y._value;&#125;public static bool operator &gt;(FP x, FP y)&#123; return x._value &gt; y._value;&#125;public static bool operator &lt;(FP x, FP y)&#123; return x._value &lt; y._value;&#125;public static bool operator &gt;=(FP x, FP y)&#123; return x._value &gt;= y._value;&#125;public static bool operator &lt;=(FP x, FP y)&#123; return x._value &lt;= y._value;&#125; 更新日志2024-01-28 补上引用内容 2024-01-28 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"定点数","slug":"定点数","permalink":"https://busyogg.github.io/tags/%E5%AE%9A%E7%82%B9%E6%95%B0/"},{"name":"确定性","slug":"确定性","permalink":"https://busyogg.github.io/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7/"}]},{"title":"逻辑与渲染分离","slug":"逻辑与渲染分离","date":"2024-01-22T18:00:49.000Z","updated":"2024-05-30T12:25:41.849Z","comments":true,"path":"article/ce948424ad1b/","link":"","permalink":"https://busyogg.github.io/article/ce948424ad1b/","excerpt":"","text":"简介逻辑与渲染分离，即逻辑运算为一个部分，渲染表现为一个部分。渲染表现依赖于逻辑运算的结果，但逻辑运算不会受到渲染表现的影响。 因此，逻辑与渲染可以获得不同的更新频率，通常是逻辑计算的频率要低于渲染，这样可以减少复杂逻辑的性能开销。 渲染表现在每两个逻辑帧之间进行插值，这样就能使画面平滑，不会因为低频逻辑更新而产生顿感。 实现如果项目结构是面向对象的话，可以考虑使用事件来通知渲染对象更新数据并插值，或者渲染对象持有逻辑对象，在更新的时候获取对应数据。 本例使用的是 ECS 的结构，因此只需要在渲染系统写好插值逻辑，系统自然会遍历更新。 如果目标位置或旋转有更新，直接重置上一位置和旋转为当前渲染对象的坐标和旋转，并重置插值进度为 0。 更新插值进度。 根据上一位置或上一旋转和目标位置或目标旋转，进行 lerp 插值，然后赋值给渲染对象。 如果插值进度完成，则重置上一位置和旋转为当前渲染对象的坐标和旋转，并重置插值进度为 0。 如果有缩放需求的也可以同理操作。 上图白色线框为逻辑包围盒位置，可以看出逻辑更新频率低的情况下有顿感，渲染对象的方块追逐逻辑位置插值靠近。 更新日志2024-01-23 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"解决方案","slug":"解决方案","permalink":"https://busyogg.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"渲染","slug":"渲染","permalink":"https://busyogg.github.io/tags/%E6%B8%B2%E6%9F%93/"}]},{"title":"物理引擎 Demo 思路","slug":"物理引擎Demo思路","date":"2024-01-21T20:08:06.000Z","updated":"2024-05-30T12:27:11.723Z","comments":true,"path":"article/b83ee5a642c0/","link":"","permalink":"https://busyogg.github.io/article/b83ee5a642c0/","excerpt":"","text":"移动移动的时候只需要以对象坐标为基础，加上移动的方向和速度，即可得到下一个坐标。 碰撞在一帧移动完成后，检测最新位置是否有和其他物体碰撞，如果有的话： 计算碰撞法线，碰撞法线是其他物体被碰撞的面的法线。 计算碰撞深度。 当前位置 +&#x3D; 碰撞法线 * 碰撞深度。 这样就可以得到碰撞后应该在的位置。我称之为排斥。 多个碰撞体的情况设置一个向量 offset 用来记录排斥的值，每个碰撞物体的排斥值都要加到 offset 中。最后我们会得到一个总的排斥值，加到当前位置中即可。 当两个碰撞物体排成一排时，会出现无法越过交界处的情况。 因此我选择每次排斥都更新一下自体碰撞盒。这样就能保证碰撞法线的方向相同。不过每次刷新包围盒的时候都会重新计算包围盒信息，增加了计算量。 不过这样会存在一个问题，就是如果碰撞的顺序不同的话，得到的结果也不同，因此我选择保存接触到的碰撞对象，每次碰撞检测的时候检测上次的碰撞物体是否存在于列表中，存在则不动，不存在则新增到列表后面，没碰撞的物体移除列表。这样就能保证每次碰撞的顺序是按照接触到的物体顺序，而不是遍历的顺序。 下落我选择的是根据下落的公式 $v_g&#x3D;-gt$ 得到下落速度，乘以每帧时间 $v_{g_{dt}}&#x3D;v_g*dt$ 得到每帧的下落速度，再加到当前坐标的 y 值上即可。 跳跃跳跃是在下落的基础上，增加一个初始速度，通过公式 $v&#x3D;v_0-v_g$ 得到下落速度，然后跟上面下落一样处理得到新的 y 值。 爬坡在爬坡的时候，我根据坡面的法线方向和自体的上方向，得到一个旋转的四元数，然后用该四元数乘以前进方向，使前进方向旋转到坡面，这样在坡面的移动就相当于把原来的坐标系转移到坡面的坐标系中，再在坡面坐标系实现位移。 用一个平面图来表示的话就像下图所示： 推广到三维空间也是一样。 判断是否在平台上跳跃和坡面都需要判断是否在平台上，在平台上的话就停止下落并重置状态。 判断是否在顶部，就判断自体最低点是否大于等于碰撞物体最高点；判断是会否在坡面，就判断移动方向和自体下方向的投影的绝对值是否大于 0 并小于自定义的坡度（0-1 之间）。 跨台阶跨台阶就是在做排斥的时候，判断自体最低点是否小于碰撞物体最高点，并且自体最低点加上自定义跨越高度是否大于碰撞物体最高点，都满足的情况下令排斥值的 y 值等于碰撞物体最高点减去自体最低点，即： 1234if (self.minY &lt; other.maxY &amp;&amp; self.minY + self.stepHeight &gt;= other.maxY)&#123; offset.y = other.maxY - self.minY;&#125; 否则就按照正常的排斥计算。 攀爬攀爬判定发生碰撞并且移动方向和碰撞法线的投影小于一定值（自定义）超过一定时间的时候判定为开始攀爬。 头顶有障碍物的时候取消攀爬。（攀爬面法线 y 值小于一定值为头顶有障碍物） 攀爬计算攀爬和爬坡一样需要把坐标系转移到攀爬平面上。 令原始输入方向（即输入值 ADWS）面向攀爬平面法线的反方向，得到面向输入方向。 计算自体上方向和攀爬平面法线的旋转四元数。 旋转四元数乘以面向输入方向得到最终攀爬方向。（和爬坡一样的操作） 攀爬与爬坡不同的是，爬坡用的是自体的移动方向做原始输入，攀爬用的是键盘输入的移动方向做原始输入。 攀爬的时候需要单独计算排斥，使其刚好处于碰撞物体表面。并且，碰撞物体的最近中心坐标在不碰撞的时候不清除，这样就可以拐弯。 自动攀爬到顶判断自体最高点是否大于碰撞物体最高点一定值，是则开始自动攀爬并禁用攀爬移动。 攀爬跳跃默认情况下向上跳跃，有按方向的情况下按照所按方向跳跃。 和攀爬到顶一样，攀爬跳跃也禁用攀爬，然后自动进行数帧的位移。完成后重启攀爬。 推物体设置物体的推力和被推时需要的力，然后根据比例，在碰撞检测排斥的时候进行比较。 设推力比例为 powerRatio 计算 $powerRatio&#x3D;另一物体被推力&#x2F;本物体推力$ ，然后将得到的数字乘到排斥力上，即 $offset*&#x3D;powerRatio$ ，即可得到新的排斥力大小。 在计算排斥力大小之前，需要先计算另一物体需要移动的距离。 设另一物体的排斥力为 reverseOffset 根据以下公式： $reverseOffset&#x3D;offset*(1-powerRatio)$ 把所有 reverseOffset 都加到另一物体的 offset，我们就能得到另一物体移动的距离。 更新日志2024-03-01 1.更新推物体思路 2024-01-22 更新基础内容移动碰撞下落跳跃爬坡判定平台跨台阶攀爬","categories":[{"name":"设计思路","slug":"设计思路","permalink":"https://busyogg.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"}],"tags":[{"name":"物理","slug":"物理","permalink":"https://busyogg.github.io/tags/%E7%89%A9%E7%90%86/"}]},{"title":"用自己买的服务器进行内网穿透","slug":"用自己买的服务器进行内网穿透","date":"2024-01-20T17:07:09.000Z","updated":"2024-05-30T12:27:21.412Z","comments":true,"path":"article/90abd34fc86f/","link":"","permalink":"https://busyogg.github.io/article/90abd34fc86f/","excerpt":"","text":"简介大部分时候我们自己网络的 IP 是内网 IP，又想要别人能够通过外网来访问我们电脑里的项目，这时候就需要内网穿透。 除了花生壳等第三方以外，我们还可以用自己买的服务器的公网 IP 来进行内网穿透。 当然，如果你条件允许的话，直接用高配的服务器就好。此处的适用场景为服务器配置不足，自己电脑配置足够的情况下，通过服务器转发访问到我们自己的电脑。 方法我们可以使用开源项目 FRP 来实现。 首先我们下载 release 中对应平台的文件。 其次我们在服务端部署 frps 相关的所有文件到任意目录。然后修改配置文件（也可以默认不修改，默认端口为 7000）。然后通过 ./frps -c ./frps.toml 命令来启动服务。 接下来我们在客户端部署 frpc 相关的所有文件到任意目录。然后按照下面的要求修改配置文件。最后通过 ./frpc -c ./frpc.toml 命令来启动服务。 1234567891011serverAddr = &quot;x.x.x.x&quot; //服务器ipserverPort = 7000 //服务端端口，和frps配置的一致# 如果默认的 STUN 服务器不可用，可以配置一个新的 STUN 服务器# natHoleStunServer = &quot;xxx&quot;[[proxies]]name = &quot;test-tcp&quot; //随便写type = &quot;tcp&quot; //协议localIP = &quot;127.0.0.1&quot; //本地服务iplocalPort = 22 //本地服务端口remotePort = 6000 //访问时使用的端口 更多配置请前往 官方文档 查看。 只要服务端出现 frps started successfully，本地出现 start proxy success 字样就穿透成功了。 接下来只要使用 x.x.x.x:6000 就能访问到内网的服务了。 更新日志2024-01-21 1.更新基本内容。","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://busyogg.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://busyogg.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"FRP","slug":"FRP","permalink":"https://busyogg.github.io/tags/FRP/"}]},{"title":"ChatGPT访问方法","slug":"ChatGPT访问方法","date":"2023-12-15T15:49:03.000Z","updated":"2024-05-18T15:38:09.617Z","comments":true,"path":"article/0adcafccba95/","link":"","permalink":"https://busyogg.github.io/article/0adcafccba95/","excerpt":"","text":"设置代理地址为支持 ChatGPT 的国家或地区，如美国（香港不支持）。 清除浏览器 cookie。 地址栏输入javascript:window.localStorage.removeItem(Object.keys(window.localStorage).find(i=&gt;i.startsWith(&#39;@@auth0spajs&#39;)))，其中javascript:需要手动输入。 以上方法根据情况自由选择搭配使用（代理必须要做）。清除 cookie 需要重启浏览器。清除缓存不需要。","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://busyogg.github.io/tags/ChatGPT/"}]},{"title":"Unity-配置类生成器","slug":"Unity-配置类生成器","date":"2023-12-10T13:32:35.000Z","updated":"2024-05-30T12:28:38.441Z","comments":true,"path":"article/7fe0212fb1a1/","link":"","permalink":"https://busyogg.github.io/article/7fe0212fb1a1/","excerpt":"","text":"简介自动监听 Json 配置文件夹，目前实现一件生成配置类，有空的话再增加配置查看和修改的功能。 使用说明工具说明 按照图片红框所示的步骤即可一件生成配置类文件。本工具监听配置文件夹，只要有变化自动就会改变面板显示的内容。 工具代码放在 Unity 项目的 Editor 文件夹下。 配置类说明配置类会保存到配置类输出文件夹的 Bean 目录下。 在输出文件夹根目录中存在一个 ConfigsPathConfig 文件，该文件包含所有配置的名字和配置文件夹的名字。 例： 配置文件说明配置表属性名后面添加 | 可以分割属性名和类型。 如果我们需要一个本配置类的类型，则我们在对应的配置项就置空。 例： 如果我们需要一个特定的枚举类型或者类的类型，则可以用 | 来表示我们要生成的类型，即 PropName|EnumType，这样就能生成 EnumType prop。 例： 如果该类型是 int 类型的列表，但是第一项中没有内容，我们只要把属性名写成 PropName|int 即可生成 List&lt;int&gt;。 例： 如果该类型是本数据类，则我们不用写类型，但是要在配置项的位置写一个空列表 [] ，这样生成的时候就会生成 List&lt;ClassName&gt;。 例： 如果要生成一个字典，则我们可以再加一个 | 来表示键值对类型，即写成 PropName|type|type，并且在配置项写一个空对象 &#123;&#125;，这样就能生成 Dictionary&lt;type,type&gt;。目前支持的 key 类型为 string 和 int。 例： 如果要生成一个对象数组，只需要在数组中写入对象键值对，即可生成对象辅助类。本类型不支持自定义数组和字典类型，只能按照输入的内容创建基本数据类型的数组和字典。 例： 配置管理器说明使用 ConfigManager.Ins().GetConfig&lt;T&gt;(string folder, string name) 来获取对应的配置。 使用 ConfigManager.Ins().Clear() 来清除缓存。 配置路径修改修改文件 ConfigEditor 中的 _jsonUrl 属性即可修改读取 json 文件的文件夹路径。 修改文件 ConfigEditor 中的 _outputUrl 属性即可修改写入配置类的路径。 注意 配置文件夹下不能创建和配置文件夹同名的文件夹。 配置文件夹只能存在最多二级文件夹，即最大路径为 /Configs/Folder/Config.json。 代码ConfigEditor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using LitJson;public class ConfigEditor : EditorWindow&#123; /// &lt;summary&gt; /// 配置文件路径 /// &lt;/summary&gt; private string _jsonUrl; /// &lt;summary&gt; /// 配置类输出路径 /// &lt;/summary&gt; private string _outputUrl; private Dictionary&lt;string, List&lt;FileInfo&gt;&gt; _allConfigs = new Dictionary&lt;string, List&lt;FileInfo&gt;&gt;(); private int _configsNum = 0; private bool _foldConfigs = true; private Vector2 _scrollRoot; ConfigEditor() &#123; titleContent = new GUIContent(&quot;配置编辑器&quot;); &#125; [MenuItem(&quot;PreUtils/EditorEditor&quot;)] static public void ShowEditor() &#123; // Debug.Log(&quot;启动配置编辑器&quot;); EditorWindow.GetWindow(typeof(ConfigEditor)); &#125; private void OnEnable() &#123; _jsonUrl = Application.dataPath + &quot;/Configs/&quot;; _outputUrl = Application.dataPath + &quot;/Script/Loader/Config/&quot;; //获取所有配置 GetAllConfigs(); //监听配置文件夹变化 Debug.Log(&quot;启动文件夹监听&quot;); FileSystemWatcher watcher = new FileSystemWatcher(); watcher.IncludeSubdirectories = true; watcher.Path = _jsonUrl; watcher.NotifyFilter = NotifyFilters.LastWrite; watcher.Filter = &quot;*.json&quot;; FileSystemEventHandler changeHandle = new FileSystemEventHandler(OnJsonFileChanged); watcher.Changed += changeHandle; //watcher.Deleted += changeHandle; watcher.Created += changeHandle; watcher.EnableRaisingEvents = true; watcher.InternalBufferSize = 10240; &#125; public void OnGUI() &#123; GUILayout.Space(10); //获取所有配置 _foldConfigs = EditorGUILayout.BeginFoldoutHeaderGroup(_foldConfigs, &quot;所有配置&quot;); if (_foldConfigs) &#123; GUILayout.Label(&quot;总配置数量：&quot; + _configsNum); GUILayout.BeginHorizontal(); GUILayout.Space(10); _scrollRoot = EditorGUILayout.BeginScrollView(_scrollRoot, GUILayout.Height(400), GUILayout.Width(position.width - 20)); GUIStyle configButtonStyle = new GUIStyle(GUI.skin.button); configButtonStyle.fixedHeight = 22; configButtonStyle.fontSize = 16; configButtonStyle.alignment = TextAnchor.MiddleLeft; GUIStyle configLabelStyle = new GUIStyle(GUI.skin.label); configLabelStyle.fontSize = 18; configLabelStyle.alignment = TextAnchor.MiddleLeft; configLabelStyle.fixedHeight = 20; foreach (var fileInfo in _allConfigs) &#123; EditorGUILayout.LabelField(fileInfo.Key + &quot;【&quot; + fileInfo.Value.Count + &quot;个配置文件】:&quot;, configLabelStyle); GUILayout.Space(5); for (int i = 0, len = fileInfo.Value.Count; i &lt; len; i++) &#123; FileInfo file = fileInfo.Value[i]; //EditorGUILayout.LabelField(&quot;测试&quot;); GUIContent name = new GUIContent((i + 1) + &quot;.&quot; + file.Name.Replace(&quot;.json&quot;, &quot;&quot;)); if (GUILayout.Button(name, configButtonStyle)) &#123; //EditorWindow.GetWindow(typeof(ConfigDetailEditor)); &#125; GUILayout.Space(2); &#125; GUILayout.Space(10); &#125; EditorGUILayout.EndScrollView(); GUILayout.EndHorizontal(); &#125; EditorGUILayout.EndFoldoutHeaderGroup(); GUILayout.Space(10); if (GUILayout.Button(&quot;一键生成所有配置文件数据类&quot;)) &#123; GenerateDataClass(); GenerateConfigPath(); &#125; &#125; /// &lt;summary&gt; /// 创建数据类 /// &lt;/summary&gt; private void GenerateDataClass() &#123; //生成基类 string ns = &quot;Bean&quot;; string baseClass = &quot;namespace &quot; + ns + &quot;\\r\\n&#123;\\r\\n&quot; + &quot;\\tpublic class ConfigBaseData\\r\\n&quot; + &quot;\\t&#123;\\r\\n&quot; + &quot;\\t\\tpublic int id;\\r\\n&quot; + &quot;\\t&#125;\\r\\n&#125;&quot;; string output = _outputUrl + &quot;ConfigBaseData.cs&quot;; GeneratorUtils.WriteFile(output, baseClass); //创建所有数据类 foreach (var fileInfo in _allConfigs) &#123; //生成数据类 for (int i = 0, len = fileInfo.Value.Count; i &lt; len; i++) &#123; FileInfo file = fileInfo.Value[i]; string content = GeneratorUtils.ReadFile(file.FullName); JsonData jsonData = JsonMapper.ToObject(content); GenerateClass(GeneratorUtils.UpperCaseFirstChar(file.Name.Split(&#x27;.&#x27;)[0]) + &quot;Data&quot;, jsonData, fileInfo.Key); &#125; &#125; &#125; /// &lt;summary&gt; /// 创建类 /// &lt;/summary&gt; /// &lt;param name=&quot;clsName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;folder&quot;&gt;&lt;/param&gt; private void GenerateClass(string clsName, JsonData json, string folder) &#123; List&lt;string&gt; listClass = new List&lt;string&gt;(); List&lt;string&gt; listProps = new List&lt;string&gt;(); string ns = &quot;Bean&quot;; //创建命名空间 listClass.Add(&quot;using System;\\r\\n&quot; + &quot;using System.Collections.Generic;\\r\\n&quot; + &quot;namespace &quot; + ns + &quot;&#123;\\r\\n&quot;); //创建类头 listClass.Add(&quot;\\tpublic class &quot; + clsName + &quot;: ConfigBaseData, ICloneable&#123;\\r\\n&quot;); //创建构造函数 string strConstructor = &quot;\\t\\tpublic &quot; + clsName + &quot;()&#123;\\r\\n&quot;; //遍历属性 IDictionary props = json[0]; foreach (var key in props.Keys) &#123; Dictionary&lt;string, bool&gt; dicClass = new Dictionary&lt;string, bool&gt;(); string propName = key.ToString(); if (propName == &quot;id&quot;) continue; JsonData child = json[0][propName]; object type = child == null ? JsonType.None : child.GetJsonType(); if (type.Equals(JsonType.None)) &#123; listClass.Add(&quot;\\t\\tpublic &quot; + clsName + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; else if (type.Equals(JsonType.Array)) &#123; //属性为数组 if (child.Count == 0) &#123; //最终类型非对象，该属性为纯数组 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; string[] propSplit = propName.Split(&#x27;|&#x27;); string strType; if (propSplit.Length &gt; 1) &#123; //strList += propSplit[1] + strListEnd; strType = propSplit[1]; &#125; else &#123; strType = clsName; &#125; strList += strType + strListEnd; Debug.Log(&quot;list数组 ==== &quot; + strList); //cls += &quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; listClass.Add(&quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propSplit[0] + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propSplit[0] + &quot; = new List&lt;&quot; + strType + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; else &#123; //获取最终类型 JsonData tempData = child[0]; JsonType tempType = tempData.GetJsonType(); int loop = 1; while (tempData.GetJsonType().Equals(JsonType.Array)) &#123; tempData = tempData[0]; tempType = tempData.GetJsonType(); loop++; &#125; if (tempType.Equals(JsonType.Object)) &#123; //最终类型为对象 //创建附属类 string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dicClass.ContainsKey(strListClassName)) &#123; GeneratorUtils.GenerateSubClass(child, strListClassName, listClass, dicClass); dicClass.Add(strListClassName, true); &#125; //创建附属类列表 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += strListClassName + strListEnd; &#125; &#125; //strListClass += &quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; listClass.Add(&quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propName + &quot; = new List&lt;&quot; + strListClassName + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; else &#123; //最终类型非对象，该属性为纯数组 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += GeneratorUtils.GetType(tempType) + strListEnd; &#125; &#125; Debug.Log(&quot;list数组 ==== &quot; + strList); //cls += &quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; listClass.Add(&quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propName + &quot; = new List&lt;&quot; + GeneratorUtils.GetType(tempType) + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; &#125; &#125; else if (type.Equals(JsonType.Object)) &#123; //属性为对象 string[] propSplits = propName.Split(&quot;|&quot;); if (propSplits.Length &gt; 1) &#123; listClass.Add(&quot;\\t\\tpublic Dictionary&lt;&quot; + propSplits[1] + &quot;,&quot; + propSplits[2] + &quot;&gt; &quot; + propSplits[0] + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propSplits[0] + &quot; = new Dictionary&lt;&quot; + propSplits[1] + &quot;,&quot; + propSplits[2] + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; else &#123; //创建附属类 string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dicClass.ContainsKey(strListClassName)) &#123; GeneratorUtils.GenerateSubClass(child, strListClassName, listClass, dicClass); dicClass.Add(strListClassName, true); &#125; listClass.Add(&quot;\\t\\tpublic &quot; + strListClassName + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; &#125; else &#123; //属性为基本类型 //Debug.Log(&quot;属性名&quot; + propName + &quot;,&quot; + type + &quot;,&quot; + json[0][propName]); //cls += &quot;\\t\\tpublic &quot; + GetType(type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;; if (type == null) &#123; listClass.Add(&quot;\\t\\tpublic &quot; + clsName + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; else &#123; string[] propSplit = propName.Split(&#x27;|&#x27;); if (propSplit.Length &gt; 1) &#123; listClass.Add(&quot;\\t\\tpublic &quot; + propSplit[1] + &quot; &quot; + propSplit[0] + &quot;;\\r\\n&quot;); &#125; else &#123; listClass.Add(&quot;\\t\\tpublic &quot; + GeneratorUtils.GetType((JsonType)type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; &#125; &#125; listProps.Add(propName); &#125; strConstructor += &quot;\\t\\t&#125;\\r\\n&quot;; listClass.Add(strConstructor); string strGenerator = &quot;&quot;; strGenerator += &quot;\\t\\tpublic &quot; + clsName + &quot;(&quot; + clsName + &quot; obj)&#123;\\r\\n&quot;; for (int i = 0, len = listProps.Count; i &lt; len; i++) &#123; string[] propSplit = listProps[i].Split(&#x27;|&#x27;); if (propSplit.Length &gt; 1) &#123; strGenerator += &quot;\\t\\t\\t&quot; + propSplit[0] + &quot; = obj.&quot; + propSplit[0] + &quot;;\\r\\n&quot;; &#125; else &#123; strGenerator += &quot;\\t\\t\\t&quot; + listProps[i] + &quot; = obj.&quot; + listProps[i] + &quot;;\\r\\n&quot;; &#125; &#125; strGenerator += &quot;\\t\\t&#125;\\r\\n&quot;; listClass.Add(strGenerator); //创建克隆函数 listClass.Add(&quot;\\t\\tpublic object Clone()\\r\\n&quot; + &quot;\\t\\t&#123;\\r\\n&quot; + &quot;\\t\\t\\treturn new &quot; + clsName + &quot;(this);\\r\\n&quot; + &quot;\\t\\t&#125;\\r\\n&quot;); //补充文件结构 listClass.Add(&quot;\\t&#125;&quot; + &quot;\\r\\n&#125;&quot;); //拼装数据类内容 string cls = &quot;&quot;; for (int i = 0, len = listClass.Count; i &lt; len; i++) &#123; cls += listClass[i]; &#125; //保存数据类 Debug.Log(&quot;生成类&quot; + cls); string strFolder; if (folder == &quot;Configs&quot;) &#123; strFolder = &quot;&quot;; &#125; else &#123; strFolder = folder + &quot;/&quot;; &#125; string output = _outputUrl + &quot;Bean/&quot; + strFolder + clsName + &quot;.cs&quot;; GeneratorUtils.WriteFile(output, cls); &#125; private void GenerateConfigPath() &#123; //string ns = &quot;Bean&quot;; string cls = &quot;namespace Bean&#123;\\r\\n&quot; + &quot;\\tpublic class ConfigsFolderConfig\\r\\n&quot; + &quot;\\t&#123;\\r\\n&quot;; string folders = &quot;\\t\\tpublic const string Null = null;\\r\\n&quot;; string names = &quot;&quot;; //配置名字典，防止重名配置重复添加 Dictionary&lt;string, bool&gt; dicNames = new Dictionary&lt;string, bool&gt;(); //创建所有数据类 foreach (var fileInfo in _allConfigs) &#123; if (fileInfo.Key != &quot;Configs&quot;) &#123; folders += &quot;\\t\\tpublic const string &quot; + fileInfo.Key + &quot; = \\&quot;&quot; + fileInfo.Key + &quot;\\&quot;;\\r\\n&quot;; &#125; //生成数据类 for (int i = 0, len = fileInfo.Value.Count; i &lt; len; i++) &#123; FileInfo file = fileInfo.Value[i]; string fileName = file.Name.Replace(&quot;.json&quot;, &quot;&quot;); if (!dicNames.ContainsKey(fileName)) &#123; names += &quot;\\t\\tpublic const string &quot; + GeneratorUtils.UpperCaseFirstChar(fileName) + &quot; = \\&quot;&quot; + fileName + &quot;\\&quot;;\\r\\n&quot;; dicNames.Add(fileName, true); &#125; &#125; &#125; cls += folders; cls += &quot;\\t&#125;\\r\\n\\r\\n&quot; + &quot;\\tpublic class ConfigsNameConfig\\r\\n&quot; + &quot;\\t&#123;\\r\\n&quot;; cls += names; cls += &quot;\\t&#125;\\r\\n&quot; + &quot;&#125;&quot;; Debug.Log(&quot;生成配置表路径配置\\n&quot; + cls); GeneratorUtils.WriteFile(_outputUrl + &quot;ConfigsPathConfig.cs&quot;, cls); &#125; //-----自动函数----- /// &lt;summary&gt; /// 配置文件发生变化后的响应事件 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; private void OnJsonFileChanged(object obj, FileSystemEventArgs args) &#123; Debug.Log(&quot;配置文件发生变化，重载配置文件&quot;); _allConfigs.Clear(); GetAllConfigs(); &#125; /// &lt;summary&gt; /// 获取所有配置 /// &lt;/summary&gt; private void GetAllConfigs() &#123; Debug.Log(&quot;获取所有配置1:&quot; + _jsonUrl); DirectoryInfo directoryInfo = new DirectoryInfo(_jsonUrl); FileInfo[] files = directoryInfo.GetFiles(&quot;*&quot;, SearchOption.AllDirectories); _configsNum = 0; for (int i = 0, len = files.Length; i &lt; len; i++) &#123; FileInfo file = files[i]; if (file.Name.EndsWith(&quot;.meta&quot;)) continue; string[] folders = file.DirectoryName.Split(&#x27;\\\\&#x27;); string parent = folders[folders.Length - 1]; //_allConfigs.Add(file); if (!_allConfigs.ContainsKey(parent)) &#123; _allConfigs.Add(parent, new List&lt;FileInfo&gt;()); &#125; _allConfigs[parent].Add(file); //ConsoleUtils.Log(&quot;添加路径&quot; , (file.DirectoryName + &quot;/&quot;), _jsonUrl); _configsNum++; &#125; &#125;&#125; GeneratorUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181using System.Collections;using System.Collections.Generic;using UnityEngine;using LitJson;using System.IO;using System.Text;public class GeneratorUtils&#123; /// &lt;summary&gt; /// 生成辅助类 /// &lt;/summary&gt; /// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;dic&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GenerateSubClass(JsonData json, string className, List&lt;string&gt; list, Dictionary&lt;string, bool&gt; dic) &#123; string strListClass = &quot;\\t\\tpublic class &quot; + className + &quot; &#123;\\r\\n&quot;; Debug.Log(&quot;json数据 ===== &quot; + json.ToJson()); IDictionary classProps = json.GetJsonType().Equals(JsonType.Array) ? json[0] : json; foreach (var classKey in classProps.Keys) &#123; string propName = classKey.ToString(); //JsonData child = json[0][propName]; //strListClass += &quot;\\t\\tpublic &quot; + GetType(type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;; JsonData child = (JsonData)classProps[classKey]; JsonType type = child.GetJsonType(); if (type.Equals(JsonType.Array)) &#123; string[] propSplit = propName.Split(&#x27;|&#x27;); //获取最终类型 JsonData tempData = child[0]; JsonType tempType = tempData.GetJsonType(); int loop = 1; while (tempData.GetJsonType().Equals(JsonType.Array)) &#123; tempData = tempData[0]; tempType = tempData.GetJsonType(); loop++; &#125; if (tempType.Equals(JsonType.Object)) &#123; string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dic.ContainsKey(strListClassName)) &#123; GenerateSubClass(child, strListClassName, list, dic); dic.Add(strListClassName, true); &#125; //创建附属类列表 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += strListClassName + strListEnd; &#125; &#125; strListClass += &quot;\\t\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; else &#123; //非对象，该属性为纯数组 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += GetType(tempType) + strListEnd; &#125; &#125; strListClass += &quot;\\t\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; &#125; else if (type.Equals(JsonType.Object)) &#123; string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dic.ContainsKey(strListClassName)) &#123; GenerateSubClass(child, strListClassName, list, dic); &#125; strListClass += &quot;\\t\\t\\tpublic &quot; + strListClassName + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; else &#123; string[] propSplit = propName.Split(&#x27;|&#x27;); Debug.Log(&quot;分离:&quot; + propSplit.Length); if (propSplit.Length &gt; 1) &#123; strListClass += &quot;\\t\\t\\tpublic &quot; + propSplit[1] + &quot; &quot; + propSplit[0] + &quot;;\\r\\n&quot;; &#125; else &#123; strListClass += &quot;\\t\\t\\tpublic &quot; + GetType(type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; &#125; &#125; strListClass += &quot;\\t\\t&#125;\\r\\n&quot;; list.Insert(2, strListClass); return strListClass; &#125; public static string GetType(JsonType name) &#123; switch (name) &#123; case JsonType.Int: return &quot;int&quot;; case JsonType.Boolean: return &quot;bool&quot;; case JsonType.String: return &quot;string&quot;; case JsonType.Double: return &quot;double&quot;; case JsonType.Long: return &quot;long&quot;; &#125; return &quot;&quot;; &#125; /// &lt;summary&gt; /// 首字母大写 /// &lt;/summary&gt; /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string UpperCaseFirstChar(string s) &#123; if (string.IsNullOrEmpty(s)) &#123; return string.Empty; &#125; char[] a = s.ToCharArray(); a[0] = char.ToUpper(a[0]); return new string(a); &#125; /// &lt;summary&gt; /// 创建文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;info&quot;&gt;&lt;/param&gt; public static void WriteFile(string path, string content) &#123; //if (File.Exists(path)) &#123; //&#125; string folderPath = Path.GetDirectoryName(path); if (!Directory.Exists(folderPath)) &#123; Directory.CreateDirectory(folderPath); &#125; File.WriteAllText(path, content, Encoding.Default); &#125; /// &lt;summary&gt; /// 读取文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ReadFile(string path) &#123; path = path.Replace(&quot;/&quot;, &quot;\\\\&quot;); return File.ReadAllText(path); &#125;&#125; FileUtils123456789101112131415161718192021222324252627282930313233343536using System.IO;using System.Text;public class FileUtils&#123; // Start is called before the first frame update /// &lt;summary&gt; /// 创建文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;info&quot;&gt;&lt;/param&gt; public static void WriteFile(string path, string content) &#123; //if (File.Exists(path)) &#123; //&#125; string folderPath = Path.GetDirectoryName(path); if (!Directory.Exists(folderPath)) &#123; Directory.CreateDirectory(folderPath); &#125; File.WriteAllText(path, content, Encoding.Default); &#125; /// &lt;summary&gt; /// 读取文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ReadFile(string path) &#123; path = path.Replace(&quot;/&quot;, &quot;\\\\&quot;); return File.ReadAllText(path); &#125;&#125; ConfigManager1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System.Collections.Generic;using System.IO;using UnityEngine;using System.Linq;using LitJson;using Bean;using System.Text.RegularExpressions;public class ConfigManager:Singleton&lt;ConfigManager&gt;&#123; private Dictionary&lt;string, object&gt; _configs = new Dictionary&lt;string, object&gt;(); private Dictionary&lt;string, Dictionary&lt;string, FileInfo&gt;&gt; _fileInfo; /// &lt;summary&gt; /// 读取配置 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;folder&quot;&gt;配置分类&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;配置名&lt;/param&gt; /// &lt;returns&gt;配置字典&lt;/returns&gt; public Dictionary&lt;int, T&gt; GetConfig&lt;T&gt;(string folder, string name) where T : ConfigBaseData &#123; object obj = null; string path = folder + &quot;_&quot; + name; _configs.TryGetValue(path, out obj); if (obj != null) &#123; Debug.Log(&quot;读取配置缓存【&quot; + name + &quot;】&quot;); return (Dictionary&lt;int, T&gt;)obj; &#125; else &#123; string config = FileUtils.ReadFile(Application.dataPath + &quot;/Configs/&quot; + (folder != null ? folder + &quot;/&quot; : &quot;&quot;) + name + &quot;.json&quot;); config = Regex.Replace(config, &quot;(\\\\|).*(?=\\&quot;)&quot;, &quot;&quot;); Debug.Log(&quot;配置读取路径 - &quot; + Application.dataPath + &quot;/Configs/&quot; + (folder != null ? folder + &quot;/&quot; : &quot;&quot;) + name + &quot;.json&quot;); Debug.Log(&quot;读取内容 = &quot; + config); if (!string.IsNullOrEmpty(config)) &#123; T[] json = JsonMapper.ToObject&lt;T[]&gt;(config); obj = json.ToDictionary(key =&gt; key.id, value =&gt; value); _configs.Add(path, obj); return (Dictionary&lt;int, T&gt;)obj; &#125; else &#123; Debug.LogWarning(&quot;不存在配置【&quot; + name + &quot;】&quot;); return null; &#125; &#125; &#125; /// &lt;summary&gt; /// 清除目标缓存 /// &lt;/summary&gt; /// &lt;param name=&quot;folder&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; public void Clear(string folder, string name) &#123; string path = folder + &quot;_&quot; + name; if (_configs.ContainsKey(path)) &#123; _configs.Remove(path); &#125; &#125; /// &lt;summary&gt; /// 清除所有缓存 /// &lt;/summary&gt; public void ClearAll() &#123; _configs.Clear(); &#125;&#125; 更新日志2023-12-13 更新配置读取管理器。修改 LitJson 序列化使其支持 int 类型作为字典的 key。 2023-12-09 更新基础版本。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Unity-时间轮定时器","slug":"Unity-时间轮定时器","date":"2023-12-08T19:20:26.000Z","updated":"2024-05-30T12:28:48.555Z","comments":true,"path":"article/57f2cacfb66b/","link":"","permalink":"https://busyogg.github.io/article/57f2cacfb66b/","excerpt":"","text":"简介我们在开发的过程中，有时候需要一个行为延迟一定时间，或者是重复执行，这时候我们就需要用到定时器。Unity 没有专门的定时器系统，不过有协程的方式来实现这一行为。不过协程的使用难免有些不方便，也有一些性能上的消耗，因此决定自己造轮子。本系统使用时间轮的思想构建定时器系统，有别于传统的全遍历方式。 原理时间轮网图： 假设我们有一个时间轮盘，这个轮盘有好几个槽位，每个槽位里面有一个链表用于保存符合当前条件的定时任务。 每个定时任务放入对应槽位的规则为 当前时间 + 延迟时间 + 每次循环时间，这样每个槽位就对应着触发任务的时间。 我们按照当前时间来访问对应的槽位，即到了需要触发任务的时间，任务触发。 如果我们按照一个最小时间间隔，每个时间都开设一个槽位的话，需要的存储空间就太大了。因此我们需要多层时间轮，就好像水表有好几个转盘表示不同的刻度。我们把时间分为年（需要的话）、月、日、时、分、毫秒，本例中没有年轮，总共是六个时间轮。毫秒轮的数量太大，我们也可以按照设定的最小时间间隔减少划分（本例按照 50ms 为最小粒度划分 20 个槽位）。本例中时间轮用字典保存，任务列表用链表保存。 当我们的任务为定时到 5 秒后，我们就把当前任务放入月轮当月的槽位，然后我们在轮询的时候按照六个符合当前时间的时间轮槽位依次遍历链表。由于我们每次添加任务都是添加到最顶层的月轮，因此我们把当前时间的月轮槽位中的所有任务都取出并添加到日轮。日轮也是同样的操作，依次执行之后任务就到达毫秒轮中。 任务最终到达毫秒轮后，我们就遍历当前毫秒轮槽位的链表，比较当前时间和任务目标时间，大于等于的情况下执行任务并移除出链表。移除之后，我们还要判断当前任务是否需要循环，需要循环的话我们把当前任务又重新添加到月轮中，执行下一个循环。 链式调用为了让定时器更加实用，我们引入了链式调用。我们在创建定时器的时候会返回一个链式调用的对象，这样就可以在创建一次定时器之后再点出一个新的定时器。这个新的定时器的延迟时间为前面所有定时器的总经过时间再加上自己的延迟时间，这样就可以避免定时器的嵌套。 使用方式使用之前先调用 TimerUtils.Init() 来初始化，结束之后调用 TimerUtils.Stop() 来结束。 调用定时器的方式分为两种，一种是同步任务，一种是异步任务。由于 Unity 对象只有在主线程上才能访问，因此如果要延迟操作 Unity 对象的话就需要用同步任务，其他情况可以选择异步调用，根据需求即可。 延迟执行：TimerChain Once(int delay, Action action)下面的例子是延迟一秒后打印消息到控制台。 1234TimerUtils.Once(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;执行&quot;, DateTime.Now, chain.GetId());&#125;); 循环执行：TimerChain Loop(int interval, Action action, int delay = 0, int loopTimes = -1)下面的例子是循环三次，每次 1 秒间隔，延迟时间为 0，不传入循环次数就是无限循环。 1234TimerUtils.Loop(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;循环&quot;, DateTime.Now);&#125;, 0, 3); 清除定时器 12345678TimerChain chain = TimerUtils.Loop(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;循环&quot;, DateTime.Now);&#125;, 0, 3);//清除定时器chain.Clear();//或者用下面的方式，两种都一样TimerUtils.Clear(chain); 链式调用 1234567TimerUtils.Loop(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;循环&quot;, DateTime.Now);&#125;, 0, 3).Once(5000, () =&gt;&#123; ConsoleUtils.Log(&quot;等待&quot;, DateTime.Now);&#125;); 异步的调用和同步的一样，只是函数名不同（带 Async）。 代码TimerTask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Threading.Tasks;public class TimerTask&#123; public int id; public int delay; public int interval; public int loopTimes; public Action action; public DateTime dateTime; public TimerType type; public bool isRemove; public TimerTask(int id, int interval, Action action, int loopTimes, int delay, TimerType type) &#123; this.id = id; this.interval = interval; this.action = action; this.loopTimes = loopTimes; this.delay = delay; this.type = type; isRemove = false; dateTime = DateTime.Now.AddMilliseconds(interval + delay); &#125; public void Run() &#123; if (type == TimerType.Sync) &#123; TimerUtils.AddAction(id, action); &#125; else &#123; RunAsync(); &#125; &#125; public async Task RunAsync() &#123; await Task.Run(() =&gt; &#123; action.Invoke(); &#125;); &#125; public bool CheckLoop() &#123; if (isRemove) &#123; return false; &#125; if (loopTimes &lt; 0) &#123; dateTime = DateTime.Now.AddMilliseconds(interval); return true; &#125; else &#123; loopTimes--; dateTime = DateTime.Now.AddMilliseconds(interval); return loopTimes &gt; 0; &#125; &#125;&#125; TimerChain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;public class TimerChain&#123; private TimeWheel _timeWheel; //private int _id = -1; private TimerTask _task; private int _delay = 0; public TimerChain(TimeWheel wheel) &#123; _timeWheel = wheel; &#125; public TimerChain Once(int delay, Action action) &#123; _task = _timeWheel.SetTimeout(_task != null ? _task.id : -1, delay + _delay, action); _delay = delay; return this; &#125; public TimerChain Loop(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; _task = _timeWheel.SetInterval(_task != null ? _task != null ? _task.id : -1 : -1, interval, action, delay + _delay, loopTimes); ; _delay = interval * loopTimes + delay; return this; &#125; public TimerChain OnceAsync(int delay, Action action) &#123; _task = _timeWheel.SetTimeoutAsync(_task != null ? _task.id : -1, delay + _delay, action); _delay = delay; return this; &#125; public TimerChain LoopAsync(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; _task = _timeWheel.SetIntervalAsync(_task != null ? _task.id : -1, interval, action, delay + _delay, loopTimes); _delay = interval * loopTimes + delay; return this; &#125; public TimerChain Clear() &#123; _task.isRemove = true; _timeWheel.ClearInterval(_task != null ? _task.id : -1, true); //ConsoleUtils.Log(&quot;清除任务Chain&quot;, _task.id); return this; &#125; public int GetId() &#123; return _task != null ? _task.id : -1; &#125;&#125; TimerUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using System;using System.Threading;using UnityEngine;public class TimerUtils&#123; private static TimeWheel _timeWheel; private static Thread _thread; private static bool _isRunning = false; private static TimerScript _timerScript; public static void Init() &#123; _timeWheel = new TimeWheel(); _isRunning = true; _thread = new Thread(Update); _thread.Start(); GameObject obj = new GameObject(); obj.name = &quot;TimerUtils&quot;; _timerScript = obj.AddComponent&lt;TimerScript&gt;(); &#125; public static void Stop() &#123; _isRunning = false; //_thread.Abort(); &#125; private static void Update() &#123; while (_isRunning) &#123; _timeWheel.Update(); &#125; &#125; /// &lt;summary&gt; /// 同步定时器 /// &lt;/summary&gt; /// &lt;param name=&quot;delay&quot;&gt;延时 单位毫秒&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain Once(int delay, Action action) &#123; return new TimerChain(_timeWheel).Once(delay, action); &#125; /// &lt;summary&gt; /// 同步循环 第一次触发时间为 interval + delay /// &lt;/summary&gt; /// &lt;param name=&quot;interval&quot;&gt;循环间隔时间&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;param name=&quot;delay&quot;&gt;延时&lt;/param&gt; /// &lt;param name=&quot;loopTimes&quot;&gt;循环次数 默认为-1 无限循环&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain Loop(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; return new TimerChain(_timeWheel).Loop(interval, action, delay, loopTimes); &#125; /// &lt;summary&gt; /// 异步定时器 /// &lt;/summary&gt; /// &lt;param name=&quot;delay&quot;&gt;延时 单位毫秒&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain OnceAsync(int delay, Action action) &#123; return new TimerChain(_timeWheel).OnceAsync(delay, action); &#125; /// &lt;summary&gt; /// 异步循环 第一次触发时间为 interval + delay /// &lt;/summary&gt; /// &lt;param name=&quot;interval&quot;&gt;循环间隔时间&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;param name=&quot;delay&quot;&gt;延时&lt;/param&gt; /// &lt;param name=&quot;loopTimes&quot;&gt;循环次数 默认为-1 无限循环&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain LoopAsync(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; return new TimerChain(_timeWheel).LoopAsync(interval, action, delay, loopTimes); &#125; public static TimerChain Clear(TimerChain chain) &#123; chain.Clear(); return chain; &#125; public static void AddAction(int id, Action action) &#123; _timerScript.AddAction(id, action); &#125;&#125; TimeWheel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269using System;using System.Collections.Generic;using System.Linq;public class TimeWheel&#123; private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _month = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _day = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _hour = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _minute = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _second = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _millisecond = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); //private long _curTime = 0; private int _id = 0; private object _lock = new object(); public TimeWheel() &#123; ConsoleUtils.Log(DateTime.Now); for (int i = 0; i &lt; 13; i++) &#123; _month.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 31; i++) &#123; _day.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 24; i++) &#123; _hour.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 60; i++) &#123; _minute.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 60; i++) &#123; _second.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; //毫秒级粒度为50ms for (int i = 0; i &lt; 20; i++) &#123; _millisecond.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; &#125; public void Update() &#123; lock (_lock) &#123; DateTime now = DateTime.Now; LinkedList&lt;TimerTask&gt; month = _month[now.Month]; LinkedList&lt;TimerTask&gt; day = _day[now.Day]; LinkedList&lt;TimerTask&gt; hour = _hour[now.Hour]; LinkedList&lt;TimerTask&gt; minute = _minute[now.Minute]; LinkedList&lt;TimerTask&gt; second = _second[now.Second]; int milliSecondDelta = now.Millisecond / 50; LinkedList&lt;TimerTask&gt; millisecond = _millisecond[milliSecondDelta]; while (month.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = month.First; month.RemoveFirst(); //添加到日轮 _day[node.Value.dateTime.Day].AddLast(node); &#125; while (day.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = day.First; day.RemoveFirst(); //添加到小时轮 _hour[node.Value.dateTime.Hour].AddLast(node); &#125; while (hour.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = hour.First; hour.RemoveFirst(); //添加到分轮 _minute[node.Value.dateTime.Minute].AddLast(node); &#125; while (minute.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = minute.First; minute.RemoveFirst(); //添加到秒轮 _second[node.Value.dateTime.Second].AddLast(node); &#125; while (second.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = second.First; second.RemoveFirst(); //添加到毫秒轮 _millisecond[node.Value.dateTime.Millisecond / 50].AddLast(node); &#125; while (millisecond.Count &gt; 0) &#123; //LinkedListNode&lt;TimerTask&gt; node = second.First; //second.RemoveFirst(); ////添加到毫秒轮 //_millisecond[node.Value.dateTime.Millisecond / 50].AddLast(node); foreach (var task in millisecond.ToList()) &#123; if (task != null &amp;&amp; DateTime.Now &gt;= task.dateTime) &#123; millisecond.Remove(task); //ConsoleUtils.Log(&quot;执行任务&quot;, task.id); //task.RunAsync(); task.Run(); if (task.CheckLoop()) &#123; AddTask(task); &#125; &#125; &#125; &#125; &#125; &#125; public TimerTask SetInterval(int id, int interval, Action action, int delay, int loopTimes, bool isRemove = false) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, interval, action, loopTimes, delay, TimerType.Sync); AddTask(task); return task; &#125; public TimerTask SetTimeout(int id, int delay, Action action) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, 0, action, 1, delay, TimerType.Sync); AddTask(task); return task; &#125; public TimerTask SetIntervalAsync(int id, int interval, Action action, int delay, int loopTimes) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, interval, action, loopTimes, delay, TimerType.Async); AddTask(task); return task; &#125; public TimerTask SetTimeoutAsync(int id, int delay, Action action) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, 0, action, 1, delay, TimerType.Async); AddTask(task); return task; &#125; public void ClearInterval(int id, bool isAll = false) &#123; if (isAll) &#123; RemoveTask(_month, id, isAll); RemoveTask(_day, id, isAll); RemoveTask(_hour, id, isAll); RemoveTask(_minute, id, isAll); RemoveTask(_second, id, isAll); RemoveTask(_millisecond, id, isAll); &#125; else &#123; if (RemoveTask(_month, id)) &#123; return; &#125; if (RemoveTask(_day, id)) &#123; return; &#125; if (RemoveTask(_hour, id)) &#123; return; &#125; if (RemoveTask(_minute, id)) &#123; return; &#125; if (RemoveTask(_second, id)) &#123; return; &#125; if (RemoveTask(_millisecond, id)) &#123; return; &#125; &#125; &#125; private void AddTask(TimerTask task) &#123; _month[task.dateTime.Month].AddLast(task); &#125; private bool RemoveTask(Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; wheel, int id, bool isAll = false) &#123; if (isAll) &#123; bool res = false; foreach (var item in wheel) &#123; LinkedList&lt;TimerTask&gt; tasks = item.Value; foreach (var task in tasks.ToList()) &#123; if (task.id == id) &#123; //ConsoleUtils.Log(&quot;清除任务&quot;, task.id, task.isRemove); tasks.Remove(task); res = true; &#125; &#125; &#125; return res; &#125; else &#123; foreach (var item in wheel) &#123; LinkedList&lt;TimerTask&gt; tasks = item.Value; foreach (var task in tasks) &#123; if (task.id == id) &#123; tasks.Remove(task); return true; &#125; &#125; &#125; return false; &#125; &#125; private int GetId() &#123; return _id++; &#125;&#125; TimerScript12345678910111213141516171819202122232425262728293031323334using System;using System.Collections.Generic;using UnityEngine;public class TimerScript : MonoBehaviour&#123; private Queue&lt;(int, Action)&gt; _actions = new Queue&lt;(int, Action)&gt;(); private Dictionary&lt;int, bool&gt; _register = new Dictionary&lt;int, bool&gt;(); void Update() &#123; while (_actions.Count &gt; 0) &#123; (int, Action) item = _actions.Dequeue(); Run(item.Item2); _register.Remove(item.Item1); &#125; &#125; public void AddAction(int id, Action action) &#123; if (!_register.ContainsKey(id)) &#123; _actions.Enqueue((id, action)); _register.Add(id, true); &#125; &#125; private void Run(Action action) &#123; action.Invoke(); &#125;&#125; 更新日志2023-12-20 修复 bug 2023-12-20 更新基础版本。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Unity编辑器拓展-自定义Mono脚本Inspector","slug":"Unity编辑器拓展-自定义Mono脚本Inspector","date":"2023-11-28T19:03:01.000Z","updated":"2024-05-18T15:36:49.319Z","comments":true,"path":"article/5b49262a8f1d/","link":"","permalink":"https://busyogg.github.io/article/5b49262a8f1d/","excerpt":"","text":"简介有时候我们需要在某个功能开启的情况下编辑一些参数，这时候就可以自定义 Inspector 面板的显示逻辑来实现这一需求。 原理Unity 提供自定义编辑器的功能，通过使用属性标签[CustomEditor(typeof(CustomClass))]定义一个编辑器类来自定义我们需要的 Inspector 显示。如果需要多选编辑的话，只要再加一个属性标签[CanEditMultipleObjects]即可。 实现我们需要一个原始的 MonoBehaviour 类，以及一个派生 Editor 的类，即我们自定义修改某一 MonoBehaviour 类显示面板的类。 假设我们有一个 MonoBehaviour 类如下： MonoBehaviour类123456using UnityEngine;public class Test : MonoBehaviour&#123; public bool _isShow = false; public int _initNum = 0;&#125; 我们要实现如下需求：当_isShow 为 true 的时候在面板上显示_initNum。 我们需要这样一个 Editor 类： 12345678910111213141516171819using UnityEditor;[CustomEditor(typeof(Test))][CanEditMultipleObjects]public class TestEditor : Editor&#123; public override void OnInspectorGUI() &#123; Test test = (Test)target; test._isShow = EditorGUILayout.Toggle(&quot;是否显示&quot;, test._isShow); if(test._isShow) &#123; EditorGUI.indentLevel++; test._initNum = EditorGUILayout.IntField(&quot;InitNum&quot;, test._initNum); EditorGUI.indentLevel--; &#125; &#125;&#125; Editor 类的编写方式和普通的 Editor 拓展一样，需要注意的是没有写的属性也不会出现在 Inspector 中，这个类相当于完全接管原来的面板显示逻辑。 为了更好分辨面板属性层级，我们也可以用EditorGUI.indentLevel来缩进。或者使用EditorGUILayout.Space()，根据具体情况即可。 当然，显示属性的方法也可以和官方文档一样。具体直接看官方文档即可。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"红点系统","slug":"红点系统","date":"2023-11-09T07:43:02.000Z","updated":"2024-05-18T15:40:07.308Z","comments":true,"path":"article/5daef1721d9d/","link":"","permalink":"https://busyogg.github.io/article/5daef1721d9d/","excerpt":"","text":"简介游戏中经常会需要红点来提醒玩家有新内容，每个部分单独控制红点显然不是个好办法，因此需要红点系统来统一管理红点。 原理所有红点根据层级关系组织成红点树，每次有数据变化就从红点树的叶子结点开始向上更新。 红点树属性红点数有_children 来保存所有下属节点，有_parent 来回溯上游节点，并且每个节点都有_path 来记录红点在红点树中的路径。 _dotNum 表示当前红点节点的数据，_isShow 用来控制当前红点节点是否需要显示红点。 红点_type 分为两类，一类是 Eternal，只有红点数量归零的时候才不显示；一类是 Once，一旦红点数量变少就不再显示。 当红点数量发生变化的时候会调用_onRedDotChangedCallback 方法执行对应的操作。 1234567891011121314151617181920212223export enum RedDotType &#123; Eternal, Once,&#125;export default class RedDot &#123; /** 父节点 */ private _parent: RedDot | null; /** 子节点 */ private _children; /** 红点节点路径 */ public _path: string; /** 红点数量 */ private _dotNum; /** 是否展示红点 */ private _isShow; /** 红点类型 */ private _type: RedDotType; private _onRedDotChangedCallback: Function | null; //----- function start -----&#125; 方法添加红点子节点先获取需要添加的红点节点的路径，判断是否已添加。未添加的情况下我们设置当前红点节点的子节点为需要添加的节点，设置需要添加节点的父节点为当前节点，并且走一遍红点变化的逻辑，防止出现 bug。 12345678910111213141516171819/** * 添加红点子节点 * @param child */public addChild(child: RedDot) &#123; let path = child._path; if (!this._children[path]) &#123; this._children[path] = child; child._parent = this; //子节点有展示红点 则该节点必展示红点 if (child._isShow) &#123; this._isShow = true; &#125; //改变红点数量 this.changeDotNum(child.getDotNum()); &#125; else &#123; console.warn(&quot;红点节点重复添加：&quot;, path); &#125;&#125; 改变红点数量首先我们保存当前节点的红点数量，然后根据传入的变化数量对当前节点红点数量进行改变。 改变之后会发生两种情况： 红点数量小于等于 0，这时候我们置红点为不显示。 红点数量大于 0，如果传入的变化量大于 0，则红点显示；否则根据红点类型判断，如果是 Once，则红点数量归零，并且置为不显示。 处理完当前节点的红点数量后，我们回溯父节点，对父节点进行同样的操作。不过传入的变化量需要根据当前节点是否显示红点来判断，如果是不显示红点，则我们传入负的之前保存的节点红点数量；显示红点，则传入该方法传入的参数。 1234567891011121314151617181920212223242526/** * 改变红点数量 * @param num */public changeDotNum(num: number) &#123; let defDotNum = this._dotNum; this._dotNum += num; //判断是否展示红点 if (this._dotNum &lt;= 0) &#123; this._dotNum = 0; this._isShow = false; &#125; else &#123; if(num &gt; 0)&#123; this._isShow = true; &#125;else&#123; if(this._type == RedDotType.Once)&#123; this._dotNum = 0; this._isShow = false; &#125; &#125; &#125; //触发红点变化回调 this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow); //父节点改变红点数量 this._parent &amp;&amp; this._parent.changeDotNum(this._isShow ? num : -defDotNum);&#125; 其他基础功能，根据函数内容即可得知作用。 1234567891011121314151617181920212223242526272829303132333435/** * 获得所有子节点 * @returns */public getChildren()&#123; return this._children;&#125;/** * 是否展示红点 * @returns */public checkShow() &#123; this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow);&#125;/** * 获得红点数量 * @returns */public getDotNum() &#123; return this._dotNum;&#125;/** * 设置红点变化回调 * @param callback */public onRedDotChanged(callback) &#123; this._onRedDotChangedCallback = callback;&#125;/** * 移除红点变化回调 */public removeRedDotChange()&#123; this._onRedDotChangedCallback = null;&#125; 红点管理类管理类维护一个红点字典_redDotDic，用于快速查找对应路径的红点。 初始化初始化一个 root 红点，该红点是所有红点的根节点。 12345678/** * 初始化红点树 */public init() &#123; let root = new RedDot(null, RedDotType.Eternal); root._path = &quot;root&quot;; this._redDotDic[&quot;root&quot;] = root;&#125; 注册红点用于注册红点的方法。先判断红点是否已注册，未注册的情况下执行注册方法： 裁剪红点路径，根据”&#x2F;“分开。 根据红点路径长度循环判断是否注册过红点，未注册则新建红点并保存到红点字典，红点路径每次也会根据红点层级拼接。如果新建的红点是最终路径，则返回该红点。 123456789101112131415161718192021222324252627282930313233/** * 注册红点 * @param redDot */public register(path: string, type: RedDotType = RedDotType.Eternal): RedDot &#123; let leaf = this.getRedDot(path); if (!leaf) &#123; let redDotPath = path.split(&quot;/&quot;); let index = 0; let curDic = this._redDotDic[&quot;root&quot;] as RedDot; let subPath = &quot;&quot;; while (index &lt; redDotPath.length) &#123; let child = curDic.getChildren()[redDotPath[index]]; subPath += (index == 0 ? &quot;&quot; : &quot;/&quot;) + redDotPath[index]; if (!child) &#123; let newRedDot = new RedDot(null, type); newRedDot._path = subPath; curDic.addChild(newRedDot); if (index == redDotPath.length - 1) &#123; leaf = newRedDot; &#125; child = newRedDot; this._redDotDic[subPath] = child; &#125; curDic = child; index++; &#125; &#125; return leaf;&#125; 其他基础功能，根据函数内容即可得知作用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 改变红点数据 * @param path * @param num */public changeDotNum(path, num) &#123; let redDot = this.getRedDot(path); if (redDot) &#123; redDot.changeDotNum(num); &#125; else &#123; console.warn(&quot;不存在该红点&quot;, path); &#125;&#125;/** * 设置红点回调 * @param path * @param callback */public setRedDotCallback(path,callback)&#123; let redDot = this.getRedDot(path); if(redDot)&#123; redDot.onRedDotChanged(callback); &#125;&#125;/** * 移除红点回调 * @param path */public removeRedDotCallback(path)&#123; let redDot = this.getRedDot(path); if(redDot)&#123; redDot.removeRedDotChange(); &#125;&#125;/** * 获得红点 * @param path * @returns */private getRedDot(path: string): RedDot &#123; return this._redDotDic[path];&#125;public getRoot() &#123; return this._redDotDic[&quot;root&quot;];&#125; 代码RedDot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import &#123; RedDotType &#125; from &quot;./RedDotManager&quot;;export default class RedDot &#123; /** 父节点 */ private _parent: RedDot | null; /** 子节点 */ private _children; /** 红点节点路径 */ public _path: string; /** 红点数量 */ private _dotNum; /** 是否展示红点 */ private _isShow; /** 红点类型 */ private _type: RedDotType; private _onRedDotChangedCallback: Function | null; public constructor(parent = null, type = RedDotType.Eternal) &#123; this._parent = parent; this._children = &#123;&#125;; this._dotNum = 0; this._isShow = false; this._type = type; &#125; /** * 添加红点子节点 * @param child */ public addChild(child: RedDot) &#123; let path = child._path; if (!this._children[path]) &#123; this._children[path] = child; child._parent = this; //子节点有展示红点 则该节点必展示红点 if (child._isShow) &#123; this._isShow = true; &#125; //改变红点数量 this.changeDotNum(child.getDotNum()); &#125; else &#123; console.warn(&quot;红点节点重复添加：&quot;, path); &#125; &#125; /** * 获得所有子节点 * @returns */ public getChildren() &#123; return this._children; &#125; /** * 是否展示红点 * @returns */ public checkShow() &#123; this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow); &#125; /** * 改变红点数量 * @param num */ public changeDotNum(num: number) &#123; let defDotNum = this._dotNum; this._dotNum += num; //判断是否展示红点 if (this._dotNum &lt;= 0) &#123; this._dotNum = 0; this._isShow = false; &#125; else &#123; if (num &gt; 0) &#123; this._isShow = true; &#125; else &#123; if (this._type == RedDotType.Once) &#123; this._dotNum = 0; this._isShow = false; &#125; &#125; &#125; //触发红点变化回调 this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow); //父节点改变红点数量 this._parent &amp;&amp; this._parent.changeDotNum(this._isShow ? num : -defDotNum); &#125; /** * 获得红点数量 * @returns */ public getDotNum() &#123; return this._dotNum; &#125; /** * 设置红点变化回调 * @param callback */ public onRedDotChanged(callback) &#123; this._onRedDotChangedCallback = callback; &#125; /** * 移除红点变化回调 */ public removeRedDotChange() &#123; this._onRedDotChangedCallback = null; &#125;&#125; RedDotManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import RedDot from &quot;./RedDot&quot;;export enum RedDotType &#123; Eternal, Once,&#125;export default class RedDotManager &#123; private static _instance: RedDotManager | null = null; /** 红点字典 */ private _redDotDic = &#123;&#125;; public static getInst(): RedDotManager &#123; if (!this._instance) &#123; this._instance = new RedDotManager(); &#125; return this._instance; &#125; /** * 初始化红点树 */ public init() &#123; let root = new RedDot(null, RedDotType.Eternal); root._path = &quot;root&quot;; this._redDotDic[&quot;root&quot;] = root; &#125; /** * 注册红点 * @param redDot */ public register(path: string, type: RedDotType = RedDotType.Eternal): RedDot &#123; let leaf = this.getRedDot(path); if (!leaf) &#123; let redDotPath = path.split(&quot;/&quot;); let index = 0; let curDic = this._redDotDic[&quot;root&quot;] as RedDot; let subPath = &quot;&quot;; while (index &lt; redDotPath.length) &#123; let child = curDic.getChildren()[redDotPath[index]]; subPath += (index == 0 ? &quot;&quot; : &quot;/&quot;) + redDotPath[index]; if (!child) &#123; let newRedDot = new RedDot(null, type); newRedDot._path = subPath; curDic.addChild(newRedDot); if (index == redDotPath.length - 1) &#123; leaf = newRedDot; &#125; child = newRedDot; this._redDotDic[subPath] = child; &#125; curDic = child; index++; &#125; &#125; return leaf; &#125; /** * 改变红点数据 * @param path * @param num */ public changeDotNum(path, num) &#123; let redDot = this.getRedDot(path); if (redDot) &#123; redDot.changeDotNum(num); &#125; else &#123; console.warn(&quot;不存在该红点&quot;, path); &#125; &#125; /** * 设置红点回调 * @param path * @param callback */ public setRedDotCallback(path, callback) &#123; let redDot = this.getRedDot(path); if (redDot) &#123; redDot.onRedDotChanged(callback); &#125; &#125; /** * 移除红点回调 * @param path */ public removeRedDotCallback(path) &#123; let redDot = this.getRedDot(path); if (redDot) &#123; redDot.removeRedDotChange(); &#125; &#125; /** * 获得红点 * @param path * @returns */ private getRedDot(path: string): RedDot &#123; return this._redDotDic[path]; &#125; public getRoot() &#123; return this._redDotDic[&quot;root&quot;]; &#125;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"}]},{"title":"任务系统","slug":"任务系统","date":"2023-11-07T12:41:52.000Z","updated":"2024-05-30T12:26:57.400Z","comments":true,"path":"article/bcdc7baf0eb9/","link":"","permalink":"https://busyogg.github.io/article/bcdc7baf0eb9/","excerpt":"","text":"简介基于任务树的任务系统，支持普通任务、分支任务，一个系列任务以树的形式保存。任务支持多需求、多奖励。任务进度支持任务开启后统计和预统计。 后续会更新其他功能。 演示 原理任务管理类设置三个字典_lockedMission、_unlockedMission、_doneMission来保存未解锁任务，已解锁任务和已完成任务。 任务数据结构 任务树自身与之间的结构如图所示。 不同任务以树的形式链接，单个任务以链表的形式链接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using System.Collections.Generic;using UnityEngine;public class MissionTree&#123; /// &lt;summary&gt; /// 任务步骤id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务id /// &lt;/summary&gt; public int m_id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务标题 /// &lt;/summary&gt; public string title &#123; get; set; &#125; /// &lt;summary&gt; /// 任务描述 /// &lt;/summary&gt; public string describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类型 /// &lt;/summary&gt; public MissionType type &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类别 /// &lt;/summary&gt; public MissionFilter filter &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标 /// &lt;/summary&gt; public List&lt;int&gt; target &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标描述 /// &lt;/summary&gt; public List&lt;string&gt; target_describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; target_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务完成数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; complete_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励 /// &lt;/summary&gt; public List&lt;string&gt; award &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励数量 /// &lt;/summary&gt; public List&lt;float&gt; award_num &#123; get; set; &#125; /// &lt;summary&gt; /// 是否预统计 /// &lt;/summary&gt; public bool is_pre_count &#123; get; set; &#125; /// &lt;summary&gt; /// 下一任务 /// &lt;/summary&gt; public MissionTree next &#123; get; set; &#125; /// &lt;summary&gt; /// 任务解锁列表 /// &lt;/summary&gt; public List&lt;int&gt; unlock_mission &#123; get; set; &#125; /// &lt;summary&gt; /// 任务分支 /// &lt;/summary&gt; public List&lt;int&gt; branch &#123; get; set; &#125; /// &lt;summary&gt; /// 分支所属任务 /// &lt;/summary&gt; public int branch_belong &#123; get; set; &#125; /// &lt;summary&gt; /// 是否直接解锁 /// &lt;/summary&gt; public bool is_pre_unlock &#123; get; set; &#125; public MissionTree() &#123; target = new List&lt;int&gt;(); target_num = new Dictionary&lt;int, float&gt;(); complete_num = new Dictionary&lt;int, float&gt;(); award = new List&lt;string&gt;(); award_num = new List&lt;float&gt;(); unlock_mission = new List&lt;int&gt;(); target_describe = new List&lt;string&gt;(); branch = new List&lt;int&gt;(); &#125;&#125; 判断任务完成判断任务完成需要判断所有的任务目标完成数量是否都大于等于任务目标需求数量。这里我们遍历任务目标，只要有一个目标数量不达标就可以判断任务未完成。 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 检测任务是否完成/// &lt;/summary&gt;/// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool CheckComplete(MissionTree mission)&#123; for (int i = 0, len = mission.target.Count; i &lt; len; i++) &#123; int target = mission.target[i]; if (mission.is_pre_count) &#123; if (mission.target_num[target] &gt; _preCount[target]) &#123; return false; &#125; &#125; else &#123; if (mission.complete_num.Count == 0 || mission.target_num[target] &gt; mission.complete_num[target]) &#123; return false; &#125; &#125; &#125; return true;&#125; 增加任务目标数量任务目标数量的增加调用SetCompleteNum方法，默认是累加模式。预统计数量的增加则是通过RefreshPreCountNum方法保存数据到_preCount字典中，以供预统计类型任务使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/// &lt;summary&gt;/// 刷新预计数类型任务的完成数量/// &lt;/summary&gt;/// &lt;param name=&quot;targetId&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;public void RefreshPreCountNum(int targetId, float num, bool isAdd = false)&#123; if (!_preCount.ContainsKey(targetId)) &#123; _preCount.Add(targetId, 0); &#125; if (isAdd) &#123; _preCount[targetId] += num; &#125; else &#123; _preCount[targetId] = num; &#125;&#125;/// &lt;summary&gt;/// 设置任务完成数量/// &lt;/summary&gt;/// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;completeNum&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;isAdd&quot;&gt;&lt;/param&gt;public void SetCompleteNum(int missionId, int targetId, float completeNum, bool isAdd = true)&#123; MissionTree mission; _unlockedMission.TryGetValue(missionId, out mission); if (mission != null) &#123; if (!mission.complete_num.ContainsKey(targetId)) &#123; mission.complete_num.Add(targetId, 0); &#125; if (isAdd) &#123; mission.complete_num[targetId] += completeNum; &#125; else &#123; mission.complete_num[targetId] = completeNum; &#125; //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, false); &#125;&#125; 下一任务任务完成的时候除了推进本任务链的任务以外，还要检测是否有可以解锁的任务，可以解锁则把其从_lockedMission转移到_unlockedMission，任务链完成则转移到_doneMission。在完成任务的时候，调用奖励方法来发放奖励。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void Next(MissionTree mission)&#123; //MissionTree mission = _unlockedMission[missionId]; int missionId = mission.m_id; MissionTree next = mission.next; if (next != null) &#123; if (mission.unlock_mission.Count &gt; 0) &#123; for (int i = 0, len = mission.unlock_mission.Count; i &lt; len; i++) &#123; int id = mission.unlock_mission[i]; MissionTree unlockMission = _lockedMission[id]; _unlockedMission.Add(unlockMission.m_id, unlockMission); _lockedMission.Remove(id); //保存数据 SaveMissionData(id, unlockMission.id, unlockMission.complete_num, false); &#125; &#125; //下一任务 _unlockedMission[missionId] = next; //保存数据 SaveMissionData(missionId, next.id, next.complete_num, false); &#125; else &#123; _unlockedMission.Remove(missionId); _doneMission.Add(missionId, mission); //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, true); &#125; //获得奖励 GetAward(mission); if (mission.filter == MissionFilter.Branch) &#123; bool missionDone = true; foreach (var id in mission.branch) &#123; MissionTree branch = GetUnlockedMissionById(id); if (mission != null) &#123; missionDone = false; break; &#125; &#125; if (!missionDone) &#123; Next(GetUnlockedMissionById(mission.branch_belong)); &#125; &#125;&#125; UI因为任务面板 UI 是简单拼凑，因此在此不做介绍。有关任务面板滚动列表的说明见滚动列表 代码MissionTree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Collections.Generic;using UnityEngine;public class MissionTree&#123; /// &lt;summary&gt; /// 任务步骤id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务id /// &lt;/summary&gt; public int m_id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务标题 /// &lt;/summary&gt; public string title &#123; get; set; &#125; /// &lt;summary&gt; /// 任务描述 /// &lt;/summary&gt; public string describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类型 /// &lt;/summary&gt; public MissionType type &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类别 /// &lt;/summary&gt; public MissionFilter filter &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标 /// &lt;/summary&gt; public List&lt;int&gt; target &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标描述 /// &lt;/summary&gt; public List&lt;string&gt; target_describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; target_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务完成数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; complete_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励 /// &lt;/summary&gt; public List&lt;string&gt; award &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励数量 /// &lt;/summary&gt; public List&lt;float&gt; award_num &#123; get; set; &#125; /// &lt;summary&gt; /// 是否预统计 /// &lt;/summary&gt; public bool is_pre_count &#123; get; set; &#125; /// &lt;summary&gt; /// 下一任务 /// &lt;/summary&gt; public MissionTree next &#123; get; set; &#125; /// &lt;summary&gt; /// 任务解锁列表 /// &lt;/summary&gt; public List&lt;int&gt; unlock_mission &#123; get; set; &#125; /// &lt;summary&gt; /// 任务分支 /// &lt;/summary&gt; public List&lt;int&gt; branch &#123; get; set; &#125; /// &lt;summary&gt; /// 分支所属任务 /// &lt;/summary&gt; public int branch_belong &#123; get; set; &#125; /// &lt;summary&gt; /// 是否直接解锁 /// &lt;/summary&gt; public bool is_pre_unlock &#123; get; set; &#125; public MissionTree() &#123; target = new List&lt;int&gt;(); target_num = new Dictionary&lt;int, float&gt;(); complete_num = new Dictionary&lt;int, float&gt;(); award = new List&lt;string&gt;(); award_num = new List&lt;float&gt;(); unlock_mission = new List&lt;int&gt;(); target_describe = new List&lt;string&gt;(); branch = new List&lt;int&gt;(); &#125;&#125; MissionManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423using System.Collections;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using UnityEngine;public enum MissionType&#123; Find, Collection, Kill&#125;public enum MissionFilter&#123; Main, Sub, Branch//这个类型一定放最后 因为该类型不参与计算，枚举数不能影响计算&#125;/// &lt;summary&gt;/// 任务管理器/// &lt;para&gt;请在预统计物品数量（即背包、杀人数等）加载之前加载本类，并且在预统计物品数量加载时执行RefreshPreCountNum方法&lt;/para&gt;/// &lt;/summary&gt;public class MissionManager&#123; private static MissionManager instance; private Dictionary&lt;int, MissionTree&gt; _lockedMission = new Dictionary&lt;int, MissionTree&gt;(); private Dictionary&lt;int, MissionTree&gt; _unlockedMission = new Dictionary&lt;int, MissionTree&gt;(); private Dictionary&lt;int, MissionTree&gt; _doneMission = new Dictionary&lt;int, MissionTree&gt;(); private Dictionary&lt;int, MissionSaveData&gt; _missionSaveData = new Dictionary&lt;int, MissionSaveData&gt;(); private Dictionary&lt;int, float&gt; _preCount = new Dictionary&lt;int, float&gt;(); private MissionTree _curMission; public static MissionManager Instance() &#123; if (instance == null) &#123; instance = new MissionManager(); &#125; return instance; &#125; private MissionManager() &#123; &#125; /// &lt;summary&gt; /// 加载存档 /// &lt;/summary&gt; /// &lt;param name=&quot;save&quot;&gt;&lt;/param&gt; public void LoadSaveData(MissionSaveDataSO save) &#123; for (int i = 0, len = save._missionSaveDatas.Count; i &lt; len; i++) &#123; MissionSaveData missionSaveData = save._missionSaveDatas[i]; _missionSaveData.Add(missionSaveData.m_id, missionSaveData); &#125; &#125; public void Init() &#123; //硬编码数据 List&lt;MissionTree&gt; missions = new List&lt;MissionTree&gt;(); MissionTree m1 = new MissionTree(); m1.id = 0; m1.m_id = 0; m1.title = &quot;任务1-1&quot;; m1.describe = &quot;任务1-1的任务描述\\n测试换行&quot;; m1.type = MissionType.Collection; m1.filter = MissionFilter.Main; m1.is_pre_count = true; m1.target.Add(0); m1.target_describe.Add(&quot;收集id=0的物品&quot;); m1.target_num.Add(0, 2); m1.award.Add(&quot;奖励1&quot;); m1.award_num.Add(1); m1.is_pre_unlock = true; MissionTree m2 = new MissionTree(); m2.id = 1; m2.m_id = 0; m2.title = &quot;任务1-2&quot;; m2.describe = &quot;任务1-2的任务描述&quot;; m2.type = MissionType.Collection; m2.filter = MissionFilter.Main; m2.is_pre_count = false; m2.target.Add(0); m2.target_describe.Add(&quot;收集id=0的物品&quot;); m2.target_num.Add(0, 2); //m2.award.Add(&quot;奖励1&quot;); //m2.award_num.Add(1); m1.next = m2; MissionTree m3 = new MissionTree(); m3.id = 0; m3.m_id = 1; m3.title = &quot;任务2-1&quot;; m3.describe = &quot;任务2-1的任务描述&quot;; m3.type = MissionType.Collection; m3.filter = MissionFilter.Sub; m3.is_pre_count = false; m3.target.Add(0); m3.target_describe.Add(&quot;收集id=0的物品&quot;); m3.target_num.Add(0, 2); m3.award.Add(&quot;奖励1&quot;); m3.award_num.Add(1); //m3.is_pre_unlock = true; MissionTree m4 = new MissionTree(); m4.id = 0; m4.m_id = 2; m4.title = &quot;任务3-1&quot;; m4.describe = &quot;任务3-1的任务描述&quot;; m4.type = MissionType.Collection; m4.filter = MissionFilter.Branch; m4.is_pre_count = false; m4.target.Add(0); m4.target_describe.Add(&quot;收集id=0的物品&quot;); m4.target_num.Add(0, 2); m4.award.Add(&quot;奖励1&quot;); m4.award_num.Add(1); m4.is_pre_unlock = true; m4.branch_belong = 0; MissionTree m5 = new MissionTree(); m5.id = 0; m5.m_id = 3; m5.title = &quot;任务4-1&quot;; m5.describe = &quot;任务4-1的任务描述&quot;; m5.type = MissionType.Collection; m5.filter = MissionFilter.Branch; m5.is_pre_count = false; m5.target.Add(0); m5.target_describe.Add(&quot;收集id=0的物品&quot;); m5.target_num.Add(0, 2); m5.award.Add(&quot;奖励1&quot;); m5.award_num.Add(1); m5.is_pre_unlock = true; m5.branch_belong = 0; m1.unlock_mission.Add(1); m2.branch.Add(2); m2.branch.Add(3); missions.Add(m1); missions.Add(m3); missions.Add(m4); missions.Add(m5); //初始化 for (int i = 0, len = missions.Count; i &lt; len; i++) &#123; MissionTree mission = missions[i]; MissionSaveData missionSaveData; _missionSaveData.TryGetValue(mission.m_id, out missionSaveData); if (missionSaveData != null) &#123; if (missionSaveData.isDone) &#123; _doneMission.Add(mission.m_id, mission); &#125; else &#123; while (mission.id != missionSaveData.id) &#123; mission = mission.next; &#125; _unlockedMission.Add(mission.m_id, mission); mission.complete_num = missionSaveData.complete_num; &#125; &#125; else &#123; if (mission.is_pre_unlock) &#123; _unlockedMission.Add(mission.m_id, mission); &#125; else &#123; _lockedMission.Add(mission.m_id, mission); &#125; &#125; &#125; &#125; public MissionTree GetCurMission() &#123; return _curMission; &#125; public Dictionary&lt;int, MissionTree&gt; GetUnlockedMission() &#123; return _unlockedMission; &#125; public Dictionary&lt;int, MissionTree&gt; GetDoneMission() &#123; return _doneMission; &#125; public MissionTree GetUnlockedMissionById(int id) &#123; MissionTree missionTree; _unlockedMission.TryGetValue(id, out missionTree); return missionTree; &#125; /// &lt;summary&gt; /// 获得任务筛选类型文字描述 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetMissionFilterString(MissionFilter type) &#123; switch (type) &#123; case MissionFilter.Main: default: return &quot;主线&quot;; case MissionFilter.Sub: return &quot;支线&quot;; &#125; &#125; /// &lt;summary&gt; /// 获得任务筛选类型 /// &lt;/summary&gt; /// &lt;param name=&quot;filter&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public MissionFilter GetMissionFileter(string filter) &#123; switch (filter) &#123; case &quot;主线&quot;: default: return MissionFilter.Main; case &quot;支线&quot;: return MissionFilter.Sub; &#125; &#125; /// &lt;summary&gt; /// 刷新预统计类型任务的完成数量 /// &lt;/summary&gt; /// &lt;param name=&quot;targetId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt; public void RefreshPreCountNum(int targetId, float num, bool isAdd = false) &#123; if (!_preCount.ContainsKey(targetId)) &#123; _preCount.Add(targetId, 0); &#125; if (isAdd) &#123; _preCount[targetId] += num; &#125; else &#123; _preCount[targetId] = num; &#125; &#125; /// &lt;summary&gt; /// 获得预统计数量 /// &lt;/summary&gt; /// &lt;param name=&quot;targetId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public float GetPreCountNum(int targetId) &#123; return _preCount[targetId]; &#125; /// &lt;summary&gt; /// 设置任务完成数量 /// &lt;/summary&gt; /// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;completeNum&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;isAdd&quot;&gt;&lt;/param&gt; public void SetCompleteNum(int missionId, int targetId, float completeNum, bool isAdd = true) &#123; MissionTree mission; _unlockedMission.TryGetValue(missionId, out mission); if (mission != null) &#123; if (!mission.complete_num.ContainsKey(targetId)) &#123; mission.complete_num.Add(targetId, 0); &#125; if (isAdd) &#123; mission.complete_num[targetId] += completeNum; &#125; else &#123; mission.complete_num[targetId] = completeNum; &#125; //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, false); &#125; &#125; /// &lt;summary&gt; /// 检测任务是否完成 /// &lt;/summary&gt; /// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool CheckComplete(MissionTree mission) &#123; for (int i = 0, len = mission.target.Count; i &lt; len; i++) &#123; int target = mission.target[i]; if (mission.is_pre_count) &#123; if (mission.target_num[target] &gt; _preCount[target]) &#123; return false; &#125; &#125; else &#123; if (mission.complete_num.Count == 0 || mission.target_num[target] &gt; mission.complete_num[target]) &#123; return false; &#125; &#125; &#125; return true; &#125; public void Next(MissionTree mission) &#123; //MissionTree mission = _unlockedMission[missionId]; int missionId = mission.m_id; MissionTree next = mission.next; if (next != null) &#123; if (mission.unlock_mission.Count &gt; 0) &#123; for (int i = 0, len = mission.unlock_mission.Count; i &lt; len; i++) &#123; int id = mission.unlock_mission[i]; MissionTree unlockMission = _lockedMission[id]; _unlockedMission.Add(unlockMission.m_id, unlockMission); _lockedMission.Remove(id); //保存数据 SaveMissionData(id, unlockMission.id, unlockMission.complete_num, false); &#125; &#125; //下一任务 _unlockedMission[missionId] = next; //保存数据 SaveMissionData(missionId, next.id, next.complete_num, false); &#125; else &#123; _unlockedMission.Remove(missionId); _doneMission.Add(missionId, mission); //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, true); &#125; //获得奖励 GetAward(mission); if (mission.filter == MissionFilter.Branch) &#123; MissionTree branchMissionRoot = GetUnlockedMissionById(mission.branch_belong); bool missionDone = true; foreach (var id in branchMissionRoot.branch) &#123; MissionTree branch = GetUnlockedMissionById(id); if (branch != null) &#123; missionDone = false; break; &#125; &#125; if (missionDone) &#123; Next(branchMissionRoot); &#125; &#125; &#125; private void GetAward(MissionTree mission) &#123; string award = &quot;&quot;; for (int i = 0, len = mission.award.Count; i &lt; len; i++) &#123; award += mission.award[i] + &quot; 数量:&quot; + mission.award_num[i]; &#125; Debug.Log(&quot;获得任务奖励 ===&gt; &quot; + award); &#125; private void SaveMissionData(int missionId, int stepId, Dictionary&lt;int, float&gt; completeNum, bool isDone) &#123; //保存数据 MissionSaveData missionSaveData; _missionSaveData.TryGetValue(missionId, out missionSaveData); if (missionSaveData == null) &#123; missionSaveData = new MissionSaveData(); missionSaveData.m_id = missionId; _missionSaveData.Add(missionId, missionSaveData); &#125; missionSaveData.id = stepId; missionSaveData.complete_num = completeNum; missionSaveData.isDone = isDone; &#125;&#125; 更新日志2023-12-12 修复分支任务判定 bug。 2023-11-7 1.更新基础版本","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"UGUI循环列表","slug":"UGUI循环列表","date":"2023-11-07T07:56:56.000Z","updated":"2024-05-18T15:37:23.587Z","comments":true,"path":"article/9d7f93194d78/","link":"","permalink":"https://busyogg.github.io/article/9d7f93194d78/","excerpt":"","text":"简介UGUI 实现滚动列表，支持非固定大小的 Item 以及多种不同的数据，可自定义单元格偏移量、单元格间隔、单元格重复数量限制，可以根据单元格重复数量自动调整滚动方向。 演示单类型单元格 复数类型单元格 使用方法UI 在 Canvas 上挂载 Scroll View 预制体，选中 Content 对象，挂载管理脚本。预制体中默认挂载了一个 TestScrollView 脚本。 PrefabItem 列表用于挂载不同的 Item 预制体，需要多少种就挂载多少个。 Stack 用于获取对象池节点，即上图的 Stack 节点。 Scroll 用于获取 Scroll View 节点。 FitSize 开启后列表将渲染所有单元格，并且面板大小自动调整为适合的大小，并禁止滚动。 SpaceX，单元格 X 方向间隔。 SpaceY，单元格 Y 方向间隔。 OffsetX，列表 X 方向偏移。 OffsetY，列表 Y 方向偏移。 RepeatX，列表 X 方向单元格最大数量。0 为无限制。 RepeatY，列表 Y 方向单元格最大数量。0 为无限制。当 RepeatX 设置后，该项失效（可能会出 bug，不建议同时设置）。 代码Content 对象挂载的脚本需要继承 ScrollViewScript。如 TestScrollView： TestScrollView123456789101112131415161718192021222324252627282930313233343536373839404142434445using System.Collections.Generic;using TMPro;public class TestScrollView : ScrollViewScript&lt;int&gt;&#123; private List&lt;int&gt; _subData = new List&lt;int&gt;(); void Awake() &#123; for (int i = 0; i &lt; 10; i++) &#123; _subData.Add(i); &#125; actions.Add(UpdateItem); actions.Add(UpdateItem); &#125; protected override void InitItemType() &#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); int i = 0; int j = 0; while (i &lt; data.Count || j &lt; _subData.Count) &#123; if (i &lt; data.Count) &#123; type.Add(new int[] &#123; 0, i++ &#125;); &#125; if (j &lt; _subData.Count) &#123; type.Add(new int[] &#123; 1, j++ &#125;); &#125; &#125; itemType = type; &#125; private void UpdateItem(ItemTransformData cell, int index) &#123; cell.item.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;单元格 &quot; + data[index]; &#125;&#125; 泛型代表了列表默认数据 data 的数据类型。对 data 赋值即可刷新列表。 列表单元格渲染函数需要在 Start 函数之前定义并存入渲染函数数组actions中。本例中在 Awake 进行初始化。有多少 Item 类型就要初始化多少渲染函数，并且顺序要一一对应。不过如果 Item 数量大于渲染函数数量，程序也不会出问题，如果是中间 Item 类型的渲染函数不存在，那就会出现渲染函数和 Item 不匹配。因此最好是一一对应。 如果需要额外的数据，那就需要重写InitItemType方法。 1234567891011121314/// &lt;summary&gt;/// 初始化单元格类型/// &lt;/summary&gt;/// &lt;param name=&quot;itemType&quot;&gt;int[2] 0为button类型 1为对应类型的数据索引&lt;/param&gt;protected virtual void InitItemType()&#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); for (int i = 0, len = _data.Count; i &lt; len; i++) &#123; type.Add(new int[] &#123; 0, i &#125;); &#125; itemType = type;&#125; 该方法负责管理虚拟列表中 Item 对应索引的 Item 类型和其在对应数据列表中的索引。 例如： 1234567891011121314151617181920protected override void InitItemType() &#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); int i = 0; int j = 0; while (i &lt; data.Count || j &lt; _subData.Count) &#123; if (i &lt; data.Count) &#123; type.Add(new int[] &#123; 0, i++ &#125;); &#125; if (j &lt; _subData.Count) &#123; type.Add(new int[] &#123; 1, j++ &#125;); &#125; &#125; itemType = type; &#125; _subData为任务滚动列表类自定义的属性，本例根据一个 Item0 和一个 Item1 交替填充到itemType中，即管理虚拟列表中 Item 对应索引的 Item 类型和其在对应数据列表中的索引的列表中。 注意，如果列表不是单列或单行，建议不要使用多种大小不同的 Item 混搭，本项目尚未对该情况进行适配，很有可能会出现 Item 覆盖的情况。 原理概述Item 固定大小的循环列表会在滚动面板视野外额外生成一个 Item，在上下滚动的时候通过改变额外 Item 的坐标并且重新渲染该 Item 来实现列表的滚动效果。 本项目因为需要支持非固定大小的 Item，因此使用对象池的方式来模拟。通过判断上下滚动时的头尾节点相较于滚动面板的位置来判断是要回收 Item 还是创建 Item。 单元格根据类型调用对应的渲染函数，在 data 数据发生变化的时候会刷新列表；在单元格大小发生变化时会刷新单元格坐标。 单元格数据类所有单元格都遵循该类的设置。滚动列表单元格之间按照逻辑顺序使用 next 和 parent 形成双向链表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123using UnityEngine;using UnityEngine.UI;public class ItemTransformData&#123; /// &lt;summary&gt; /// 坐标 /// &lt;/summary&gt; public Vector2 pos &#123; get &#123; return _pos; &#125; set &#123; _pos = value; item.transform.localPosition = pos; &#125; &#125; /// &lt;summary&gt; /// 高度 /// &lt;/summary&gt; public float height &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.height; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽度 /// &lt;/summary&gt; public float width &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.width; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽高 /// &lt;/summary&gt; public Vector2 size &#123; set &#123; _item_rect.sizeDelta = value; &#125; &#125; /// &lt;summary&gt; /// 虚拟列表索引 /// &lt;/summary&gt; public int cell_index &#123; get; set; &#125; /// &lt;summary&gt; /// 数据列表索引 /// &lt;/summary&gt; public int item_index &#123; get; set; &#125; /// &lt;summary&gt; /// 单元格对象 /// &lt;/summary&gt; public Button item &#123; get &#123; return _item; &#125; set &#123; _item = value; _item_rect = _item.GetComponent&lt;RectTransform&gt;(); &#125; &#125; /// &lt;summary&gt; /// 单元格类型 /// &lt;/summary&gt; public int item_type &#123; get; set; &#125; /// &lt;summary&gt; /// 下一单元格 /// &lt;/summary&gt; public ItemTransformData next &#123; get; set; &#125; /// &lt;summary&gt; /// 上一单元格 /// &lt;/summary&gt; public ItemTransformData parent &#123; get; set; &#125; private Button _item; private RectTransform _item_rect; private Vector2 _pos; public void CloneTo(ItemTransformData itd) &#123; itd.pos = pos; itd.cell_index = cell_index; itd.item_index = item_index; itd.item = item; itd.item_type = item_type; &#125; public ItemTransformData Clone() &#123; ItemTransformData itd = new ItemTransformData(); CloneTo(itd); return itd; &#125;&#125; 初始化 生成单元格对象池 首先初始化列表的视口大小。 然后遍历 Item 预制体类型，根据视口大小循环创建 Item 对象并存入对象池（也可以在运行时创建，根据需求即可）。 根据面板配置设置对应的控制条件。 监听滚动。 根据数据生成单元格 回收所有显示的单元格。 初始化虚拟列表 while 循环生成单元格，非 FitSize 情况下当单元格超出视界后不生成，只获取并计算位置和大小信息。 列表滚动刷新前提条件：Y 轴向下为负值，向下滚动为滚动面板 Y 值增加，X 方向相反 滚动列表刷新按照滚动方向分为两类： 向下\\右滚动 对于头单元格，当其 Y 方向最低点加上滚动距离大于 0 时，或者其 X 方向最右点加上滚动距离小于 0 时，回收头单元格，然后置头单元格为下一单元格（next）。 Y：_head.pos.y - _head.height + rect &gt; 0 X：_head.pos.x + _head.width + rect &lt; 0 对于尾单元格，当其 Y 方向最高点加上滚动距离大于负的滚动面板高度时，或者其 X 方向最左点加上滚动距离小于滚动面板宽度时，生成新单元格，并置尾单元格为该单元格。 Y：_tail.pos.y + rect &gt; -_viewHeight X：_tail.pos.x + rect &lt; _viewWidth 向上\\左滚动 对于头单元格，当其 Y 方向最低点加上滚动距离小于 0 时，或者其 X 方向最右点加上滚动距离大于 0 时，生成新单元格，并置头单元格为该单元格。 Y：_head.pos.y - _head.height + rect &lt; 0 X：_head.pos.x + _head.width + rect &gt; 0 对于尾单元格，当其 Y 方向最高点加上滚动距离小于负的滚动面板高度时，或者其 X 方向最左点加上滚动距离大于滚动面板宽度时，回收尾单元格，然后置尾单元格为上一单元格（parent）。 Y：_tail.pos.y + rect &lt; -_viewHeight X：_tail.pos.x + rect &gt; _viewWidth 改变单元格大小调用SetCellSize方法设置单元格大小，并且默认刷新单元格位置。 代码ItemTransformData123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123using UnityEngine;using UnityEngine.UI;public class ItemTransformData&#123; /// &lt;summary&gt; /// 坐标 /// &lt;/summary&gt; public Vector2 pos &#123; get &#123; return _pos; &#125; set &#123; _pos = value; item.transform.localPosition = pos; &#125; &#125; /// &lt;summary&gt; /// 高度 /// &lt;/summary&gt; public float height &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.height; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽度 /// &lt;/summary&gt; public float width &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.width; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽高 /// &lt;/summary&gt; public Vector2 size &#123; set &#123; _item_rect.sizeDelta = value; &#125; &#125; /// &lt;summary&gt; /// 虚拟列表索引 /// &lt;/summary&gt; public int cell_index &#123; get; set; &#125; /// &lt;summary&gt; /// 数据列表索引 /// &lt;/summary&gt; public int item_index &#123; get; set; &#125; /// &lt;summary&gt; /// 单元格对象 /// &lt;/summary&gt; public Button item &#123; get &#123; return _item; &#125; set &#123; _item = value; _item_rect = _item.GetComponent&lt;RectTransform&gt;(); &#125; &#125; /// &lt;summary&gt; /// 单元格类型 /// &lt;/summary&gt; public int item_type &#123; get; set; &#125; /// &lt;summary&gt; /// 下一单元格 /// &lt;/summary&gt; public ItemTransformData next &#123; get; set; &#125; /// &lt;summary&gt; /// 上一单元格 /// &lt;/summary&gt; public ItemTransformData parent &#123; get; set; &#125; private Button _item; private RectTransform _item_rect; private Vector2 _pos; public void CloneTo(ItemTransformData itd) &#123; itd.pos = pos; itd.cell_index = cell_index; itd.item_index = item_index; itd.item = item; itd.item_type = item_type; &#125; public ItemTransformData Clone() &#123; ItemTransformData itd = new ItemTransformData(); CloneTo(itd); return itd; &#125;&#125; ScrollViewScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642using System;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class ScrollViewScript&lt;T&gt; : MonoBehaviour&#123; /// &lt;summary&gt; /// 单元格预制体 /// &lt;/summary&gt; public List&lt;Button&gt; PrefabItem; /// &lt;summary&gt; /// 单元格回收节点 /// &lt;/summary&gt; public GameObject Stack; /// &lt;summary&gt; /// 滚动节点 /// &lt;/summary&gt; public ScrollRect Scroll; /// &lt;summary&gt; /// 自适应大小 /// &lt;/summary&gt; public bool FitSize; /// &lt;summary&gt; /// X方向单元格间隔 /// &lt;/summary&gt; public float SpaceX; /// &lt;summary&gt; /// Y方向单元格间隔 /// &lt;/summary&gt; public float SpaceY; /// &lt;summary&gt; /// X方向偏移 /// &lt;/summary&gt; public float OffsetX; /// &lt;summary&gt; /// Y方向偏移 /// &lt;/summary&gt; public float OffsetY; /// &lt;summary&gt; /// X方向重复单元格个数 /// &lt;/summary&gt; public int RepeatX; /// &lt;summary&gt; /// Y方向重复单元格个数 /// &lt;/summary&gt; public int RepeatY; /// &lt;summary&gt; /// 默认列表数据 /// &lt;/summary&gt; public List&lt;T&gt; data &#123; get &#123; return _data; &#125; set &#123; RefreshList(value); &#125; &#125; /// &lt;summary&gt; /// 列表单元格类型 /// &lt;/summary&gt; protected List&lt;int[]&gt; itemType &#123; get &#123; return _itemType; &#125; set &#123; _itemType = value; &#125; &#125; protected List&lt;Action&lt;ItemTransformData, int&gt;&gt; actions &#123; get &#123; return _actions; &#125; &#125; private bool _inited = false; private List&lt;int[]&gt; _itemType = new List&lt;int[]&gt;(); /// &lt;summary&gt; /// 默认列表数据 /// &lt;/summary&gt; private List&lt;T&gt; _data; /// &lt;summary&gt; /// 单元格虚拟数量最大值 /// &lt;/summary&gt; private int _length; /// &lt;summary&gt; /// 显示的单元格列表 /// &lt;/summary&gt; private List&lt;ItemTransformData&gt; _items = new List&lt;ItemTransformData&gt;(); /// &lt;summary&gt; /// 回收的单元格列表 /// &lt;/summary&gt; private List&lt;Stack&lt;ItemTransformData&gt;&gt; _itemStack = new List&lt;Stack&lt;ItemTransformData&gt;&gt;(); /// &lt;summary&gt; /// content面板transform /// &lt;/summary&gt; private RectTransform _rectTransform; /// &lt;summary&gt; /// content视图高度 /// &lt;/summary&gt; private float _viewHeight; /// &lt;summary&gt; /// content视图宽度 /// &lt;/summary&gt; private float _viewWidth; //private int _repeatX; private ItemTransformData _head; private ItemTransformData _tail; private Vector2 _lastScrollPos = new Vector2(); private List&lt;Vector2&gt; _itemPos = new List&lt;Vector2&gt;(); private Dictionary&lt;int, Dictionary&lt;int, Vector2&gt;&gt; _itemSize = new Dictionary&lt;int, Dictionary&lt;int, Vector2&gt;&gt;(); private int _scrollDirection = 0; private List&lt;Action&lt;ItemTransformData, int&gt;&gt; _actions = new List&lt;Action&lt;ItemTransformData, int&gt;&gt;(); public void Start() &#123; _rectTransform = GetComponent&lt;RectTransform&gt;(); _viewWidth = transform.parent.GetComponent&lt;RectTransform&gt;().rect.width; _viewHeight = transform.parent.GetComponent&lt;RectTransform&gt;().rect.height; for (int i = 0, len = PrefabItem.Count; i &lt; len; i++) &#123; //创建回收栈节点对应类型的回收节点 GameObject obj = new GameObject(); obj.name = &quot;ItemType_&quot; + i; obj.transform.SetParent(Stack.transform); Button item = Instantiate(PrefabItem[i]); item.transform.SetParent(obj.transform); RectTransform itemRect = item.GetComponent&lt;RectTransform&gt;(); ItemTransformData itd = new ItemTransformData(); itd.item = item; itd.pos = new Vector2(); itd.item_type = i; if (_itemStack.Count &lt;= i) &#123; _itemStack.Add(new Stack&lt;ItemTransformData&gt;()); &#125; _itemStack[i].Push(itd); for (int j = 0, len2 = (int)Mathf.Ceil(_viewHeight / itd.height) * (int)Mathf.Ceil(_viewWidth / itd.width); j &lt; len2; j++) &#123; Button item2 = Instantiate(PrefabItem[i]); item2.transform.SetParent(obj.transform); RectTransform itemRect2 = item.GetComponent&lt;RectTransform&gt;(); ItemTransformData itd2 = new ItemTransformData(); itd2.item = item2; itd2.pos = new Vector2(); itd2.item_type = i; _itemStack[i].Push(itd2); &#125; &#125; if (FitSize) &#123; Scroll.vertical = false; Scroll.horizontal = false; &#125; else &#123; if (RepeatY != 0) &#123; Scroll.vertical = false; &#125; else &#123; Scroll.horizontal = false; &#125; &#125; Scroll.onValueChanged.AddListener(OnScroll); _inited = true; if (data != null &amp;&amp; data.Count &gt; 0) &#123; data = data; &#125; &#125; private void OnScroll(Vector2 v) &#123; ////Debug.Log(v); if (_head == null || _tail == null) return; float rect; float diff; if (RepeatY != 0) &#123; rect = _rectTransform.localPosition.x; diff = _lastScrollPos.x - rect; &#125; else &#123; rect = _rectTransform.localPosition.y; diff = rect - _lastScrollPos.y; &#125; if (diff &gt; 0) &#123; _scrollDirection = 1; &#125; else if (diff &lt; 0) &#123; _scrollDirection = -1; &#125; else &#123; _scrollDirection = 0; &#125; if (_scrollDirection == 1) &#123; bool checkRecycleHead; if (RepeatY != 0) &#123; checkRecycleHead = _head.pos.x + _head.width + rect &lt; 0; &#125; else &#123; checkRecycleHead = _head.pos.y - _head.height + rect &gt; 0; &#125; if (checkRecycleHead) &#123; if (_head.next != null) &#123; //Debug.Log(&quot;回收头&quot; + _head.cell_index + &quot; == &quot; + _head.next.cell_index); RecycleCell(_head.item_type, _head); _head = _head.next; &#125; &#125; bool checkRecycleTail; if (RepeatY != 0) &#123; checkRecycleTail = _tail.pos.x + rect &lt; _viewWidth; &#125; else &#123; checkRecycleTail = _tail.pos.y + rect &gt; -_viewHeight; &#125; //Debug.Log(_tail.pos.y + rectY + &quot; : &quot; + _viewHeight); if (checkRecycleTail) &#123; int index = _tail.cell_index + 1; if (index &lt; _itemType.Count) &#123; int[] itemType = _itemType[index]; ItemTransformData item = CreateItem(itemType[0]); Vector2 pos = _itemPos[index]; item.cell_index = index; item.item_index = itemType[1]; item.parent = _tail; _tail.next = item; item.pos = pos; item.item.transform.localPosition = pos; item.item.name = index + &quot;&quot;; _tail = item; //Debug.Log(&quot;创建尾&quot; + _tail.cell_index + &quot; &quot; + pos + &quot; &quot; + index); if (itemType[0] &lt; _actions.Count) &#123; _actions[itemType[0]](item, item.item_index); &#125; &#125; &#125; &#125; else if (_scrollDirection == -1) &#123; bool checkRecycleHead; if (RepeatY != 0) &#123; checkRecycleHead = _head.pos.x + _head.width + rect &gt; 0; &#125; else &#123; checkRecycleHead = _head.pos.y - _head.height + rect &lt; 0; &#125; //Debug.Log(_head.pos.y - _head.height + rectY); if (checkRecycleHead) &#123; int index = _head.cell_index - 1; if (index &gt;= 0) &#123; int[] itemType = _itemType[index]; ItemTransformData item = CreateItem(itemType[0]); Vector2 pos = _itemPos[index]; item.cell_index = index; item.item_index = itemType[1]; item.next = _head; _head.parent = item; item.pos = pos; item.item.transform.localPosition = pos; item.item.name = index + &quot;&quot;; _head = item; //Debug.Log(&quot;创建头&quot; + _head.cell_index + &quot; &quot; + pos + &quot; &quot; + index); if (itemType[0] &lt; _actions.Count) &#123; _actions[itemType[0]](item, item.item_index); &#125; &#125; &#125; bool checkRecycleTail; if (RepeatY != 0) &#123; checkRecycleTail = _tail.pos.x + rect &gt; _viewWidth; &#125; else &#123; checkRecycleTail = _tail.pos.y + rect &lt; -_viewHeight; &#125; //Debug.Log(_tail.pos.y + rectY + &quot; : &quot; + -_viewHeight); if (checkRecycleTail) &#123; if (_tail.parent != null) &#123; //Debug.Log(&quot;回收尾&quot; + _tail.cell_index); RecycleCell(_tail.item_type, _tail); _tail = _tail.parent; &#125; &#125; &#125; _lastScrollPos.x = _rectTransform.localPosition.x; _lastScrollPos.y = _rectTransform.localPosition.y; &#125; /// &lt;summary&gt; /// 创建ItemTransformData /// &lt;/summary&gt; /// &lt;param name=&quot;itemType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private ItemTransformData CreateItem(int itemType, bool init = true) &#123; ItemTransformData item; //Debug.Log(itemType + &quot; &quot; + _itemStack.Count); if (_itemStack[itemType].Count &gt; 0) &#123; item = _itemStack[itemType].Pop(); &#125; else &#123; Button button = Instantiate(PrefabItem[itemType]); item = new ItemTransformData(); item.item = button; &#125; if (init) &#123; item.item.transform.SetParent(transform); _items.Add(item); &#125; else &#123; _itemStack[itemType].Push(item); &#125; return item; &#125; /// &lt;summary&gt; /// 回收所有单元格 /// &lt;/summary&gt; private void RecycleAllCells() &#123; for (int i = 0, len = _items.Count; i &lt; len; i++) &#123; ItemTransformData item = _items[i]; item.item.transform.SetParent(Stack.transform.GetChild(item.item_type)); _itemStack[item.item_type].Push(item); &#125; _items.Clear(); _itemPos.Clear(); &#125; /// &lt;summary&gt; /// 回收一个单元格 /// &lt;/summary&gt; /// &lt;param name=&quot;itemType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;itd&quot;&gt;&lt;/param&gt; private void RecycleCell(int itemType, ItemTransformData itd) &#123; itd.item.transform.SetParent(Stack.transform.GetChild(itemType)); //itd.next = null; //itd.parent = null; _items.Remove(itd); _itemStack[itemType].Push(itd); &#125; private Vector2 CalculatePosition(ItemTransformData last, ItemTransformData current) &#123; float bonusX = 0; float bonusY = 0; if (RepeatX != 0) &#123; if (current.cell_index == 0) &#123; bonusX = OffsetX; bonusY = OffsetY; &#125; else if (current.cell_index % RepeatX == 0) &#123; //换行 bonusX = -last.pos.x + OffsetX; bonusY = last.height + SpaceY; &#125; else &#123; bonusX = last.width + SpaceX; &#125; &#125; else if (RepeatY != 0) &#123; if (current.cell_index == 0) &#123; bonusY = OffsetY; bonusX = OffsetX; &#125; else if (current.cell_index % RepeatY == 0) &#123; //换行 bonusX = last.width + SpaceX; bonusY = last.pos.y + OffsetY; &#125; else &#123; bonusY = last.height + SpaceY; &#125; Debug.Log(bonusY); &#125; else &#123; if (current.cell_index == 0) &#123; bonusX = OffsetX; bonusY = OffsetY; &#125; else if (last.pos.x + last.width + SpaceX + current.width &gt; _viewWidth) &#123; //换行 bonusX = -last.pos.x + OffsetX; bonusY = last.height + SpaceY; &#125; else &#123; bonusX = last.width + SpaceX; &#125; &#125; //_tempVec2.x = last.pos.x + bonusX; //_tempVec2.y = last.pos.y - bonusY; Vector2 pos = new Vector2(last.pos.x + bonusX, last.pos.y - bonusY); return pos; &#125; protected void RefreshList(List&lt;T&gt; data) &#123; //Debug.Log(&quot;设置数据&quot;); _data = data; if (_inited) &#123; RecycleAllCells(); InitItemType(); ResetCells(); &#125; &#125; private void ResetCells() &#123; if (FitSize) &#123; _viewWidth = transform.parent.GetComponent&lt;RectTransform&gt;().rect.width; _viewHeight = transform.parent.GetComponent&lt;RectTransform&gt;().rect.height; &#125; ItemTransformData last = new ItemTransformData(); int i = 0; float maxY = 0; float maxX = 0; float maxHeight = 0; float maxWidth = 0; while (i &lt; itemType.Count) &#123; int type = itemType[i][0]; bool isInit = true; if (!FitSize) &#123; if (RepeatY != 0) &#123; isInit = maxX &lt; _viewHeight; &#125; else &#123; isInit = maxY &gt; -_viewHeight; &#125; &#125; ItemTransformData itd = CreateItem(type, isInit); itd.cell_index = i; itd.item_index = itemType[i][1]; itd.item.name = i + &quot;&quot;; if (isInit) &#123; if (type &lt; _actions.Count) &#123; _actions[type](itd, itd.item_index); &#125; &#125; Vector2 pos = CalculatePosition(last, itd); _itemPos.Add(pos); //第一次设置数据的时候初始化单元格大小 之后设置单元格大小 Dictionary&lt;int, Vector2&gt; sizeDic; _itemSize.TryGetValue(type, out sizeDic); if (sizeDic == null) &#123; sizeDic = new Dictionary&lt;int, Vector2&gt;(); _itemSize.Add(type, sizeDic); &#125; if (!sizeDic.ContainsKey(itd.item_index)) &#123; sizeDic.Add(itd.item_index, new Vector2(itd.width, itd.height)); &#125; else &#123; itd.size = sizeDic[itd.item_index]; &#125; itd.pos = pos; last.next = itd; if (i != 0) &#123; itd.parent = last; &#125; last = itd; maxY = pos.y; maxX = pos.x; float maxH = pos.y - itd.height; float maxW = pos.x + itd.width; if (maxH &lt; maxHeight) &#123; maxHeight = maxH; &#125; if (maxW &gt; maxWidth) &#123; maxWidth = maxW; &#125; i++; //Debug.Log(&quot;设置item &quot; + (i - 1) + &quot; &quot; + maxHeight + &quot; &quot; + pos.y + &quot; &quot; + itd.height); &#125; if (_items.Count &gt; 0) &#123; _head = _items[0]; _tail = _items[_items.Count - 1]; &#125; else &#123; _head = null; _tail = null; &#125; //更新UI大小 _rectTransform.sizeDelta = new Vector2(maxWidth, -maxHeight); if (FitSize) &#123; float contentHeight = _rectTransform.rect.height; _viewHeight = contentHeight; float contentWidth = _rectTransform.rect.width; _viewWidth = contentWidth; //if (contentHeight &lt; _viewHeight) //&#123; // _viewHeight = contentHeight; //&#125; RectTransform scrollRect = Scroll.GetComponent&lt;RectTransform&gt;(); scrollRect.sizeDelta = new Vector2(maxWidth, -maxHeight); &#125; &#125; private void Resize() &#123; RecycleAllCells(); ResetCells(); &#125; /// &lt;summary&gt; /// 初始化单元格类型 /// &lt;/summary&gt; /// &lt;param name=&quot;itemType&quot;&gt;int[2] 0为button类型 1为对应类型的数据索引&lt;/param&gt; protected virtual void InitItemType() &#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); for (int i = 0, len = _data.Count; i &lt; len; i++) &#123; type.Add(new int[] &#123; 0, i &#125;); &#125; itemType = type; &#125; /// &lt;summary&gt; /// 设置单元格大小 /// &lt;/summary&gt; /// &lt;param name=&quot;itd&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; protected void SetCellSize(ItemTransformData itd, Vector2 size, bool resize = true) &#123; _itemSize[itd.item_type][itd.item_index] = size; if (resize) &#123; Resize(); &#125; &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"UI","slug":"UI","permalink":"https://busyogg.github.io/tags/UI/"}]},{"title":"对话系统","slug":"对话系统","date":"2023-11-02T11:27:14.000Z","updated":"2024-05-18T15:40:15.086Z","comments":true,"path":"article/71fc63e69064/","link":"","permalink":"https://busyogg.github.io/article/71fc63e69064/","excerpt":"","text":"简介通过对话树构造对话系统，支持选项分支、自动对话和对话历史。 演示 原理通过树结构保存对话节点，没有选项的时候进入索引为 0 的下一节点，有选项的时候根据选项的索引进入对应的下一节点。 DialogueTree1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Collections.Generic;public class DialogueTree&#123; /// &lt;summary&gt; /// id，用来判断对话顺序 /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话id，用来判断所属对话树 /// &lt;/summary&gt; public int d_id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话人 /// &lt;/summary&gt; public string target &#123; get; set; &#125; /// &lt;summary&gt; /// 内容 /// &lt;/summary&gt; public string content &#123; get; set; &#125; /// &lt;summary&gt; /// 选项 /// &lt;/summary&gt; public List&lt;string&gt; selection &#123; get; set; &#125; /// &lt;summary&gt; /// 下一对话 /// &lt;/summary&gt; public List&lt;DialogueTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 特效 暂无用处 /// &lt;/summary&gt; public string effect &#123; get; set; &#125; /// &lt;summary&gt; /// 自动播放速度 /// &lt;/summary&gt; public float autoSpeed &#123; get; set; &#125; public DialogueTree() &#123; next = new List&lt;DialogueTree&gt;(); selection = new List&lt;string&gt;(); &#125;&#125; 自动对话利用协程进行，在遇到选项的时候停止，在选项选择后重新开启自动对话协程；在手动点击下一个对话的情况下停止协程并重新开启一个自动对话的协程。 对话历史则是把每一条对话和选择的选项记录到一个对话列表中，展示的时候只要遍历即可。 UI 逻辑UI 展示UI 展示封装为ShowDialogue，每次调用更新对话人，对话内容，如果有选项则根据选项数量显示选项按钮。同时，在该方法内调用DialogueManager.Instance().RecordDialogue(_content.text);记录对话内容用于回放。 123456789101112131415161718192021/// &lt;summary&gt;/// UI展示/// &lt;/summary&gt;private void ShowDialogue()&#123; _content.text = DialogueManager.Instance().GetContent(); DialogueManager.Instance().RecordDialogue(_content.text); _target.text = DialogueManager.Instance().GetTarget(); List&lt;string&gt; selections = DialogueManager.Instance().GetSelection(); if (selections.Count &gt; 0) &#123; for (int i = 0, len = selections.Count; i &lt; len; i++) &#123; string selection = selections[i]; Button button = _buttons[i]; button.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = selection; button.gameObject.SetActive(true); &#125; &#125;&#125; 开始对话调用DialogueManager.Instance().StartDialogue();方法开始对话，该方法接受一个对话 id 参数。 开始对话之后，立刻调用ShowDialogue展示对话内容，并且判断是否自动对话，是的情况调用自动对话协程 12345678910111213141516/// &lt;summary&gt;/// 开始对话点击事件/// &lt;/summary&gt;private void OnStartClick()&#123; _start.gameObject.SetActive(false); _dialoguePanel.SetActive(true); DialogueManager.Instance().StartDialogue(0); ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125;&#125; 自动对话利用协程根据每一段对话的速度来决定自动进入下一对话的时间。 点击按钮开启自动对话，再次点击关闭。 自动对话协程等待时间到了之后，先判断是否有下一对话。 是的情况判断下一对话是否有选项，没有选项的情况下进入下一对话，有的话就停止协程。 否的情况，结束对话。 123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// 自动对话点击事件/// &lt;/summary&gt;private void OnAutoClick()&#123; _isAuto = !_isAuto; if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto On&quot;; &#125; else &#123; StopCoroutine(_dialogCo); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto&quot;; &#125;&#125;/// &lt;summary&gt;/// 自动对话协程/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;IEnumerator AutoDialogue()&#123; float speed = DialogueManager.Instance().GetAutoSpeed(); yield return new WaitForSeconds(speed); bool next = DialogueManager.Instance().Next(); if (next) &#123; bool nextSelection = DialogueManager.Instance().GetSelection().Count == 0; if (nextSelection) &#123; StartCoroutine(AutoDialogue()); &#125; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125;&#125; 下一对话首先判断选项按钮是否显示，显示的情况下禁止进入下一对话。否则调用DialogueManager.Instance().Next()进入下一对话，并且调用ShowDialogue()更新 UI。如果没有下一对话就结束对话。 在开启自动对话的情况下，先停止上一个自动对话的协程防止冲突，然后另起一个自动对话协程。 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 下一对话点击事件/// &lt;/summary&gt;private void OnNextClick()&#123; if (!_buttons[0].gameObject.activeInHierarchy) &#123; bool next = DialogueManager.Instance().Next(); if (next) &#123; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125; if (_isAuto) &#123; StopCoroutine(_dialogCo); _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125;&#125; 选项点击选项的时候调用DialogueManager.Instance().SetSelect(index)设置当前选项，调用DialogueManager.Instance().RecordDialogue(DialogueManager.Instance().GetSelection()[index])保存已选选项的内容到对话历史中。然后就是和点击下一对话的逻辑一样。另外在完成选择后隐藏所有选项。 1234567891011121314151617181920/// &lt;summary&gt;/// 选项点击事件/// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;private void OnSelectClick(int index)&#123; DialogueManager.Instance().SetSelect(index); DialogueManager.Instance().RecordDialogue(DialogueManager.Instance().GetSelection()[index]); DialogueManager.Instance().Next(); for (int i = 0; i &lt; _buttons.Count; i++) &#123; Button button = _buttons[i]; button.gameObject.SetActive(false); &#125; ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125;&#125; 对话历史对话历史只要调用DialogueManager.Instance().GetRecordedDialogue()获得历史对话列表，然后根据需要输出即可。 1234567891011/// &lt;summary&gt;/// 对话回放点击事件/// &lt;/summary&gt;private void OnRecordClick() &#123; List&lt;string&gt; record = DialogueManager.Instance().GetRecordedDialogue(); for(int i = 0,len = record.Count; i &lt; len; i++) &#123; string rec = record[i]; Debug.Log(rec); &#125;&#125; 对话管理器对话管理器负责简单的数据存储和获取功能。最复杂的部分就在于选择下一对话。 下一对话先判断是否有选项 有选项的情况，下一对话直接根据当前选择的索引去_curDialogue.next中取对应索引的节点。 没有选项的情况，如果_curDialogue.next的计数大于 0，即有下一对话，则置当前对话节点_curDialogue为_curDialogue.next[0]（保存的下一对话只有一个，索引为 0）。否则置下一对话为null。 下一对话选择完成后，返回成功或失败的结果，用于 UI 展示。 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 下一对话/// &lt;/summary&gt;public bool Next()&#123; if (_curDialogue.selection.Count == 0) &#123; if (_curDialogue.next.Count &gt; 0) &#123; _curDialogue = _curDialogue.next[0]; return true; &#125; else &#123; _curDialogue = null; return false; &#125; &#125; else &#123; _curDialogue = _curDialogue.next[_select]; return true; &#125;&#125; 代码对话树1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Collections.Generic;public class DialogueTree&#123; /// &lt;summary&gt; /// id，用来判断对话顺序 /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话id，用来判断所属对话树 /// &lt;/summary&gt; public int d_id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话人 /// &lt;/summary&gt; public string target &#123; get; set; &#125; /// &lt;summary&gt; /// 内容 /// &lt;/summary&gt; public string content &#123; get; set; &#125; /// &lt;summary&gt; /// 选项 /// &lt;/summary&gt; public List&lt;string&gt; selection &#123; get; set; &#125; /// &lt;summary&gt; /// 下一对话 /// &lt;/summary&gt; public List&lt;DialogueTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 特效 暂无用处 /// &lt;/summary&gt; public string effect &#123; get; set; &#125; /// &lt;summary&gt; /// 自动播放速度 /// &lt;/summary&gt; public float autoSpeed &#123; get; set; &#125; public DialogueTree() &#123; next = new List&lt;DialogueTree&gt;(); selection = new List&lt;string&gt;(); &#125;&#125; UI脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190using System.Collections;using System.Collections.Generic;using TMPro;using UnityEngine;using UnityEngine.UI;public class RootScript : MonoBehaviour&#123; //UI控件 -----start public TextMeshProUGUI _content; public List&lt;Button&gt; _buttons; public Button _auto; public Button _start; public Button _panel; public Button _record; public TextMeshProUGUI _target; public GameObject _dialoguePanel; //UI控件 -----end /// &lt;summary&gt; /// 是否自动对话 /// &lt;/summary&gt; private bool _isAuto = false; /// &lt;summary&gt; /// 自动对话协程 /// &lt;/summary&gt; private Coroutine _dialogCo; void Start() &#123; DialogueManager.Instance().Init(); _auto.onClick.AddListener(OnAutoClick); _start.onClick.AddListener(OnStartClick); _panel.onClick.AddListener(OnNextClick); _record.onClick.AddListener(OnRecordClick); for (int i = 0, len = _buttons.Count; i &lt; len; i++) &#123; Button button = _buttons[i]; int index = i; button.onClick.AddListener(() =&gt; &#123; OnSelectClick(index); &#125;); &#125; &#125; /// &lt;summary&gt; /// UI展示 /// &lt;/summary&gt; private void ShowDialogue() &#123; _content.text = DialogueManager.Instance().GetContent(); DialogueManager.Instance().RecordDialogue(_content.text); _target.text = DialogueManager.Instance().GetTarget(); List&lt;string&gt; selections = DialogueManager.Instance().GetSelection(); if (selections.Count &gt; 0) &#123; for (int i = 0, len = selections.Count; i &lt; len; i++) &#123; string selection = selections[i]; Button button = _buttons[i]; button.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = selection; button.gameObject.SetActive(true); &#125; &#125; &#125; /// &lt;summary&gt; /// 开始对话点击事件 /// &lt;/summary&gt; private void OnStartClick() &#123; _start.gameObject.SetActive(false); _dialoguePanel.SetActive(true); DialogueManager.Instance().StartDialogue(0); ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125; /// &lt;summary&gt; /// 自动对话点击事件 /// &lt;/summary&gt; private void OnAutoClick() &#123; _isAuto = !_isAuto; if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto On&quot;; &#125; else &#123; StopCoroutine(_dialogCo); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto&quot;; &#125; &#125; /// &lt;summary&gt; /// 下一对话点击事件 /// &lt;/summary&gt; private void OnNextClick() &#123; if (!_buttons[0].gameObject.activeInHierarchy) &#123; bool next = DialogueManager.Instance().Next(); if (next) &#123; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125; if (_isAuto) &#123; StopCoroutine(_dialogCo); _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125; &#125; /// &lt;summary&gt; /// 选项点击事件 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; private void OnSelectClick(int index) &#123; DialogueManager.Instance().SetSelect(index); DialogueManager.Instance().RecordDialogue(DialogueManager.Instance().GetSelection()[index]); DialogueManager.Instance().Next(); for (int i = 0; i &lt; _buttons.Count; i++) &#123; Button button = _buttons[i]; button.gameObject.SetActive(false); &#125; ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125; /// &lt;summary&gt; /// 对话回放点击事件 /// &lt;/summary&gt; private void OnRecordClick() &#123; List&lt;string&gt; record = DialogueManager.Instance().GetRecordedDialogue(); for(int i = 0,len = record.Count; i &lt; len; i++) &#123; string rec = record[i]; Debug.Log(rec); &#125; &#125; /// &lt;summary&gt; /// 自动对话协程 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator AutoDialogue() &#123; float speed = DialogueManager.Instance().GetAutoSpeed(); yield return new WaitForSeconds(speed); bool next = DialogueManager.Instance().Next(); if (next) &#123; bool nextSelection = DialogueManager.Instance().GetSelection().Count == 0; if (nextSelection) &#123; StartCoroutine(AutoDialogue()); &#125; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125; &#125;&#125; 对话管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168using System.Collections.Generic;public class DialogueManager&#123; private static DialogueManager _instance = null; private List&lt;DialogueTree&gt; _dialogues = new List&lt;DialogueTree&gt;(); private DialogueTree _curDialogue = null; private int _select; private List&lt;string&gt; _record = new List&lt;string&gt;(); public static DialogueManager Instance() &#123; if (_instance == null) &#123; _instance = new DialogueManager(); &#125; return _instance; &#125; private DialogueManager() &#123; &#125; public void Init() &#123; DialogueTree d1 = new DialogueTree(); d1.id = 0; d1.d_id = 0; d1.content = &quot;第一条对话&quot;; d1.target = &quot;NPC&quot;; d1.autoSpeed = 2; DialogueTree d2 = new DialogueTree(); d2.id = 1; d2.d_id = 0; d2.content = &quot;第二条对话&quot;; d2.target = &quot;NPC&quot;; d2.autoSpeed = 2; d2.selection.Add(&quot;选项1&quot;); d2.selection.Add(&quot;选项2&quot;); DialogueTree d3 = new DialogueTree(); d3.id = 2; d3.d_id = 0; d3.content = &quot;第三条对话&quot;; d3.target = &quot;NPC&quot;; d3.autoSpeed = 2; DialogueTree d4 = new DialogueTree(); d4.id = 3; d4.d_id = 0; d4.content = &quot;第四条对话&quot;; d4.target = &quot;Player&quot;; d4.autoSpeed = 2; d1.next.Add(d2); d2.next.Add(d3); d2.next.Add(d4); _dialogues.Add(d1); &#125; /// &lt;summary&gt; /// 开始对话 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt; public void StartDialogue(int id) &#123; _curDialogue = _dialogues[id]; &#125; /// &lt;summary&gt; /// 获取对话内容 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetContent() &#123; return _curDialogue?.content; &#125; /// &lt;summary&gt; /// 获取对话人 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetTarget() &#123; return _curDialogue?.target; &#125; /// &lt;summary&gt; /// 获得选项 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;string&gt; GetSelection() &#123; return _curDialogue?.selection; &#125; /// &lt;summary&gt; /// 获得自动对话速度 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public float GetAutoSpeed() &#123; return _curDialogue.autoSpeed; &#125; /// &lt;summary&gt; /// 设置选项 /// &lt;/summary&gt; /// &lt;param name=&quot;select&quot;&gt;&lt;/param&gt; public void SetSelect(int select) &#123; _select = select; &#125; /// &lt;summary&gt; /// 下一对话 /// &lt;/summary&gt; public bool Next() &#123; if (_curDialogue.selection.Count == 0) &#123; if (_curDialogue.next.Count &gt; 0) &#123; _curDialogue = _curDialogue.next[0]; return true; &#125; else &#123; _curDialogue = null; return false; &#125; &#125; else &#123; _curDialogue = _curDialogue.next[_select]; return true; &#125; &#125; /// &lt;summary&gt; /// 记录对话 /// &lt;/summary&gt; /// &lt;param name=&quot;content&quot;&gt;&lt;/param&gt; public void RecordDialogue(string content) &#123; _record.Add(content); &#125; /// &lt;summary&gt; /// 获得对话记录 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;string&gt; GetRecordedDialogue() &#123; return _record; &#125; /// &lt;summary&gt; /// 清除对话记录 /// &lt;/summary&gt; public void ClearRecordedDialogue() &#123; _record.Clear(); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"连招系统","slug":"连招系统","date":"2023-10-31T17:11:49.000Z","updated":"2024-05-18T15:39:50.874Z","comments":true,"path":"article/69e4e16ef4ee/","link":"","permalink":"https://busyogg.github.io/article/69e4e16ef4ee/","excerpt":"","text":"简介使用有限状态机构造的连招系统，支持技能连招、分支技能、打断、变招、长按技能、蓄力技能。 演示 原理在 Update 中持续判断状态切换，并根据当前状态执行对应的操作。 状态机分为五个状态，Idle、Running、Holding、Charging 以及 Waiting。其中 Running 为非长按技能释放状态；Holding 为长按技能；Charging 为蓄力技能。 技能树本系统维护一个技能列表，技能列表中保存自定义的技能树。 SkillTree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections.Generic;using UnityEngine;public class SkillTree&#123; /// &lt;summary&gt; /// 技能名称 /// &lt;/summary&gt; public string name &#123; get; set; &#125; /// &lt;summary&gt; /// 技能id 一系列技能使用同一id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 键位需求 /// &lt;/summary&gt; public KeyCode key &#123; get; set; &#125; /// &lt;summary&gt; /// 下一连招列表 /// &lt;/summary&gt; public List&lt;SkillTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 技能持续时间 /// &lt;/summary&gt; public float skillTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否正在释放技能 /// &lt;/summary&gt; public bool isRunSkill &#123; get; set; &#125; /// &lt;summary&gt; /// 连招超时时间 /// &lt;/summary&gt; public float outOfTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否可以强制打断技能 /// &lt;/summary&gt; public bool isCanForceStop &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断次数 /// &lt;/summary&gt; public int forceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 默认强制打断次数 /// &lt;/summary&gt; public int defaultForceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断重置时间 /// &lt;/summary&gt; public float forceResetTime &#123; get; set; &#125; /// &lt;summary&gt; /// 技能类型 /// &lt;/summary&gt; public SkillType skillType &#123; get; set; &#125; /// &lt;summary&gt; /// 长按/蓄力时间 /// &lt;/summary&gt; public float holdingTime &#123; get; set; &#125; /// &lt;summary&gt; /// 进度条颜色 /// &lt;/summary&gt; public Color progressColor &#123; get; set; &#125; public SkillTree() &#123; skillType = SkillType.Click; progressColor = Color.white; next = new List&lt;SkillTree&gt;(); &#125;&#125; 本系统还维护当前使用的技能、输入间隔时间、技能持续时间、蓄力&#x2F;长按时间。这些数据是连招判定的相关数据。 连招判定方法我们在技能树中保存了需要按下的按键，只要判断输入事件是否和所需要的键位相同即可。 连招判定分为两个部分，一个是从根技能（即起手式）的情况，一个是判定连招的情况。 根技能的情况下有两种判断，一个是技能打断的判断，一个是开始放技能的判断。我们只要检测最近有无放过技能就能分辨是什么情况的判断。 连招的情况下也有两种情况，一种是连招成功，那么我们就保存当前的技能为连招的技能；另一种是连招失败，即下一个键位不是连招的键位，那么我们就返回一个错误连招的状态。 判定连招键位的时候我们遍历键位列表，即可做出分支攻击。 技能打断限制次数，每次打断都会减少次数，并且开启一个协程等待恢复技能打断次数。本系统的逻辑为第一次打断开始计时，时间到了就恢复次数，不论重置前使用多少次，也不会向后推延倒计时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/// &lt;summary&gt;/// 检测连招是否成功/// &lt;/summary&gt;/// &lt;param name=&quot;isRoot&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private ComboState CheckSkillKey(bool isRoot)&#123; if (Input.anyKeyDown) &#123; if (isRoot) &#123; if (_curSkill != null) &#123; //存在最近技能，并且从技能起手式开始检测 该情况为打断检测 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (skill.isCanForceStop &amp;&amp; skill.forceTimes &gt; 0 &amp;&amp; Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;打断并强制开始连招&quot; + skill.key); StopCoroutine(_skillCo); if (skill.name != _curSkill.name) &#123; _curSkill.isRunSkill = false; //_curSkill.forceTimes = _curSkill.defaultForceTimes; &#125; _curSkill = skill; --_curSkill.forceTimes; bool reset; _forceReset.TryGetValue(_curSkill.id, out reset); if (!reset) &#123; StartCoroutine(WaitForForceTimesReset(_curSkill)); &#125; return ComboState.Success; &#125; &#125; &#125; else &#123; //查找连招起手式 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;开始连招&quot; + skill.key); _curSkill = skill; return ComboState.Success; &#125; &#125; &#125; &#125; else &#123; //检测连招分支 for (int i = 0, len = _curSkill.next.Count; i &lt; len; i++) &#123; SkillTree skill = _curSkill.next[i]; if (Input.GetKeyDown(skill.key)) &#123; //连招成功 _curSkill = _curSkill.next[i]; return ComboState.Success; &#125; &#125; //连错招 重置 Debug.Log(&quot;连招重置&quot;); return ComboState.Wrong; &#125; &#125; return ComboState.Fail;&#125; 状态切换Idle待机状态，这个状态为初始状态，负责接收技能的起手式按键。如果玩家按下的按键是某一技能的起手式，那么当前状态就置为 Running、Holding 和 Charging 中的一种（根据技能树设置）。 Running技能执行状态，这个状态负责执行技能等待协程和技能打断判定。 该状态会开启一次技能等待协程，重置技能时间。该状态下会持续增加技能等待时间。技能等待协程执行完毕会自动切换为 Waiting 状态并且重置技能的执行状态。 如果技能打断成功，则我们就重置输入间隔时间。由于这个时候技能变为了新的，因此会重新执行一次上述行为。 Holding长按技能状态，按住按键技能就一直释放，按键放下就结束并转为 Waiting 状态。 该状态持续增加长按时间，一旦键位不再持续输入或者超过最大持续时间，就会置状态为 Waiting。考虑到按键一松开就会结束长按状态，因此这个状态没有判断技能打断。 Charging蓄力状态，按住按键技能开始蓄力，按键放下就结束并转为 Idle 状态。 该状态持续增加蓄力时间，一旦键位停止输入，则打断蓄力。由于蓄力未完成，连招中断，因此进入 Idle 状态。考虑到按键一松开就会结束蓄力状态，所以这个状态没有判断技能打断。 当蓄力时间超过技能所需时间，则转换为 Running 状态，执行 Running 状态的技能释放，这时候和普通点按技能释放的效果一样。 总的来说，蓄力技能就是在技能释放状态之前，增加了一个蓄力过程，其他和点按技能一致。 Waiting等待状态，负责技能连招之间的等待输入。该状态下每帧都会增加输入间隔时间，如果输入间隔时间小于技能最大的连招等待时间，并且玩家有输入操作的情况下，就开始判定连招。 连招正确的情况下，重置输入间隔时间，改变连招状态为 Running；连招错误的情况下，判断是否有对应按键的起手式，有就立刻转为新的连招并改变状态为 Running，否则就置为 Idle。 超时的情况下，重置输入间隔时间，并置 Idle。 状态执行根据各个状态执行对应的功能即可。该部分只负责实现，不参与控制。 代码技能树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System.Collections.Generic;using UnityEngine;public class SkillTree&#123; /// &lt;summary&gt; /// 技能名称 /// &lt;/summary&gt; public string name &#123; get; set; &#125; /// &lt;summary&gt; /// 技能id 一系列技能使用同一id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 键位需求 /// &lt;/summary&gt; public KeyCode key &#123; get; set; &#125; /// &lt;summary&gt; /// 下一连招列表 /// &lt;/summary&gt; public List&lt;SkillTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 技能持续时间 /// &lt;/summary&gt; public float skillTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否正在释放技能 /// &lt;/summary&gt; public bool isRunSkill &#123; get; set; &#125; /// &lt;summary&gt; /// 连招超时时间 /// &lt;/summary&gt; public float outOfTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否可以强制打断技能 /// &lt;/summary&gt; public bool isCanForceStop &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断次数 /// &lt;/summary&gt; public int forceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 默认强制打断次数 /// &lt;/summary&gt; public int defaultForceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断重置时间 /// &lt;/summary&gt; public float forceResetTime &#123; get; set; &#125; /// &lt;summary&gt; /// 技能类型 /// &lt;/summary&gt; public SkillType skillType &#123; get; set; &#125; /// &lt;summary&gt; /// 长按/蓄力时间 /// &lt;/summary&gt; public float holdingTime &#123; get; set; &#125; /// &lt;summary&gt; /// 进度条颜色 /// &lt;/summary&gt; public Color progressColor &#123; get; set; &#125; public SkillTree() &#123; skillType = SkillType.Click; progressColor = Color.white; next = new List&lt;SkillTree&gt;(); &#125;&#125; 连招控制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469using System;using System.Collections;using System.Collections.Generic;using UnityEditor.Experimental.GraphView;using UnityEngine;using UnityEngine.UI;public class ComboScript : MonoBehaviour&#123; /// &lt;summary&gt; /// 连招状态 /// &lt;/summary&gt; private State _state; /// &lt;summary&gt; /// 技能列表 /// &lt;/summary&gt; private List&lt;SkillTree&gt; _skills = new List&lt;SkillTree&gt;(); /// &lt;summary&gt; /// 当前技能 /// &lt;/summary&gt; private SkillTree _curSkill; /// &lt;summary&gt; /// 输入间隔 /// &lt;/summary&gt; private float _inputDelta = 0; /// &lt;summary&gt; /// 输入间隔进度条控件 /// &lt;/summary&gt; private RectTransform _skillProgress = null; /// &lt;summary&gt; /// 输入间隔进度条图像 /// &lt;/summary&gt; private Image _skillImage; /// &lt;summary&gt; /// 技能进度条控件 /// &lt;/summary&gt; private RectTransform _runProgress = null; /// &lt;summary&gt; /// 技能进度条图像 /// &lt;/summary&gt; private Image _runImage; /// &lt;summary&gt; /// 技能执行时间 /// &lt;/summary&gt; private float _skillTime = 0; /// &lt;summary&gt; /// 长按时间 /// &lt;/summary&gt; private float _holdingTime = 0; private Dictionary&lt;int, bool&gt; _forceReset = new Dictionary&lt;int, bool&gt;(); private Coroutine _skillCo; private Action _onIdle; private Action _onRunning; private Action _onHolding; private Action _onCharging; private Action _onWaiting; void Start() &#123; //获取UI _skillProgress = GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent&lt;RectTransform&gt;(); _skillProgress.sizeDelta = new Vector2(0, 30); _skillImage = GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent&lt;Image&gt;(); _runProgress = GameObject.FindGameObjectWithTag(&quot;Finish&quot;).GetComponent&lt;RectTransform&gt;(); _runProgress.sizeDelta = new Vector2(0, 30); _runImage = GameObject.FindGameObjectWithTag(&quot;Finish&quot;).GetComponent&lt;Image&gt;(); DoChangeState(State.Idle); &#125; // Update is called once per frame void Update() &#123; ChangeState(); &#125; private void OnGUI() &#123; if (_curSkill != null) &#123; if (_inputDelta == 0) &#123; if (_skillProgress.sizeDelta.x != 0) &#123; _skillProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; else &#123; float ratio = (_curSkill.outOfTime - _inputDelta) / _curSkill.outOfTime; if (ratio &lt; 0) &#123; ratio = 0; &#125; _skillProgress.sizeDelta = new Vector2(ratio * 100, 30); _skillImage.color = _curSkill.progressColor; &#125; if (_skillTime == 0) &#123; if (_runProgress.sizeDelta.x != 0) &#123; _runProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; else &#123; float total = _curSkill.skillTime; if (_curSkill.skillType == SkillType.Charge &amp;&amp; _state == State.Charging) &#123; total = _curSkill.holdingTime; &#125; if (total - _skillTime &gt;= 0) &#123; float skillRatio = (total - _skillTime) / total; _runProgress.sizeDelta = new Vector2(skillRatio * 100, 30); _runImage.color = _curSkill.progressColor; &#125; else &#123; _runProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; &#125; else &#123; if (_skillProgress.sizeDelta.x != 0) &#123; _skillProgress.sizeDelta = new Vector2(0, 30); &#125; if (_runProgress.sizeDelta.x != 0) &#123; _runProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; &#125; /// &lt;summary&gt; /// 改变状态 /// &lt;/summary&gt; private void ChangeState() &#123; switch (_state) &#123; case State.Idle: _curSkill = null; //起始技能检测 if (CheckSkillKey(true) == ComboState.Success) &#123; DoChangeState(CheckSkillType(_curSkill.skillType)); &#125; break; case State.Running: //等待技能执行 if (!_curSkill.isRunSkill) &#123; Debug.Log(&quot;执行技能 === &quot; + _curSkill.name + &quot;:&quot; + _curSkill.skillTime); _curSkill.isRunSkill = true; _skillCo = StartCoroutine(WaitForSkill()); &#125; _skillTime += Time.deltaTime; //检测强制打断 if (CheckSkillKey(true) == ComboState.Success) &#123; //_inputDelta = 0; DoChangeState(State.Running); &#125; break; case State.Holding: _holdingTime += Time.deltaTime; _skillTime += Time.deltaTime; if (_holdingTime &gt; _curSkill.holdingTime || !Input.anyKey) &#123; Debug.Log(&quot;超时或没有长按&quot;); DoChangeState(State.Waiting); &#125; else &#123; Debug.Log(&quot;执行长按技能 === &quot; + _curSkill.name); &#125; break; case State.Charging: _holdingTime += Time.deltaTime; _skillTime += Time.deltaTime; if (Input.anyKey) &#123; if (_holdingTime &gt; _curSkill.holdingTime) &#123; Debug.Log(&quot;蓄力完成&quot;); DoChangeState(State.Running); &#125; else &#123; Debug.Log(&quot;蓄力 === &quot; + _curSkill.name); &#125; &#125; else &#123; Debug.Log(&quot;停止蓄力&quot;); DoChangeState(State.Idle); &#125; break; case State.Waiting: //等待中增加间隔时间 _inputDelta += Time.deltaTime; //连击时间小于技能最大间隔时间 if (_inputDelta &lt;= _curSkill.outOfTime) &#123; //连击时间内检测 ComboState res = CheckSkillKey(false); if (res == ComboState.Success) &#123; //连招成功 DoChangeState(CheckSkillType(_curSkill.skillType)); Debug.Log(&quot;连招成功&quot;); &#125; else if (res == ComboState.Wrong) &#123; //连招错误 此处选择立即执行当前连招指令 也可以不执行，放下一帧再判断 if (CheckSkillKey(true) == ComboState.Success) &#123; //如果有招，直接转为别的连招 DoChangeState(CheckSkillType(_curSkill.skillType)); Debug.Log(&quot;转换连招&quot;); &#125; else &#123; //没有别的连招 状态重置 DoChangeState(State.Idle); Debug.Log(&quot;没有新连招&quot;); &#125; &#125; &#125; else &#123; //超时重置 DoChangeState(State.Idle); &#125; break; &#125; &#125; private State CheckSkillType(SkillType type) &#123; switch (type) &#123; case SkillType.Click: return State.Running; case SkillType.Hold: return State.Holding; case SkillType.Charge: return State.Charging; &#125; return State.Running; &#125; /// &lt;summary&gt; /// 执行状态 /// &lt;/summary&gt; private void DoStatus() &#123; switch (_state) &#123; case State.Idle: //RunIdle if (_onIdle != null) &#123; _onIdle(); &#125; break; case State.Running: //RunSkill if (_onRunning != null) &#123; _onRunning(); &#125; break; case State.Holding: //HoldingSkill if (_onHolding != null) &#123; _onHolding(); &#125; break; case State.Charging: //HoldingSkill if (_onCharging != null) &#123; _onCharging(); &#125; break; case State.Waiting: //RunWaiting if (_onWaiting != null) &#123; _onWaiting(); &#125; break; &#125; &#125; private void DoChangeState(State state) &#123; _state = state; _inputDelta = 0; _skillTime = 0; _holdingTime = 0; DoStatus(); Debug.Log(&quot;重置计数器&quot;); &#125; /// &lt;summary&gt; /// 检测连招是否成功 /// &lt;/summary&gt; /// &lt;param name=&quot;isRoot&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private ComboState CheckSkillKey(bool isRoot) &#123; if (Input.anyKeyDown) &#123; if (isRoot) &#123; if (_curSkill != null) &#123; //存在最近技能，并且从技能起手式开始检测 该情况为打断检测 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (skill.isCanForceStop &amp;&amp; skill.forceTimes &gt; 0 &amp;&amp; Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;打断并强制开始连招&quot; + skill.key); StopCoroutine(_skillCo); if (skill.name != _curSkill.name) &#123; _curSkill.isRunSkill = false; //_curSkill.forceTimes = _curSkill.defaultForceTimes; &#125; _curSkill = skill; --_curSkill.forceTimes; bool reset; _forceReset.TryGetValue(_curSkill.id, out reset); if (!reset) &#123; StartCoroutine(WaitForForceTimesReset(_curSkill)); &#125; return ComboState.Success; &#125; &#125; &#125; else &#123; //查找连招起手式 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;开始连招&quot; + skill.key); _curSkill = skill; return ComboState.Success; &#125; &#125; &#125; &#125; else &#123; //检测连招分支 for (int i = 0, len = _curSkill.next.Count; i &lt; len; i++) &#123; SkillTree skill = _curSkill.next[i]; if (Input.GetKeyDown(skill.key)) &#123; //连招成功 _curSkill = _curSkill.next[i]; return ComboState.Success; &#125; &#125; //连错招 重置 Debug.Log(&quot;连招重置&quot;); return ComboState.Wrong; &#125; &#125; return ComboState.Fail; &#125; /// &lt;summary&gt; /// 模拟技能执行时间 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private IEnumerator WaitForSkill() &#123; yield return new WaitForSeconds(_curSkill.skillTime); if (_curSkill != null) &#123; DoChangeState(State.Waiting); _curSkill.isRunSkill = false; &#125; &#125; private IEnumerator WaitForForceTimesReset(SkillTree obj) &#123; Debug.Log(&quot;开始重置强制打断次数 ：&quot; + obj.forceResetTime); yield return new WaitForSeconds(obj.forceResetTime); obj.forceTimes = obj.defaultForceTimes; _forceReset[obj.id] = false; Debug.Log(&quot;重置强制打断次数&quot;); &#125; /// &lt;summary&gt; /// 添加技能 /// &lt;/summary&gt; /// &lt;param name=&quot;skill&quot;&gt;&lt;/param&gt; public void AddSkill(SkillTree skill) &#123; _skills.Add(skill); &#125; /// &lt;summary&gt; /// 获取当前技能 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public SkillTree GetCurSkill() &#123; return _curSkill; &#125; public void OnIdle(Action callback) &#123; _onIdle = callback; &#125; public void OnRunning(Action callback) &#123; _onRunning = callback; &#125; public void OnHolding(Action callback) &#123; _onHolding = callback; &#125; public void OnCharging(Action callback) &#123; _onCharging = callback; &#125; public void OnWaiting(Action callback) &#123; _onWaiting = callback; &#125;&#125; 连招管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 连招状态枚举 空闲|执行中|等待/// &lt;/summary&gt;public enum State&#123; Idle, Running, Holding, Charging, Waiting&#125;/// &lt;summary&gt;/// 连招检测状态枚举 成功|失败|错误/// &lt;/summary&gt;public enum ComboState&#123; Success, Fail, Wrong&#125;public enum SkillType &#123; Click, Hold, Charge&#125;public class ComboManager&#123; private static ComboManager _instance = null; private ComboScript _comboScript; public static ComboManager Instance() &#123; if(_instance == null) &#123; _instance = new ComboManager(); &#125; return _instance; &#125; private ComboManager() &#123; &#125; public void Init() &#123; GameObject root = new GameObject(); root.name = &quot;ComboSystem&quot;; _comboScript = root.AddComponent&lt;ComboScript&gt;(); //初始化技能 此处暂时用代码写死 //实例化技能链 //技能A SkillTree skillA1 = new SkillTree(); skillA1.key = KeyCode.A; skillA1.name = &quot;连招A1&quot;; skillA1.id = 1; skillA1.outOfTime = 0.5f; skillA1.skillTime = 0.5f; skillA1.progressColor = Color.red; SkillTree skillA2 = new SkillTree(); skillA2.key = KeyCode.A; skillA2.name = &quot;连招A2&quot;; skillA2.id = 1; skillA2.outOfTime = 0.5f; skillA2.skillTime = 2f; skillA2.progressColor = new Color(0.8f, 0, 0, 1); skillA2.skillType = SkillType.Hold; skillA2.holdingTime = 2; SkillTree skillA3 = new SkillTree(); skillA3.key = KeyCode.A; skillA3.name = &quot;连招A3-1&quot;; skillA3.id = 1; skillA3.outOfTime = 0.5f; skillA3.skillTime = 0.5f; skillA3.progressColor = new Color(0.6f, 0, 0, 1); SkillTree skillA4 = new SkillTree(); skillA4.key = KeyCode.S; skillA4.name = &quot;连招A3-2&quot;; skillA4.id = 1; skillA4.outOfTime = 0.5f; skillA4.skillTime = 0.5f; skillA4.progressColor = new Color(0.4f, 0, 0, 1); skillA4.skillType = SkillType.Charge; skillA4.holdingTime = 2; skillA1.next.Add(skillA2); skillA2.next.Add(skillA3); skillA2.next.Add(skillA4); _comboScript.AddSkill(skillA1); //技能B SkillTree skillB1 = new SkillTree(); skillB1.key = KeyCode.B; skillB1.name = &quot;连招B1&quot;; skillB1.id = 2; skillB1.outOfTime = 0.5f; skillB1.skillTime = 0.5f; skillB1.isCanForceStop = true; skillB1.forceTimes = 1; skillB1.defaultForceTimes = 1; skillB1.forceResetTime = 5; skillB1.progressColor = Color.green; SkillTree skillB2 = new SkillTree(); skillB2.key = KeyCode.B; skillB2.name = &quot;连招B2&quot;; skillB2.id = 2; skillB2.outOfTime = 0.5f; skillB2.skillTime = 10f; skillB2.progressColor = new Color(0, 0.8f, 0, 1); skillB1.next.Add(skillB2); _comboScript.AddSkill(skillB1); Debug.Log(&quot;初始化完成&quot;); &#125; /// &lt;summary&gt; /// 获得当前技能 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public SkillTree GetCurSkill() &#123; return _comboScript.GetCurSkill(); &#125; /// &lt;summary&gt; /// Idle函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnIdle(Action callback) &#123; _comboScript.OnIdle(callback); &#125; /// &lt;summary&gt; /// Running函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnRunning(Action callback) &#123; _comboScript.OnRunning(callback); &#125; /// &lt;summary&gt; /// Holding函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnHolding(Action callback) &#123; _comboScript.OnHolding(callback); &#125; /// &lt;summary&gt; /// Charging函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnCharging(Action callback) &#123; _comboScript.OnCharging(callback); &#125; /// &lt;summary&gt; /// Waiting函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnWaiting(Action callback) &#123; _comboScript.OnWaiting(callback); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"IK算法之Fabrik","slug":"IK算法之Fabrik","date":"2023-10-30T14:29:55.000Z","updated":"2024-05-18T15:37:57.409Z","comments":true,"path":"article/5795c3870390/","link":"","permalink":"https://busyogg.github.io/article/5795c3870390/","excerpt":"","text":"简介IK（反向运动，Inverse Kinematics）是计算运动关节末端(如机械臂臂爪或人物骨架手臂末端的手掌)相对于关节的起始位置和方向到达所需位置的关节参数的数学过程。 –百度百科 Fabrik 算法通过计算骨骼节点的空间坐标关系来实现 IK 的效果。 原理概括Fabrik 算法一次迭代执行两个方向的遍历，首先从后往前计算到达目标点情况下所有骨骼的空间位置变化（不包括根节点），然后从前往后计算从根节点出发到达目标节点的骨骼节点位置。 从后往前 首先我们把最后一个骨骼节点置于目标位置，然后从后向前遍历骨骼节点，前一个节点的位置由后一个节点指向前一个节点的方向向量的单位向量乘以骨骼长度加上后一个节点当前的位置得到，即 $\\vec{dir}*length+P_{back}$ $\\vec{dir}&#x3D;normalized(P_{forward}-P_{back})$ 经过一轮遍历之后我们就可以得到除了根节点外的所有节点到达目标点的位置。 从前往后 然后我们从根节点开始从前向后遍历骨骼节点，后一个节点的位置由前一个节点指向后一个节点的方向向量的单位向量乘以骨骼长度加上前一个节点当前的位置得到，即 $\\vec{dir}*length+P_{forward}$ $\\vec{dir}&#x3D;normalized(P_{back}-P_{forward})$ 和从后往前的算法相反。 经过一轮迭代后，我们就可以得到一个相对正确的位置了。 约束因为 Fabrik 是基于骨骼节点位置的，因此会出现关节往奇怪方向弯曲的问题。所以为了解决这个问题就要对关节进行约束。 我使用向量叉乘来判断当前关节前后两个骨骼的方向是否符合约定的左右关系，不符合的话就旋转方向向量到我们需要的方向。 因为我初次接触 IK 算法，因此约束相关的内容还没有好的方案，这部分内容就请自行调整。 代码IKData12345678910using System.Collections;using System.Collections.Generic;using UnityEngine;public class IKData&#123; public Vector3 Pos &#123; get; set; &#125; public float Length &#123; get; set; &#125; public Transform Node &#123; get; set; &#125;&#125; IKRootScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152using System;using System.Collections.Generic;using UnityEngine;public class IKRootScript : MonoBehaviour&#123; public List&lt;IKData&gt; _ikList = new List&lt;IKData&gt;(); public Transform _leaf; public Vector3 _lastPos; public List&lt;GameObject&gt; _boneLine = new List&lt;GameObject&gt;(); void Start() &#123; InitBone(transform); InitLength(); _leaf = GameObject.Find(&quot;CtrlPoint&quot;).transform; _lastPos = _leaf.position; Debug.Log(&quot;骨骼数量&quot; + _ikList.Count); CreateBoneLine(); &#125; void LateUpdate() &#123; //控制点发生变化的时候计算IK if (_lastPos != _leaf.position) &#123; //IK迭代 for (int i = 0; i &lt; 3; i++) &#123; IKBack(_leaf.position); IKForward(); &#125; _lastPos = _leaf.position; UpdateBone(); &#125; &#125; /// &lt;summary&gt; /// 初始化骨骼节点 /// &lt;/summary&gt; /// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt; private void InitBone(Transform trans) &#123; IKData bone = new IKData(); bone.Pos = trans.position; bone.Node = trans; _ikList.Add(bone); if (trans.childCount &gt; 0) &#123; Transform child = trans.GetChild(0); InitBone(child); &#125; &#125; /// &lt;summary&gt; /// 初始化骨骼长度 /// &lt;/summary&gt; private void InitLength() &#123; for (int i = 0, len = _ikList.Count - 1; i &lt; len; i++) &#123; IKData first = _ikList[i]; IKData second = _ikList[i + 1]; first.Length = Math.Abs((second.Pos - first.Pos).magnitude); &#125; &#125; /// &lt;summary&gt; /// 创建骨架 /// &lt;/summary&gt; private void CreateBoneLine() &#123; for (int i = 0, len = _ikList.Count - 1; i &lt; len; i++) &#123; IKData parent = _ikList[i]; IKData child = _ikList[i + 1]; Vector3 center = (parent.Pos + child.Pos) * 0.5f; GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); cube.transform.position = center; cube.transform.localScale = new Vector3(0.2f, 0.2f, parent.Length); cube.transform.LookAt(child.Pos); _boneLine.Add(cube); &#125; &#125; /// &lt;summary&gt; /// 更新骨骼位置 /// &lt;/summary&gt; private void UpdateBone() &#123; for (int i = 0, len = _ikList.Count; i &lt; len; i++) &#123; //更新关节位置 IKData parent = _ikList[i]; parent.Node.position = parent.Pos; //更新骨架位置 if (i &lt; len - 1) &#123; IKData child = _ikList[i + 1]; GameObject cube = _boneLine[i]; Vector3 center = (parent.Pos + child.Pos) * 0.5f; cube.transform.position = center; cube.transform.LookAt(child.Pos); &#125; &#125; &#125; /// &lt;summary&gt; /// 反向迭代 /// &lt;/summary&gt; /// &lt;param name=&quot;target&quot;&gt;&lt;/param&gt; private void IKBack(Vector3 target) &#123; //末节点位置置为target _ikList[_ikList.Count - 1].Pos = target; //遍历迭代 for (int i = _ikList.Count - 1; i &gt; 1; i--) &#123; IKData parent = _ikList[i - 1]; IKData child = _ikList[i]; Vector3 nextBone = (parent.Pos - child.Pos).normalized; Vector3 lastBone = (parent.Pos - _ikList[i - 2].Pos).normalized; Vector3 side = Vector3.Cross(nextBone, lastBone); Debug.Log(i + &quot;:&quot; + side); Vector3 normal = (parent.Pos - child.Pos).normalized; if (side.x &lt;= 0 || side.y &lt;= 0 || side.z &lt;= 0) &#123; //按照权重和旋转方向调整方向向量 normal = Quaternion.Euler(new Vector3(2f, 0, 0)) * normal; &#125; parent.Pos = child.Pos + normal * parent.Length; Debug.Log(i + &quot;:&quot; + normal); &#125; &#125; /// &lt;summary&gt; /// 正向迭代 /// &lt;/summary&gt; private void IKForward() &#123; //遍历迭代 for (int i = 0, len = _ikList.Count - 1; i &lt; len; i++) &#123; IKData parent = _ikList[i]; IKData child = _ikList[i + 1]; Vector3 normal = (child.Pos - parent.Pos).normalized; child.Pos = parent.Pos + normal * parent.Length; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"逆向运动学","slug":"算法/逆向运动学","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"IK","slug":"IK","permalink":"https://busyogg.github.io/tags/IK/"},{"name":"Fabrik","slug":"Fabrik","permalink":"https://busyogg.github.io/tags/Fabrik/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"碰撞检测之射线与 AABB 和 OBB","slug":"碰撞检测之射线与AABB和OBB","date":"2023-10-15T12:29:10.000Z","updated":"2024-05-30T12:26:19.524Z","comments":true,"path":"article/e2b04b62f691/","link":"","permalink":"https://busyogg.github.io/article/e2b04b62f691/","excerpt":"","text":"简介射线检测可以用于拾取物体、判断前方是否有障碍物、判断是否碰撞等场景，本文介绍射线与 AABB 以及射线与 OBB 的检测原理。射线与 AABB 检测的原理是由射线与 OBB 检测简化而来，因此放在一起介绍。 原理当我们判断一条射线是否与一个矩形相交的时候，我们可以判断射线和矩形四条边的延长线的交点之间的关系。（slab 碰撞检测） 如图所示，我们有一条绿色射线与黑色矩形相交，得到四个点 P1、P2、P3、P4。其中在 y 轴方向的交点为 P1、P2，在 x 轴方向的交点为 P3、P4；我们有一条紫色射线与黑色矩形相交，得到四个点 P1’、P2’、P3’、P4’。其中在 x 轴方向的交点为 P1’、P2’，在 y 轴方向的交点为 P3’、P4’。 观察图像我们可以发现，当射线与圆相交的时候，P1P2 与 P3P4 在射线上存在相交的部分，当射线与圆不相交的时候，P1’P2’与 P3’P4’在射线上不存在相交的部分。 因此我们可以得到一个结论：当矩形两个方向轴上的四条边的延长线与射线相交的时候，所有轴向上的最小交点比最大交点要小，并且所有最小交点的最大值比所有最大交点的最小值都要小，这时候射线与矩形相交。 即：每个轴两条边的两个交点中的近点 P1、P3 中的最大值，要比远点 P2、P4 中的最小值还小，这样射线就与矩形相交。 所以对于射线与矩形，我们有$max(P1,P3)&lt;min(P2,P4)$，化为通式的话就是$max(Pmin_x,Pmin_y)&lt;min(Pmax_x,Pmax_y)$ 拓展到三维空间也是一样，二维空间是比较两个轴，三维空间就是比较三个轴，也要满足$max(Pmin_x,Pmin_y,Pmin_z)&lt;min(Pmax_x,Pmax_y,Pmax_z)$的关系。 在 OBB 中我们设射线 R 的起点为 C1，长度为 t，方向为 Dir；平面 S 的法线为 n，平面中一点为 D，平面到 R 起点的距离为 d，平面与射线的交点为 P，我们可以得到 射线的方程为： $P&#x3D;C1+t*Dir$ 平面的方程为： $Dot(P,n)&#x3D;d$ 当射线与平面相交的时候，两个方程的值相等，我们可以得到如下关系： $Dot(C1+t*Dir,n)&#x3D;d$ 由于点乘符合分配律，所以方程化为： $Dot(C1,n)+Dot(t*Dir,n)&#x3D;d$ 我们想要求出射线的长度 t，因此方程改造一下变成： $Dot(t*Dir,n)&#x3D;d-Dot(C1,n)$ 由于点乘符合结合律，所以方程化为： $t*Dot(Dir,n)&#x3D;d-Dot(C1,n)$ 化简得到： $t&#x3D;(d-Dot(C1,n))&#x2F;Dot(Dir,n)$ 因为我们不知道 d，所以根据平面方程，我们可以得到： $t&#x3D;(Dot(P,n)-Dot(C1,n))&#x2F;Dot(Dir,n)$ 由分配律，我们最终得到： $t&#x3D;(Dot(P-C1,n))&#x2F;Dot(Dir,n)$ 在 OBB 包围盒中，最大点和最小点分别横跨三个最大面和最小面，因此满足方程： $Dot(P_{min},n)&#x3D;d$ $Dot(P_{max},n)&#x3D;d$ 所以，三个最小面的最小距离为： $t&#x3D;(Dot(P_{min}-C1,n))&#x2F;Dot(Dir,n)$ 三个最大面的最大距离为： $t&#x3D;(Dot(P_{max}-C1,n))&#x2F;Dot(Dir,n)$ 最后，我们只需要判断$max(t_{min_x},t_{min_y},t_{min_z})&lt;min(t_{max_x},t_{max_y},t_{max_z})$就能知道是否相交。 交点只要带入射线方程即可得到。 需要注意的是，我们都是以射线和包围盒方向轴同向为正方向，因此当方向相反的时候（$Dot(Dir,n)&lt;0$），我们要交换$t_{min}$和$t_{max}$的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//包围盒数据结构public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f; public Vector3 direction = Vector3.zero; public Vector3[] vertexts = new Vector3[8]; public Vector3[] axes = new Vector3[3];&#125;---------------------------------------------/// &lt;summary&gt;/// 射线和OBB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionRay2OBB(CollisionData data1,CollisionData data2)&#123; //判断不在OBB内 Vector3 centerDis = data1.center - data2.center; float ray2ObbX = Vector3.Dot(centerDis, data2.axes[0]); float ray2ObbY = Vector3.Dot(centerDis, data2.axes[1]); float ray2ObbZ = Vector3.Dot(centerDis, data2.axes[2]); bool checkNotInside = ray2ObbX &lt; -data2.extents[0] || ray2ObbX &gt; data2.extents[0] || ray2ObbY &lt; -data2.extents[1] || ray2ObbY &gt; data2.extents[1] || ray2ObbZ &lt; -data2.extents[2] || ray2ObbZ &gt; data2.extents[2]; //判断反向情况 bool checkFoward = Vector3.Dot(data2.center - data1.center, data1.direction) &lt; 0; if (checkNotInside &amp;&amp; checkFoward) &#123; return false; &#125; //判断是否相交 Vector3 min = Vector3.zero; Vector3 minP = data2.vertexts[4] - data1.center; min.x = Vector3.Dot(minP, data2.axes[0]); min.y = Vector3.Dot(minP, data2.axes[1]); min.z = Vector3.Dot(minP, data2.axes[2]); Vector3 max = Vector3.zero; Vector3 maxP = data2.vertexts[2] - data1.center; max.x = Vector3.Dot(maxP, data2.axes[0]); max.y = Vector3.Dot(maxP, data2.axes[1]); max.z = Vector3.Dot(maxP, data2.axes[2]); Vector3 projection = Vector3.zero; projection.x = 1 / Vector3.Dot(data1.direction, data2.axes[0]); projection.y = 1 / Vector3.Dot(data1.direction, data2.axes[1]); projection.z = 1 / Vector3.Dot(data1.direction, data2.axes[2]); Vector3 pMin = Vector3.Scale(min, projection); Vector3 pMax = Vector3.Scale(max, projection); if (projection.x &lt; 0) Swap(ref pMin.x, ref pMax.x); if (projection.y &lt; 0) Swap(ref pMin.y, ref pMax.y); if (projection.z &lt; 0) Swap(ref pMin.z, ref pMax.z); float n = Mathf.Max(pMin.x, pMin.y, pMin.z); float f = Mathf.Min(pMax.x, pMax.y, pMax.z); Debug.Log(n + &quot; &quot; + f); Debug.Log(pMin + &quot; &quot; + pMax); Debug.Log(projection); bool res = false; if (!checkNotInside) &#123; res = true; Vector3 point = data1.center + data1.direction * f; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125; else &#123; if (n &lt; f &amp;&amp; data1.radius &gt;= n) &#123; res = true; &#125; else &#123; return false; &#125; Vector3 point = data1.center + data1.direction * n; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125; return res;&#125; 在 AABB 中由于 AABB 包围盒的方向轴与坐标轴一致，所以我们可以简化方程。 在 X 轴上，我们有$t_{yz}&#x3D;(Dot(P-C1,n_{yz}))&#x2F;Dot(Dir,n_{yz})$ 又因为$n_{yz}&#x3D;(1,0,0)$，只有 x 上有值 所以$t_{yz}&#x3D;(P.x-C1.x)&#x2F;Dir.x$ 同理可得其他面也是这样，因此最后我们可以得到如下方程： $t&#x3D;(P-C1)&#x2F;Dir$ 其他部分就和射线与 OBB 的算法一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//包围盒数据结构public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f; public Vector3 direction = Vector3.zero; public Vector3 max = Vector3.zero; public Vector3 min = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// 射线和AABB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private void CollisionRay2AABB(CollisionData data1,CollisionData data2)&#123; //判断是否不在AABB内 bool checkNotInside = data1.center.x &gt; data2.max.x || data1.center.x &lt; data2.min.x || data1.center.y &gt; data2.max.y || data1.center.y &lt; data2.min.y || data1.center.z &gt; data2.max.z || data1.center.z &lt; data2.min.z; //判断反向情况 bool checkForawd = Vector3.Dot(data2.center - data1.center, data1.direction) &lt; 0; if (checkNotInside &amp;&amp; checkForawd) &#123; line1.Collided(false); line2.Collided(false); return; &#125; //判断是否相交 Vector3 min = data2.min - data1.center; Vector3 max = data2.max - data1.center; Vector3 projection = new Vector3(1 / data1.direction.x, 1 / data1.direction.y, 1 / data1.direction.z); Vector3 pMin = Vector3.Scale(min, projection); Vector3 pMax = Vector3.Scale(max, projection); if (data1.direction.x &lt; 0) Swap(ref pMin.x, ref pMax.x); if (data1.direction.y &lt; 0) Swap(ref pMin.y, ref pMax.y); if (data1.direction.z &lt; 0) Swap(ref pMin.z, ref pMax.z); float n = Mathf.Max(pMin.x, pMin.y, pMin.z); float f = Mathf.Min(pMax.x, pMax.y, pMax.z); if (!checkNotInside) &#123; line1.Collided(true); line2.Collided(true); Vector3 point = data1.center + data1.direction * f; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125; else &#123; if (n &lt; f &amp;&amp; data1.radius &gt;= n) &#123; line1.Collided(true); line2.Collided(true); &#125; else &#123; line1.Collided(false); line2.Collided(false); return; &#125; Vector3 point = data1.center + data1.direction * n; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125;&#125; 其他情况和射线与圆相交检测一样，当射线在包围盒内的时候一定相交；当射线与包围盒相反的时候一定不相交。 对于 AABB 来说，只要判断射线起点和 AABB 包围盒的最大最小点的关系就可以判断是否在包围盒内，对于 OBB 来说要把射线起点映射到 OBB 坐标系中，然后按照 AABB 的方式来判断。 碰撞检测示例工程 更新日志2024-03-21 修复描述错误。 2023-10-15 更新基本内容。","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"射线","slug":"射线","permalink":"https://busyogg.github.io/tags/%E5%B0%84%E7%BA%BF/"}]},{"title":"碰撞检测之射线与圆","slug":"碰撞检测之射线与圆","date":"2023-10-08T11:20:39.000Z","updated":"2024-05-18T15:39:38.391Z","comments":true,"path":"article/d898103b68b3/","link":"","permalink":"https://busyogg.github.io/article/d898103b68b3/","excerpt":"","text":"简介射线检测可以用于拾取物体、判断前方是否有障碍物、判断是否碰撞等场景，本文介绍射线与圆的检测原理。 原理射线与圆的检测，有以下几点判断： 射线方向是否与射线起点与圆的方向相反，是则不相交； 射线是否过短，是则不相交； 如图所示，射线 R 在射线原点与圆心方向的投影加上圆 C 的半径长度之和小于射线原点与圆心的距离 RC，射线过短。（黑线表示距离和，蓝线表示 RC） 射线是否在园内，是则必定相交； 当射线与圆相交的时候，如下图所示： 我们投影射线原点与圆心的距离 d 到射线 R 上，记为 p，并通过圆心作一条垂直于射线 R 的垂线 g，我们可以得到如下关系： f1 : $p^2+g^2&#x3D;d^2$ 我们把交点到射线原点的距离记为 t，到垂线 g 的距离记为 s，线段 s 满足以下关系：f2 : $s^2+g^2&#x3D;r^2$ 我们合并两个三角形方程f1、f2，得到方程 $p^2+g^2-s^2+g^2&#x3D;d^2-r^2$，化简得到：f3 : $s^2&#x3D;p^2-d^2+r^2$ 由此可知，如果射线与圆相交，则以上等式恒成立，即如果以上等式不成立的情况下，射线与圆不相交。因此我们判断方程f3的情况是否成立，开根号得到： f4 : $s&#x3D;\\pm\\sqrt[]{p^2-d^2+r^2}$，那么我们只要判断$p^2-d^2+r^2&gt;&#x3D;0$就知道射线与圆是否相交，p、d、r 均为已知数。 当我们要求交点的时候，我们只要带入上文已求的 p 和 s，得到近点距离为：$t&#x3D;p-s$；远点距离为：$t&#x3D;p+s$，然后以射线原点出发，加上方向向量的单位向量乘以距离，即可求出交点。 对于三维空间来说，我们求的也是射线与球的一个面，即圆的关系。因此算法和二维空间一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243//包围盒数据结构public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f; public Vector3 direction = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// 射线和球检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionRay2Circle(CollisionData data1,CollisionData data2)&#123; Vector3 centerDis = data2.center - data1.center; Vector3 direction = data1.direction; float projection = Vector3.Dot(centerDis, direction); float r2 = Mathf.Pow(data2.radius, 2); float f = Mathf.Pow(projection, 2) + r2 - centerDis.sqrMagnitude; //方向相反 bool checkDirection = projection &lt; 0; //射线过短 bool checkDistance = centerDis.sqrMagnitude &gt; Mathf.Pow(data1.radius + data2.radius, 2); //射线起点在球内部 bool checkNotInside = centerDis.sqrMagnitude &gt; r2; //不相交 bool checkNotCollide = f &lt; 0; if (checkNotInside &amp;&amp; (checkDirection || checkDistance || checkNotCollide)) &#123; return false; &#125; float dis = projection - Mathf.Sqrt(f) * (checkNotInside ? 1 : -1); Vector3 point = data1.center + data1.direction * dis; ConsoleUtils.Log(&quot;碰撞点&quot;, point); return true;&#125; 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"},{"name":"射线","slug":"射线","permalink":"https://busyogg.github.io/tags/%E5%B0%84%E7%BA%BF/"}]},{"title":"碰撞检测之圆与OBB","slug":"碰撞检测之圆与OBB","date":"2023-09-28T08:43:29.000Z","updated":"2024-05-18T15:38:30.812Z","comments":true,"path":"article/2d2709a1efcf/","link":"","permalink":"https://busyogg.github.io/article/2d2709a1efcf/","excerpt":"","text":"简介圆与 OBB 进行碰撞检测，和圆与 AABB 进行碰撞检测类似，实质可以化为一个点与 OBB 进行检测，然后根据检测结果与圆的半径进行比较。 原理和圆与 AABB 碰撞检测类似，圆与 OBB 碰撞检测也是化为点与 OBB 检测。因此，我们需要把点的坐标化为 OBB 坐标系的坐标。这里我们利用投影，把点的坐标投影到 OBB 坐标系中，然后再使用点与 AABB 检测的思路进行检测，最后把得到的交点转换回原来的坐标系中。 如图所示，我们连接两个物体的中心点 C1 和 C2，得到一个距离向量 DIR（矩形中心到圆心）。然后我们把 dir 投影到矩形的坐标轴上，得到 X 方向的投影 X’和 Y 方向的投影 Y’，由此可以得出 C1 点在矩形坐标系中的位置。 然后我们利用圆与 AABB 检测的方法得到 OBB 上距离 C1 点的最近点，并且还原这个坐标到原始坐标轴中。具体方法是令最近点 Pnear 初始值为 C2 坐标，然后在求交点在每个轴坐标的时候让 P 的每个轴的值加上坐标值distance * 坐标轴向量的分量，即 Pnear.x += distance * axis[i].x ,以此类推。 得到最近点之后，我们就可以用和圆与 AABB 检测一样的方法来判断是否相交了。 三维空间和二维空间的求法一样，只不过多一个轴。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public Vector3 extents = Vector3.zero; public Vector3[] axes = new Vector3[3]; public float radius = 1.0f;&#125;---------------------------------------------/// &lt;summary&gt;/// 球与OBB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionCircle2OBB(CollisionData data1,CollisionData data2)&#123; //求最近点 Vector3 nearP = GetClosestPointOBB(data1,data2); //与AABB检测原理相同 float distance = (nearP - data1.center).sqrMagnitude; float radius = Mathf.Pow(data1.radius, 2); if (distance &lt;= radius) &#123; return true; &#125; else &#123; return false; &#125;&#125;/// &lt;summary&gt;/// 获取一点到OBB的最近点/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private Vector3 GetClosestPointOBB(CollisionData data1,CollisionData data2)&#123; Vector3 nearP = data2.center; //求球心与OBB中心的距离向量 从OBB中心指向球心 Vector3 center1 = data1.center; Vector3 center2 = data2.center; Vector3 dist = center1 - center2; float[] extents = new float[3] &#123; data2.extents.x, data2.extents.y, data2.extents.z &#125;; Vector3[] axes = data2.axes; for (int i = 0; i &lt; 3; i++) &#123; //计算距离向量到OBB坐标轴的投影长度 即距离向量在OBB坐标系中的对应坐标轴的长度 float distance = Vector3.Dot(dist, axes[i]); distance = Mathf.Clamp(distance, -extents[i], extents[i]); //还原到世界坐标 nearP.x += distance * axes[i].x; nearP.y += distance * axes[i].y; nearP.z += distance * axes[i].z; &#125; return nearP;&#125; 其他和圆与圆的检测一样，圆与 OBB 检测求两点距离的时候也使用平方来计算，减少开方的性能消耗。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"}]},{"title":"碰撞检测之圆与AABB","slug":"碰撞检测之圆与AABB","date":"2023-09-26T16:11:11.000Z","updated":"2024-05-18T15:38:31.960Z","comments":true,"path":"article/09bda077a263/","link":"","permalink":"https://busyogg.github.io/article/09bda077a263/","excerpt":"","text":"简介圆与 AABB 进行碰撞检测，实质可以化为一个点与 AABB 进行检测，然后根据检测结果与圆的半径进行比较。 原理二维 首先我们把圆与 AABB 的问题化为点与 AABB 的问题。 从一个点到一条直线的最短距离，就是从这个点做一条垂线，这样我们就得到了一个点 P。 如图所示，在 Y 轴上，这个点的 Y 坐标在矩形 Y 坐标的最大值和最小值之间。这时我们观察图像可知，P 点的 Y 坐标就是圆心的 Y 坐标。 在 X 轴上，这个点的 X 坐标在矩形 X 坐标的最大值和最小值之外。由于 P 点是矩形上一点，因此 P 的 X 坐标一定限制在矩形的 X 坐标之内。所以，此时 P 点的 X 坐标为矩形的 X 坐标最小值。 通过这两条我们不难看出，一个点在 AABB 的最近点坐标一定在 AABB 最大最小坐标之内，如果超出的话就设置为 AABB 的最大或最小坐标。 当我们得到 P 点坐标之后，就可以通过圆心和 P 点求出这两个点之间的距离。然后我们只需要比较这个距离和圆半径的关系就可以知道这两个物体是否相交。 三维在三维空间中，两个对象碰撞检测的原理和二维空间一样，只不过多加了一个 Z 轴。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 max = Vector3.zero; public Vector3 min = Vector3.zero; public Vector3 center = Vector3.zero; public float radius = 1.0f;&#125;---------------------------------------------/// &lt;summary&gt;/// 球与AABB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionCircle2AABB(CollisionData data1,CollisionData data2)&#123; //求出最近点 Vector3 center = data1.center; Vector3 nearP = GetClosestPointAABB(data1,data2); //求出最近点与球心的距离 float distance = (nearP - center).sqrMagnitude; float radius = Mathf.Pow(data1.radius, 2); //距离小于半径则碰撞 if (distance &lt;= radius) &#123; return true; &#125; return false;&#125;/// &lt;summary&gt;/// 获得一点到AABB最近点/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private Vector3 GetClosestPointAABB(CollisionData data1,CollisionData data2)&#123; Vector3 center = data1.center; Vector3 nearP = Vector3.zero; nearP.x = Mathf.Clamp(center.x, data2.min.x, data2.max.x); nearP.y = Mathf.Clamp(center.y, data2.min.y, data2.max.y); nearP.z = Mathf.Clamp(center.z, data2.min.z, data2.max.z); return nearP;&#125; 其他和圆与圆的检测一样，圆与 AABB 检测求两点距离的时候也使用平方来计算，减少开方的性能消耗。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"}]},{"title":"碰撞检测之圆与圆","slug":"碰撞检测之圆与圆","date":"2023-09-26T15:46:22.000Z","updated":"2024-05-18T15:38:33.204Z","comments":true,"path":"article/2bef1c973f07/","link":"","permalink":"https://busyogg.github.io/article/2bef1c973f07/","excerpt":"","text":"简介用圆或球来包裹物体，检测两个物体是否有碰撞。 原理 判断两个圆是否相交，只需要判断两个圆心的距离小于等于（也可以只是小于，看需求）两个圆的半径之和，若小于，则相交。 二维空间和三维空间的原理相同，也是判断两个球心的距离小于等于两个球的半径之和。 物体的包围球可能会存在较大的空隙，因此包围球检测的精度较低。 我们在求距离的时候，可以使用平方来计算，因为平方的开销比开方小，这样可以优化性能。 1234567891011121314151617181920212223242526272829//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f;&#125;---------------------------------------------/// &lt;summary&gt;/// 球与球检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionCircle(CollisionData data1,CollisionData data2)&#123; //求两个球半径和的平方 float totalRadius = Mathf.Pow(data1.radius + data2.radius, 2); //球两个球心之间的距离平方 float distance = (data1.center - data2.center).sqrMagnitude; //距离小于等于半径和则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; return false;&#125; 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"}]},{"title":"碰撞检测之OBB","slug":"碰撞检测之OBB","date":"2023-09-25T15:27:33.000Z","updated":"2024-05-18T15:38:27.157Z","comments":true,"path":"article/3c9cb66ca768/","link":"","permalink":"https://busyogg.github.io/article/3c9cb66ca768/","excerpt":"","text":"简介OBB 检测，即有向包围盒（Oriented Bounding Box）检测，是一种检测两个物体有没有相交的算法。物体根据包围盒中心、包围盒大小以及包围盒旋转轴构造有向包围盒，该包围盒比 AABB 包围盒更贴合旋转物体。OBB 检测利用 SAT（Separating AxisTheorem）分离轴算法进行相交检测，比 AABB 检测具有更好的检测精度。 原理 对于两个凸多边形来说，若存在一条直线把两个凸多边形分开，那么垂直于这条直线的轴则称为分离轴。若两个物体在分离轴上的投影不相交，则两个物体不相交，并且一旦在某个轴上存在不相交的情况，则两个物体一定不相交，退出检测。 在实际运用中，我们常以凸多边形的边的垂线作为分离轴，依次检测物体在分离轴上的投影。 二维 在 2D 图形中，分离轴的数量为两个凸多边形物体的边数之和，如上图所示，4 条黑色的轴为分离轴。在分离轴 1 上，我们观察到物体 A 的投影和物体 B 的投影相交了，因此在分离轴 1 上，两个物体相交；在分离轴 2 上，我们观察到两个物体的投影没有相交，因此两个物体在分离轴 2 上没有相交。 由此，我们可以得出 A、B 两个物体没有相交。通过观察图像我们也知道这个结果没错。 三维在 3D 中，我们以一个有向的长方体来包围物体，即 OBB。 由于长方体的坐标轴两两垂直，因此坐标轴即是分离轴。由于两个长方体之间还存在特殊的摆放。 在这种情况下，两个包围盒的坐标轴分离轴投影均相交，但是这两个物体并没有相交，两个物体之间还是存在一个面能够把两个物体分开，这个面就是向量 A 和向量 B 构成的平面。 利用向量叉乘的性质，我们可以求出一个垂直于这个面的向量，我们以这个向量为新的分离轴。两个物体每两条边构成的面都需要求垂直向量，因此两个 OBB 包围盒之间有 3 * 3 = 9 条新的分离轴。加上原来两个向量的 3 + 3 = 6 条分离轴，在 3D 中一共要检测15条分离轴。 对于其中一条分离轴，我们遍历顶点作为向量，投影到分离轴上，筛选出最大和最小值。对两个物体进行同样的操作后，我们比较两个物体的投影最值有无相交。每条分离轴以此方法操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3[] vertexts = new Vector3[8]; public Vector3[] axes = new Vector3[3]; public Vector3 center = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// SAT分离轴碰撞检测之OBB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionOBB(CollisionData data1,CollisionData data2)&#123; //求与两个OBB包围盒之间两两坐标轴垂直的法线轴 共9个 int len1 = data1.axes.Length; int len2 = data2.axes.Length; Vector3[] axes = new Vector3[len1 + len2 + len1 * len2]; int k = 0; int initJ = len2; for (int i = 0; i &lt; len1; i++) &#123; axes[k++] = data1.axes[i]; for (int j = 0; j &lt; len2; j++) &#123; if (initJ &gt; 0) &#123; initJ--; axes[k++] = data2.axes[j]; &#125; axes[k++] = Vector3.Cross(data1.axes[i], data2.axes[j]); &#125; &#125; for (int i = 0, len = axes.Length; i &lt; len; i++) &#123; if (NotInteractiveOBB(data1.vertexts, data2.vertexts, axes[i])) &#123; //有一个不相交就退出 return false; &#125; &#125; return true;&#125;/// &lt;summary&gt;/// 计算投影是否不相交/// &lt;/summary&gt;/// &lt;param name=&quot;vertexs1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;vertexs2&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;axis&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private bool NotInteractiveOBB(Vector3[] vertexs1, Vector3[] vertexs2, Vector3 axis)&#123; //计算OBB包围盒在分离轴上的投影极限值 float[] limit1 = GetProjectionLimit(vertexs1, axis); float[] limit2 = GetProjectionLimit(vertexs2, axis); //两个包围盒极限值不相交，则不碰撞 return limit1[0] &gt; limit2[1] || limit2[0] &gt; limit1[1];&#125;/// &lt;summary&gt;/// 计算顶点投影极限值/// &lt;/summary&gt;/// &lt;param name=&quot;vertexts&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;axis&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private float[] GetProjectionLimit(Vector3[] vertexts, Vector3 axis)&#123; float[] result = new float[2] &#123; float.MaxValue, float.MinValue &#125;; for (int i = 0, len = vertexts.Length; i &lt; len; i++) &#123; Vector3 vertext = vertexts[i]; float dot = Vector3.Dot(vertext, axis); result[0] = Mathf.Min(dot, result[0]); result[1] = Mathf.Max(dot, result[1]); &#125; return result;&#125; 其他OBB 检测只能是凸多边形，不适用于凹多边形的情况。凹多边形可以分割为凸多边形进行检测。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"SAT分离轴","slug":"SAT分离轴","permalink":"https://busyogg.github.io/tags/SAT%E5%88%86%E7%A6%BB%E8%BD%B4/"}]},{"title":"碰撞检测之AABB","slug":"碰撞检测之AABB","date":"2023-09-25T14:35:26.000Z","updated":"2024-05-18T15:38:29.519Z","comments":true,"path":"article/1f60a8286c97/","link":"","permalink":"https://busyogg.github.io/article/1f60a8286c97/","excerpt":"","text":"简介AABB 检测，即轴对齐包围盒（Axis-Aligned Bounding Boxes）检测，是一种检测两个物体有没有相交的算法。物体根据坐标轴形成包围盒，通过检测顶点关系来判断是否相交。 原理一维 如上图所示，在一维坐标轴中，存在一个物体 AB，一个物体 CD 以及一个物体 EF。 当我们要检测物体 AB 和 CD 是否相交的时候，我们不难看出，只要物体 CD 的最大坐标和最小坐标都不在物体 AB 的坐标之间，那我们就认为这两个物体没有相交。 当我们检测物体 AB 和物体 EF 是否相交的时候，我们观察到物体 AB 和物体 EF 的坐标相交了，因此这两个物体相交。 由此我们可以得出，当一个物体的最大坐标和最小坐标都不在另一个物体的最大坐标和最小坐标之间，则两个物体没有相交。 二维这个原理拓展到二维坐标中，即 2D 平面中也成立。 同样的，我们在平面中也存在 A、B、C、D 四个物体。 对于物体 A 和物体 D，在 X 轴中，我们需要判断 D 的 X 最大值和 D 的 X 最小值都不在 A 的 X 最大值和 X 最小值中，我们就能判断连个物体不相交。 对于物体 A 和物体 C，在 X 轴中，我们需要判断 C 的 Y 最大值和 C 的 Y 最小值都不在 A 的 Y 最大值和 Y 最小值中，我们就能判断连个物体不相交。 因此，对于平面来说，我们只是拓展了一个轴的检测，并且这两个轴的检测只要有一个成立，就表示两个物体不相交。 我们在做平面 AABB 检测的时候会出现三种情况，即 B、C、D 三个物体和 A 物体之间的关系。这三种情况只要出现一种成立即可。所以，我们判断物体关系的时候就判断不成立的情况，用或来连接，可以减少计算量。并且当我们判断的时候可以直接用一个物体的最大值去比另一个物体的最小值，用最小值去比最大值，进一步减少计算。 三维在三维空间中进行 AABB 检测与在二维空间中检测并无不同，只是要检测的轴再增加一个 Z 轴。三个轴之间的关系也是或的关系。 1234567891011121314151617181920212223242526272829//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 max = Vector3.zero; public Vector3 min = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// AABB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;//AABB检测private bool CollisionAABB(CollisionData data1,CollisionData data2)&#123; //包围盒1的最小值比包围盒2的最大值还大 或 包围盒1的最大值比包围盒2的最小值还小 则不碰撞 if (data1.max.x &lt; data2.min.x || data1.max.y &lt; data2.min.y || data1.max.z &lt; data2.min.z || data1.min.x &gt; data2.max.x || data1.min.y &gt; data2.max.y || data1.min.z &gt; data2.max.z) &#123; return false; &#125; else &#123; return true; &#125;&#125; 其他AABB 检测在物体有旋转的情况下会造成包围盒过大，因此检测的精度不是很高。具体情况如下图所示。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"}]},{"title":"TS实现ECS架构","slug":"TS实现ECS架构","date":"2023-09-14T17:40:51.000Z","updated":"2024-05-18T15:37:27.180Z","comments":true,"path":"article/be8112f144cf/","link":"","permalink":"https://busyogg.github.io/article/be8112f144cf/","excerpt":"","text":"简介ECS 架构是 实体（Entity）-组件（Component）-系统（System） 组成的架构，主要目的是对数据和逻辑进行解耦以便更好的维护系统。其运行的原理也能提高 CPU 的缓存命中，即可以提高游戏运行的性能。 原理概述ECS 架构简单来说就是用实体来组合组件，用组件来保存数据，用系统来进行运算。单一的实体没有任何意义，只有在组合组件之后这个实体才有意义。组件只能用于保存数据，不能自己进行任何的运算。系统只负责运算，不会持久化保存任何数据。这样就把数据和逻辑分离开来，通过组合的方式实现特定的功能，实现数据和逻辑的解耦，以及逻辑与逻辑之间的解耦。 大致示意图如下 组件组件是 ECS 架构的基础，实体需要组件，系统也根据组件处理逻辑。组件的设计很简单，我们只需要以下基础属性和方法： 组件 id，每个组件都拥有一个属于自己的 id，这个 id 是全局唯一的。 组件名，每个组件都拥有一个属于自己的名字，这个名字是全局唯一的。 实体，保存组件所属的具体实体。 是否可以被回收，有些组件在实体移除后需要回收，有些则不从实体回收。 重置方法，用于回收组件之后进行组件的重置。 因此我们可以定义一个组件接口，接口不关心组件的具体信息，只关心组件是否可以回收、组件的所属以及重置方法。 IComp1234567import Entity from &quot;../Entity&quot;;export default interface IComp &#123; canRecycle: boolean; entity: Entity; reset(): void;&#125; 然后我们定义一个抽象组件基类。 Comp12345678910import Entity from &quot;./Entity&quot;;import IComp from &quot;./Interface/IComp&quot;;export abstract class Comp implements IComp &#123; static tid = -1; static compName: string; public canRecycle: boolean = true; public entity: Entity | null; abstract reset(): void;&#125; 然后我们就可以定义实际的 Comp 类来保存我们需要的数据。 组件还有一种形式是标签，标签不继承抽象组件基类，但是在注册的时候也是和组件共享一套 id 自增规则。注意，标签类中的属性要任意赋一个值，这样才能在注册的时候获取到这个属性。 实体实体是组件的合集，虽然实体的概念很简单，但是实体的实现却比较复杂。实体需要实现组件的添加和移除，也要在添加移除组件的时候通知对应系统进行处理，同时实体也要提供组件的查询功能。当然，实体自身也要提供移除的方法。 掩码工具由于实体需要查询组件，系统也需要查询组件，因此我们需要先设计对应的功能。此处我们选择用二进制数来制作掩码系统保存组件信息。 这里我们使用一个二进制数组来保存，用数组的目的是如果组件数超过二进制数大小，就在数组增加一个二进制数来保存。在 32 位二进制数中，由于与（&amp;）操作符最大只能操作 30 位数（一位符号位，一位进位），因此一个数只保存 30 个组件。 由于组件的数量在游戏的最开始就初始化完成，因此 Mask 实例的组件总数是固定的。 当我们进行掩码运算时，传入的组件 id 转为二进制数和当前的掩码进行比较，例如我们设置组件时，假设当前掩码为 0000 0000 0000 0000 ，传入的组件 id 为 3，则我们把组件 id 化为 1 &lt;&lt; (3 % 31)，即 1 左移 3 位，得到 1000 ，0000 0000 0000 0000 &amp; 1000 = 0000 0000 0000 1000，最终的组件就保存下来了。 也就是说 32 位掩码就是插槽，组件的 id 就是往哪个插槽插入组件，这样就能表示保存的组件了。 Mask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import ECSManager from &quot;./ECSManager&quot;;export default class Mask &#123; /** 32位二进制数组 由于&amp;操作符最大只能30位操作 故每个三十二位二进制保存30个组件 */ private mask: Uint32Array; private size: number = 0; constructor() &#123; //计算32位掩码数量 (总组件数/31) let length = Math.ceil(ECSManager.getInst().getCompTid() / 31); this.mask = new Uint32Array(length); this.size = length; &#125; /** * 设置掩码 或 * @param num */ set(num: number) &#123; /// &gt;&gt;&gt; 无符号位移 高位补0 this.mask[(num / 31) &gt;&gt;&gt; 0] |= 1 &lt;&lt; num % 31; &#125; /** * 移除掩码 与 取反 * @param num */ delete(num: number) &#123; this.mask[(num / 31) &gt;&gt;&gt; 0] &amp;= ~(1 &lt;&lt; num % 31); &#125; /** * 查找 与 * @param num * @returns */ has(num: number) &#123; // !!取布尔值 0或1 return !!(this.mask[(num / 31) &gt;&gt;&gt; 0] &amp; (1 &lt;&lt; num % 31)); &#125; or(other: Mask) &#123; for (let i = 0; i &lt; this.size; i++) &#123; // &amp;操作符最大也只能对2^30进行操作，如果对2^31&amp;2^31会得到负数。当然可以(2^31&amp;2^31) &gt;&gt;&gt; 0，这样多了一步右移操作。 if (this.mask[i] &amp; other.mask[i]) &#123; return true; &#125; &#125; return false; &#125; and(other: Mask) &#123; for (let i = 0; i &lt; this.size; i++) &#123; if ((this.mask[i] &amp; other.mask[i]) != this.mask[i]) &#123; return false; &#125; &#125; return true; &#125; clear() &#123; for (let i = 0; i &lt; this.size; i++) &#123; this.mask[i] = 0; &#125; &#125;&#125; 筛选工具因为系统以实体进行遍历的，所以有了掩码之后，我们就可以对实体进行筛选了，通过比较实体的组件掩码和筛选工具的组件掩码，我们就可以筛选出系统需要的实体。 首先我们定义一个匹配规则抽象基类，基类的构造函数根据传入的组件设置掩码，并且按顺序保存组件 id。 然后我们定义各个匹配规则的类，判断是否匹配只需要调用掩码定义的规则即可。 所有规则类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import &#123; CompTypeUnion &#125; from &quot;./ECSManager&quot;;import Entity from &quot;./Entity&quot;;import &#123; CompType &#125; from &quot;./Interface/CompType&quot;;import IComp from &quot;./Interface/IComp&quot;;import Mask from &quot;./Mask&quot;;export abstract class BaseOf &#123; protected mask = new Mask(); public indices: number[] = []; constructor(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; let componentTypeId = -1; let len = args.length; for (let i = 0; i &lt; len; i++) &#123; if (typeof args[i] === &quot;number&quot;) &#123; componentTypeId = args[i] as number; &#125; else &#123; componentTypeId = (args[i] as CompType&lt;IComp&gt;).tid; &#125; if (componentTypeId == -1) &#123; console.error(&quot;存在没有注册的组件！&quot;); &#125; this.mask.set(componentTypeId); if (this.indices.indexOf(componentTypeId) &lt; 0) &#123; // 去重 this.indices.push(componentTypeId); &#125; &#125; if (len &gt; 1) &#123; // 对组件类型id进行排序，这样关注相同组件的系统就能共用同一个group this.indices.sort((a, b) =&gt; &#123; return a - b; &#125;); &#125; &#125; public toString(): string &#123; return this.indices.join(&quot;-&quot;); // 生成group的key &#125; public abstract getKey(): string; public abstract isMatch(entity: Entity): boolean;&#125;/** * 用于描述包含任意一个这些组件的实体 */export class AnyOf extends BaseOf &#123; public isMatch(entity: Entity): boolean &#123; // @ts-ignore return this.mask.or(entity.mask); &#125; getKey(): string &#123; return &quot;anyOf:&quot; + this.toString(); &#125;&#125;/** * 用于描述包含了“这些”组件的实体，这个实体除了包含这些组件还可以包含其他组件 */export class AllOf extends BaseOf &#123; public isMatch(entity: Entity): boolean &#123; // @ts-ignore return this.mask.and(entity.mask); &#125; getKey(): string &#123; return &quot;allOf:&quot; + this.toString(); &#125;&#125;/** * 不包含指定的任意一个组件 */export class ExcludeOf extends BaseOf &#123; public getKey(): string &#123; return &quot;excludeOf:&quot; + this.toString(); &#125; public isMatch(entity: Entity): boolean &#123; // @ts-ignore return !this.mask.or(entity.mask); &#125;&#125; 然后我们定义匹配器，匹配器可以包含复数规则，即匹配器是规则的集合，是所有匹配的实际执行类。匹配器也需要一个全局唯一的 id，给后面的 Group 使用。 IMatcher12345678import Entity from &quot;../Entity&quot;;export interface IMatcher &#123; mid: number; indices: number[]; key: string; isMatch(entity: Entity): boolean;&#125; Matcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import ECSManager, &#123; CompTypeUnion &#125; from &quot;./ECSManager&quot;;import Entity from &quot;./Entity&quot;;import &#123; AllOf, AnyOf, BaseOf, ExcludeOf &#125; from &quot;./FilterRule&quot;;import IComp from &quot;./Interface/IComp&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;/** * 筛选规则间是“与”的关系 * 比如：ecs.Macher.allOf(...).excludeOf(...)表达的是allOf &amp;&amp; excludeOf，即实体有“这些组件” 并且 “没有这些组件” */export class Matcher implements IMatcher &#123; protected rules: BaseOf[] = []; protected _indices: number[] | null = null; public mid: number = -1; private _key: string | null = null; public get key(): string &#123; if (!this._key) &#123; let s = &quot;&quot;; for (let i = 0; i &lt; this.rules.length; i++) &#123; s += this.rules[i].getKey(); if (i &lt; this.rules.length - 1) &#123; s += &quot; &amp;&amp; &quot;; &#125; &#125; this._key = s; &#125; return this._key; &#125; constructor() &#123; this.mid = ECSManager.getInst().getMatherId(); &#125; /** * 匹配器关注的组件索引。在创建Group时，Context根据组件id去给Group关联组件的添加和移除事件。 */ public get indices() &#123; if (this._indices === null) &#123; this._indices = []; //合并数组 this.rules.forEach((rule) =&gt; &#123; Array.prototype.push.apply(this._indices, rule.indices); &#125;); &#125; return this._indices; &#125; /** * 组件间是或的关系，表示关注拥有任意一个这些组件的实体。 * @param args 组件索引 */ public anyOf(...args: CompTypeUnion&lt;IComp&gt;[]): Matcher &#123; this.rules.push(new AnyOf(...args)); return this; &#125; /** * 组件间是与的关系，表示关注拥有所有这些组件的实体。 * @param args 组件索引 */ public allOf(...args: CompTypeUnion&lt;IComp&gt;[]): Matcher &#123; this.rules.push(new AllOf(...args)); return this; &#125; /** * 表示关注只拥有这些组件的实体 * * 注意： * 不是特殊情况不建议使用onlyOf。因为onlyOf会监听所有组件的添加和删除事件。 * @param args 组件索引 */ public onlyOf(...args: CompTypeUnion&lt;IComp&gt;[]): Matcher &#123; this.rules.push(new AllOf(...args)); let otherTids: CompTypeUnion&lt;IComp&gt;[] = []; for (let comp of ECSManager.getInst().getComps()) &#123; if (args.indexOf(comp) &lt; 0) &#123; otherTids.push(comp); &#125; &#125; this.rules.push(new ExcludeOf(...otherTids)); return this; &#125; /** * 不包含指定的任意一个组件 * @param args */ public excludeOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; this.rules.push(new ExcludeOf(...args)); return this; &#125; public isMatch(entity: Entity): boolean &#123; for (let rule of this.rules) &#123; if (!rule.isMatch(entity)) &#123; return false; &#125; &#125; return true; &#125; public clone(): Matcher &#123; let newMatcher = new Matcher(); newMatcher.mid = ECSManager.getInst().getMatherId(); this.rules.forEach((rule) =&gt; newMatcher.rules.push(rule)); return newMatcher; &#125;&#125; 大致的关系如下图所示 实体类现在我们可以实现实体类了。 大概的思路如图所示 首先是组件的增加。 我们设置一个 Map（下文都叫字典）_compInEntity 来保存当前实体的组件，设置一个字典 _compRemoved 用来保存已经移除但没有回收的组件。 添加组件的时候先判断是组件还是标签。 标签的情况，判断标签是否已经注册，已注册的情况下把标签添加到实体掩码，并且添加到已保存的组件字典中即可。 组件的情况，判断组件是否已注册，已注册并且已存在的情况下判断是否需要重新添加，需要的话就移除当前的组件，然后把组件添加到实体掩码，并且添加到已保存的组件字典中。 添加完成之后，我们还需要广播增删事件给系统。 然后是组件的移除。 组件的移除和添加类似，也需要分为标签和组件两个部分。 标签的情况，判断标签是否存在，是的话标记存在，到最后统一处理。 组件的情况，判断组件是否存在，是的话标记存在，取出当前组件的实例，设置实例的实体为 null，判断是否需要回收，需要回收的话执行组件初始化操作并回收，不需要的话就把组件放到移除列表中。 最后我们执行掩码的移除和组件存在列表的移除，并且广播通知系统执行对应操作。 在组件的添加和移除中，我们都可以设置实体类的对应名称属性为组件实例，以便更方便地访问组件。 接着是组件的查找。 组件的查找很简单，可以用掩码也可以用字典，根据自己的需要即可。组件的获取同理，可以用字典也可以用属性，自己决定即可。 最后是实体的移除。 实体移除的时候要移除所有组件，包括存在的和移除的列表。然后实体可以放入对象池。 Entity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import ECSManager, &#123; CompTypeUnion &#125; from &quot;./ECSManager&quot;;import &#123; CompType &#125; from &quot;./Interface/CompType&quot;;import IComp from &quot;./Interface/IComp&quot;;import Mask from &quot;./Mask&quot;;export default class Entity &#123; public eid: number = -1; private mask = new Mask(); /** * 当前实体上的组件 */ private _compInEntity: Map&lt;number, CompTypeUnion&lt;IComp&gt;&gt; = new Map(); /** * 保存在实体上的已移除的组件 */ private _compRemoved: Map&lt;number, CompTypeUnion&lt;IComp&gt;&gt; = new Map(); constructor() &#123;&#125; /** * 添加组件 * @param comp * @param isReAdded * @returns */ public add&lt;T extends IComp&gt;( comp: CompTypeUnion&lt;T&gt;, isReAdded = false ): T | null &#123; let compId; if (typeof comp == &quot;number&quot;) &#123; compId = comp; if (ECSManager.getInst().hasTag(comp)) &#123; this.mask.set(comp); this._compInEntity.set(comp, comp); let tagName = ECSManager.getInst().getTag(comp)!; // @ts-ignore this[tagName] = comp; ECSManager.getInst().broadcastCompAddOrRemove(this, comp); &#125; else &#123; console.error(&quot;不存在的tag！&quot;); &#125; return null; &#125; else &#123; compId = comp.tid; if (compId == -1) &#123; console.error(&quot;组件未注册&quot;); return null; &#125; if (this._compInEntity.has(compId)) &#123; if (isReAdded) &#123; this.remove(comp); &#125; else &#123; console.log(&quot;组件&quot; + comp.compName + &quot;已存在&quot;); return this[comp.compName]; &#125; &#125; this.mask.set(compId); let compInstance: T; if (this._compRemoved.has(compId)) &#123; compInstance = this._compRemoved.get(compId) as unknown as T; this._compRemoved.delete(compId); &#125; else &#123; compInstance = ECSManager.getInst().createComp(comp); &#125; this[comp.compName] = compInstance; this._compInEntity.set(compId, comp); compInstance.entity = this; //TODO 广播添加组件消息 ECSManager.getInst().broadcastCompAddOrRemove(this, compId); return compInstance as T; &#125; &#125; /** * 添加组件 * @param comps * @returns */ public addComps(reAdded = false, ...comps) &#123; for (let comp of comps) &#123; this.add(comp, reAdded); &#125; return this; &#125; /** * 获得组件 * @param comp * @returns */ public get&lt;T&gt;(comp: CompTypeUnion&lt;T&gt;) &#123; let compName; if (typeof comp == &quot;number&quot;) &#123; compName = ECSManager.getInst().getTag(comp); &#125; else &#123; compName = comp.compName; &#125; return this[compName] as T; &#125; /** * 判断组件是否存在 * @param comp * @returns */ public has&lt;T&gt;(comp: CompTypeUnion&lt;T&gt;) &#123; if (typeof comp == &quot;number&quot;) &#123; return this.mask.has(comp); &#125; else &#123; return this._compInEntity.has(comp.tid); &#125; &#125; private _remove(comp: CompTypeUnion&lt;IComp&gt;) &#123; //TODO git上为false 此处测试true this.remove(comp, true); &#125; /** * 移除组件 * @param comp 组件 * @param isRecycle 是否回收 */ public remove(comp: CompTypeUnion&lt;IComp&gt;, isRecycle: boolean = true) &#123; let compName: string; let id = -1; let hasComp = false; if (typeof comp == &quot;number&quot;) &#123; id = comp; if (this.mask.has(id)) &#123; hasComp = true; compName = ECSManager.getInst().getTag(id); &#125; else &#123; console.warn(&quot;试图移除不存在的tag&quot;); return; &#125; &#125; else &#123; id = comp.tid; compName = comp.compName; if (this.mask.has(id)) &#123; hasComp = true; let compInstance = this[compName] as CompType&lt;IComp&gt;; compInstance.entity = null; if (isRecycle) &#123; compInstance.reset(); if (compInstance.canRecycle) &#123; ECSManager.getInst().recycle(id, compInstance); &#125; &#125; else &#123; this._compRemoved.set(id, compInstance); &#125; &#125; else &#123; console.warn(&quot;试图移除不存在的组件&quot;, compName); &#125; &#125; if (hasComp) &#123; this[compName] = null; this.mask.delete(id); this._compInEntity.delete(id); ECSManager.getInst().broadcastCompAddOrRemove(this, id); // console.log(&quot;广播移除组件&quot;, compName); &#125; &#125; /** * 移除组件 * @param isRecycle * @param args */ public removeComps(isRecycle = true, ...args: CompTypeUnion&lt;IComp&gt;[]) &#123; for (let c of args) &#123; this.remove(c, isRecycle); &#125; &#125; /** * 移除实体 */ public removeSelf() &#123; this._compInEntity.forEach(this._remove, this); this._compRemoved.forEach(this._remove, this); ECSManager.getInst().removeEntity(this.eid, this); &#125;&#125; 系统系统根据所需要的组件来筛选实体，有时候不同系统需要的组件相同，因此我们使用组 Group 来管理系统。 系统的结构如下图所示 群组群组包含一个匹配器，如前文所说，匹配器的 id 也是群组的 id。群组只关心组件匹配的实体，操作的对象也都是实体。 我们保存一个匹配实体字典，以实体 id 为 key，以及一个缓存实体数组。缓存实体数组是系统运行时遍历的，每次组件广播后删除，下次重新缓存。 另外，我们保存一个进入实体列表和一个移除实体列表，这两个列表保存的是系统中对应列表的引用，在群组里专门负责监控组件变化时实体的进入和移除情况。 Group12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import Entity from &quot;./Entity&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;export default class Group&lt;E extends Entity = Entity&gt; &#123; /** * 实体筛选规则 */ private matcher: IMatcher; private _matchEntities: Map&lt;number, E&gt; = new Map(); private _entitiesCache: E[] | null = null; /** * 符合规则的实体 */ public get matchEntities() &#123; if (this._entitiesCache === null) &#123; this._entitiesCache = Array.from(this._matchEntities.values()); &#125; return this._entitiesCache; &#125; /** * 当前group中实体的数量。 * * 不要手动修改这个属性值。 */ public count = 0; // 其实可以通过this._matchEntities.size获得实体数量，但是需要封装get方法。为了减少一次方法的调用所以才直接创建一个count属性 /** * 获取matchEntities中第一个实体 */ get entity(): E &#123; return this.matchEntities[0]; &#125; private _enteredEntities: Map&lt;number, E&gt; | null = null; private _removedEntities: Map&lt;number, E&gt; | null = null; constructor(matcher: IMatcher) &#123; this.matcher = matcher; &#125; /** * 组件变化监听 * @param entity 实体 */ public onComponentAddOrRemove(entity: E) &#123; if (this.matcher.isMatch(entity)) &#123; // Group只关心指定组件在实体身上的添加和删除动作。 this._matchEntities.set(entity.eid, entity); this._entitiesCache = null; this.count++; if (this._enteredEntities) &#123; this._enteredEntities.set(entity.eid, entity); &#125; if (this._removedEntities) &#123; this._removedEntities.delete(entity.eid); &#125; &#125; else if (this._matchEntities.has(entity.eid)) &#123; // 如果Group中有这个实体，但是这个实体已经不满足匹配规则，则从Group中移除该实体 this._matchEntities.delete(entity.eid); this._entitiesCache = null; this.count--; if (this._enteredEntities) &#123; this._enteredEntities.delete(entity.eid); &#125; if (this._removedEntities) &#123; this._removedEntities.set(entity.eid, entity); &#125; &#125; &#125; /** * 监控进入/移除数组 * @param enteredEntities * @param removedEntities */ public watchEntityEnterAndRemove( enteredEntities: Map&lt;number, E&gt;, removedEntities: Map&lt;number, E&gt; ) &#123; this._enteredEntities = enteredEntities; this._removedEntities = removedEntities; &#125; clear() &#123; this._matchEntities.clear(); this._entitiesCache = null; this.count = 0; this._enteredEntities?.clear(); this._removedEntities?.clear(); &#125;&#125; 系统实现系统实现分为两个部分，一个部分是系统的具体实现，还有一个部分是根系统。 系统的具体实现核心目标是实现实体进入时的逻辑处理，每帧逻辑处理和实体移除时的逻辑处理。因此我们定义如下接口 ISystem12345678910111213141516171819202122232425import Entity from &quot;../Entity&quot;;/** * 如果需要监听实体首次进入System的情况，实现这个接口。 * * entityEnter会在update方法之前执行，实体进入后，不会再次进入entityEnter方法中。 * 当实体从当前System移除，下次再次符合条件进入System也会执行上述流程。 */export interface IEntityEnterSystem&lt;E extends Entity = Entity&gt; &#123; entityEnter(entities: E[]): void;&#125;/** * 如果需要监听实体从当前System移除，需要实现这个接口。 */export interface IEntityRemoveSystem&lt;E extends Entity = Entity&gt; &#123; entityRemove(entities: E[]): void;&#125;/** * 第一次执行update */export interface ISystemFirstUpdate&lt;E extends Entity = Entity&gt; &#123; firstUpdate(entities: E[]): void;&#125; 我们在系统实现类的构造函数中判断是否有我们需要实现的方法，分为以下两种情况： 有首次进入&#x2F;移除的逻辑函数execute1。这时候我们要初始化实体进入&#x2F;移除的数组，并且在组里监听这两个数组的实体变化。之后设置执行函数为execute1。 没有上述逻辑，直接设置执行函数为每帧更新的逻辑函数execute0。 如果有第一次执行 update 的函数updateOnce的话，就保存当前设置的执行函数，并且设执行函数为updateOnce。 在execute1、execute0、updateOnce执行之后，我们都要置实体进入&#x2F;移除的数组为空，防止下次执行时重复对已执行实体再次执行对应逻辑。 如果还有其他需求，也可以自行定义对应的接口和具体的处理逻辑。 ComblockSystem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import ECSManager from &quot;./ECSManager&quot;;import Entity from &quot;./Entity&quot;;import Group from &quot;./Group&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;import &#123; IEntityEnterSystem, ISystemFirstUpdate, IEntityRemoveSystem,&#125; from &quot;./Interface/ISystem&quot;;export abstract class ComblockSystem&lt;E extends Entity = Entity&gt; &#123; protected _group: Group&lt;E&gt;; protected _dt: number = 0; private _enteredEntities: Map&lt;number, E&gt; | null = null; private _removedEntities: Map&lt;number, E&gt; | null = null; private _hasEntityEnter: boolean = false; private _hasEntityRemove: boolean = false; private _tmpExecute: ((dt: number) =&gt; void) | null = null; private execute!: (dt: number) =&gt; void; constructor() &#123; let hasOwnProperty = Object.hasOwnProperty; let prototype = Object.getPrototypeOf(this); let hasEntityEnter = hasOwnProperty.call(prototype, &quot;entityEnter&quot;); let hasEntityRemove = hasOwnProperty.call(prototype, &quot;entityRemove&quot;); let hasFirstUpdate = hasOwnProperty.call(prototype, &quot;firstUpdate&quot;); this._hasEntityEnter = hasEntityEnter; this._hasEntityRemove = hasEntityRemove; if (hasEntityEnter || hasEntityRemove) &#123; this._enteredEntities = new Map&lt;number, E&gt;(); this._removedEntities = new Map&lt;number, E&gt;(); this.execute = this.execute1; this._group = ECSManager.getInst().createGroup(this.filter()); this._group.watchEntityEnterAndRemove( this._enteredEntities, this._removedEntities ); &#125; else &#123; this.execute = this.execute0; this._group = ECSManager.getInst().createGroup(this.filter()); &#125; if (hasFirstUpdate) &#123; this._tmpExecute = this.execute; this.execute = this.updateOnce; &#125; &#125; init(): void &#123;&#125; onDestroy(): void &#123;&#125; hasEntity(): boolean &#123; return this._group.count &gt; 0; &#125; private updateOnce(dt: number) &#123; if (this._group.count === 0) &#123; return; &#125; this._dt = dt; // 处理刚进来的实体 if (this._enteredEntities &amp;&amp; this._enteredEntities.size &gt; 0) &#123; (this as unknown as IEntityEnterSystem).entityEnter( Array.from(this._enteredEntities.values()) as E[] ); this._enteredEntities.clear(); &#125; (this as unknown as ISystemFirstUpdate).firstUpdate( this._group.matchEntities ); this.execute = this._tmpExecute!; this.execute(dt); this._tmpExecute = null; &#125; /** * 只执行update * @param dt * @returns */ private execute0(dt: number): void &#123; if (this._group.count === 0) &#123; return; &#125; this._dt = dt; this.update(this._group.matchEntities); &#125; /** * 先执行entityRemove，再执行entityEnter，最后执行update。 * @param dt * @returns */ private execute1(dt: number): void &#123; if (this._removedEntities &amp;&amp; this._removedEntities.size &gt; 0) &#123; if (this._hasEntityRemove) &#123; (this as unknown as IEntityRemoveSystem).entityRemove( Array.from(this._removedEntities.values()) as E[] ); &#125; this._removedEntities.clear(); &#125; if (this._group.count === 0) &#123; return; &#125; this._dt = dt; // 处理刚进来的实体 if (this._enteredEntities &amp;&amp; this._enteredEntities.size &gt; 0) &#123; if (this._hasEntityEnter) &#123; (this as unknown as IEntityEnterSystem).entityEnter( Array.from(this._enteredEntities.values()) as E[] ); &#125; this._enteredEntities.clear(); &#125; this.update(this._group.matchEntities as E[]); &#125; /** * 实体过滤规则 * * 根据提供的组件过滤实体。 */ abstract filter(): IMatcher; abstract update(entities: E[]): void;&#125; 当然，同类型的系统我们也可以用系统组合器来组合使用。 System123456789101112131415161718192021222324import &#123; ComblockSystem &#125; from &quot;./ComBlockSystem&quot;;/** * 系统组合器，用于将多个相同功能模块的系统逻辑上放在一起。System也可以嵌套System。 */export class System &#123; private _comblockSystems: ComblockSystem[] = []; get comblockSystems() &#123; return this._comblockSystems; &#125; add(system: System | ComblockSystem) &#123; if (system instanceof System) &#123; Array.prototype.push.apply( this._comblockSystems, system._comblockSystems ); system._comblockSystems.length = 0; &#125; else &#123; this._comblockSystems.push(system as ComblockSystem); &#125; return this; &#125;&#125; 所有的系统实现，最后我们都要用根系统来使用。 根系统生命周期提供一个 init 方法，来遍历所有系统并且调用对应系统的初始化；提供一个 execute 方法来遍历所有系统，执行每帧更新的内容；提供一个 clear 方法来遍历所有系统，调用系统销毁时的 onDestroy 方法。 然后就是 add 方法，传入系统组合器时我们会平铺其的所有系统并加入数组；传入系统时直接加入数组。 所有的方法在我们自定义根系统的时候都不需要修改，只需要在构造函数中 add 新的系统即可。 RootSystem1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; ComblockSystem &#125; from &quot;./ComBlockSystem&quot;;import &#123; System &#125; from &quot;./System&quot;;/** * System的root，对游戏中的System遍历从这里开始。 * * 一个System组合中只能有一个RootSystem，可以有多个并行的RootSystem。 */export class RootSystem &#123; private executeSystemFlows: ComblockSystem[] = []; private systemCnt: number = 0; add(system: System | ComblockSystem) &#123; if (system instanceof System) &#123; // 将嵌套的System都“摊平”，放在根System中进行遍历，减少execute的频繁进入退出。 Array.prototype.push.apply( this.executeSystemFlows, system.comblockSystems ); &#125; else &#123; this.executeSystemFlows.push(system as ComblockSystem); &#125; this.systemCnt = this.executeSystemFlows.length; return this; &#125; init() &#123; this.executeSystemFlows.forEach((sys) =&gt; sys.init()); &#125; execute(dt: number) &#123; for (let i = 0; i &lt; this.systemCnt; i++) &#123; // @ts-ignore this.executeSystemFlows[i].execute(dt); &#125; &#125; clear() &#123; this.executeSystemFlows.forEach((sys) =&gt; sys.onDestroy()); &#125;&#125; 管理器ECS 的基本框架搭建好后，我们还需要一个管理器来管理 ECS 框架的一些操作。下面是本项目的分类，也可以根据需求自己设计。 ECS 管理器的核心功能简单概括如下图所示 组件注册我们在使用组件之前，都要对组件进行注册。由上文我们知道组件有两种，一种是组件，一种是标签，因此注册也是分两种情况进行。 首先我们定义组件 id_compTid来记录组件 id，定义注册池_registerPool来判断是否存在同名组件或标签，定义组件池_comps保存组件类，定义组件缓存池_compPools来保存组件对象，定义 tag 池_tags来保存标签名，定义组件变化池_compAddOrRemove来保存变化的组件。 组件的注册用装饰器进行，我们定义两个类装饰器函数。 注册组件：传入一个组件名，还有一个可选变量 canNew 表示是否可以实例化，一般我们默认 true，然后我们判断注册的组件是否重复，没重复的话给当前组件命名，组件 id 赋值后自增，可以实例化组件的话就把组件存入组件池，并开辟一个当前组件的缓存池数组以及组件变化池数组。最后在注册池里标记为已注册。 注册组件12345678910111213141516171819202122232425262728293031/** * 注册组件 * @param compName * @param canNew * @returns */public register&lt;T&gt;(compName: string, canNew: boolean = true) &#123; return function (comp: CompType&lt;T&gt;) &#123; if (comp.tid == -1) &#123; let manager = ECSManager.getInst(); if (manager._registerPool[compName]) &#123; console.warn(&quot;组件与标签重名:&quot;, compName); &#125; else &#123; comp.tid = manager._compTid++; comp.compName = compName; if (canNew) &#123; manager._comps.push(comp); manager._compPools.set(comp.tid, []); &#125; else &#123; manager._comps.push(null); &#125; manager._compAddOrRemove.set(comp.tid, []); console.log(&quot;组件&quot; + compName + &quot;注册成功:&quot;, comp.tid) manager._registerPool[compName] = true; &#125; &#125; else &#123; console.log(&quot;组件已注册&quot;); &#125; &#125;&#125; 注册标签：注册标签我们不传入任何参数，我们只需要遍历标签类的所有属性，判断是否已注册，未注册的情况我们给标签 id 赋值并自增，然后和组件一样放入组件池并开辟组件缓存池。标签要额外放到标签池以方便标签的操作。最后也要在注册池里标注为已注册。 注册tag123456789101112131415161718192021222324/** * 注册tag * @returns */public registerTag() &#123; return function (_class: any) &#123; let manager = ECSManager.getInst(); let tid = manager._compTid; for (let k in _class) &#123; if (manager._registerPool[k]) &#123; console.warn(&quot;标签与组件重名:&quot;, k); &#125; else &#123; tid = manager._compTid++; _class[k] = tid; manager._comps.push(tid); manager._compPools.set(tid, []); manager._compAddOrRemove.set(tid, []); manager._tags.set(tid, k); console.log(&quot;标签&quot; + k + &quot;注册成功:&quot;, tid) manager._registerPool[k] = true; &#125; &#125; &#125;&#125; 组件功能组件的功能很简单，只是运用了对象池的概念。 组件功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//-----tag-----/** * 是否有tag * @param id * @returns */public hasTag(id: number) &#123; return this._tags.has(id);&#125;/** * 获得tag * @param id * @returns */public getTag(id: number): string &#123; return this._tags.get(id) as string;&#125;//-----tag-----//-----组件-----/** * 回收组件 * @param id 组件id * @param comp 组件实例 */public recycle(id: number, comp: IComp) &#123; this._compPools.get(id)?.push(comp);&#125;/** * 创建组件 * @param comp * @returns */public createComp&lt;T&gt;(comp: CompType&lt;T&gt;) &#123; if (!this._comps[comp.tid]) &#123; console.error(&quot;未找到组件&quot; + comp.compName) &#125; let compInstance = this._compPools.get(comp.tid)?.pop() || new this._comps[comp.tid]; return compInstance;&#125;/** * 获得所有组件 * @returns */public getComps() &#123; return this._comps;&#125;//-----组件----- 实体功能实体的功能也很简单，我们定义一个实体池_eid2Entity用于保存当前所有的实体实例，定义一个实体缓存池_eneityPool用来当实体的对象池。 实体功能1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 创建实体 * @returns */public createEntity&lt;E extends Entity = Entity&gt;(): E &#123; let entity = this._eneityPool.pop(); if (!entity) &#123; entity = new Entity(); entity.eid = this._entityId++; &#125; this._eid2Entity.set(entity.eid, entity); return entity as E;&#125;/** * 移除实体 * @param id 实体id * @param entity 实体 */public removeEntity(id: number, entity: Entity) &#123; if (this._eid2Entity.has(id)) &#123; this._eneityPool.push(entity); this._eid2Entity.delete(id); &#125; else &#123; console.warn(&quot;试图销毁不存在的实体&quot;); &#125;&#125;/** * 根据eid获取实体 * @param eid * @returns */public getEntityByEid(eid: number) &#123; return this._eid2Entity.get(eid);&#125;/** * 获得当前活动实体数量 * @returns */public activeEntityCount() &#123; return this._eid2Entity.size;&#125; 系统功能系统功能包括群组功能，过滤功能和组件变化的通知及清除功能。 组件变化的监听是在创建群组的时候就绑定好的。通过获取对应组件 id 的组件变化数组，存入群组的监听函数，就可以在每次组件变化的时候通知所有监听该组件的群组执行对应的函数。 其他功能就是对上文现有功能的再包装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//-----群组-----/** * 创建群组 * @param matcher */public createGroup&lt;E extends Entity = Entity&gt;(matcher: IMatcher): Group&lt;E&gt; &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = new Group(matcher); this._groups.set(matcher.mid, group); let careCompIds = matcher.indices; for (let i = 0, len = careCompIds.length; i &lt; len; i++) &#123; let child = this._compAddOrRemove.get(careCompIds[i]); if (!child) &#123; child = []; this._compAddOrRemove.set(careCompIds[i], child); &#125; child.push(group.onComponentAddOrRemove.bind(group)); &#125; &#125; return group as unknown as Group&lt;E&gt;;&#125;public query(matcher: IMatcher) &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = this.createGroup(matcher); this._eid2Entity.forEach(group.onComponentAddOrRemove, group); &#125; return group.matchEntities;&#125;//-----群组-----/*** 实体身上组件有增删操作，广播通知对应的观察者。* @param entity 实体对象* @param componentTypeId 组件类型id*/public broadcastCompAddOrRemove(entity: Entity, componentTypeId: number) &#123; let events = this._compAddOrRemove.get(componentTypeId); if (events) &#123; for (let i = events.length - 1; i &gt;= 0; i--) &#123; events![i](entity); &#125; &#125;&#125;/*** 清除*/public clear() &#123; this._eid2Entity.forEach((entity) =&gt; &#123; entity.removeSelf(); &#125;); this._groups.forEach((group) =&gt; &#123; group.clear(); &#125;); this._compAddOrRemove.forEach(callbackLst =&gt; &#123; callbackLst.length = 0; &#125;); this._eid2Entity.clear(); this._groups.clear();&#125;//-----过滤-----public getMatherId() &#123; return this._matcherId++;&#125;/** * 判断是否拥有所有对应组件 * @param args * @returns */public allOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().allOf(...args);&#125;/** * 判断是否拥有任意对应组件 * @param args * @returns */public anyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().anyOf(...args);&#125;/** * 判断是否只包含所有对应组件 * @param args * @returns */public onlyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().onlyOf(...args);&#125;/** * 判断是否不包含任意对应组件 * @param args * @returns */public excludeOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().excludeOf();&#125;//-----过滤----- 总的 ECS 管理类代码如下 ECSManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337import &#123; Comp &#125; from &quot;./Comp&quot;;import Entity from &quot;./Entity&quot;;import Group from &quot;./Group&quot;;import &#123; CompType &#125; from &quot;./Interface/CompType&quot;;import IComp from &quot;./Interface/IComp&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;import &#123; Matcher &#125; from &quot;./Mathcer&quot;;export type CompAddOrRemove = (entity: Entity) =&gt; void;export type CompTypeUnion&lt;T&gt; = CompType&lt;T&gt; | number;export default class ECSManager &#123; private static _instance: ECSManager | null = null; private _compTid = 0; private _entityId = 1; private _matcherId = 1; /** * 注册池，判断是否存在同名组件或标签 */ private _registerPool = &#123;&#125;; /** * 组件注册池 */ private _comps: any[] = []; /** * 组件缓存池 */ private _compPools: Map&lt;number, Comp[]&gt; = new Map(); /** * tag池 */ private _tags: Map&lt;number, string&gt; = new Map(); private _compAddOrRemove: Map&lt;number, CompAddOrRemove[]&gt; = new Map(); /** * 实体池 */ private _eid2Entity: Map&lt;number, Entity&gt; = new Map(); /** * 实体缓存池 */ private _eneityPool: Entity[] = []; private _groups: Map&lt;number, Group&gt; = new Map(); public static getInst(): ECSManager &#123; if (!this._instance) &#123; this._instance = new ECSManager(); &#125; return this._instance; &#125; public getCompTid() &#123; return this._compTid; &#125; //-----注册----- /** * 注册组件 * @param compName * @param canNew * @returns */ public register&lt;T&gt;(compName: string, canNew: boolean = true) &#123; return function (comp: CompType&lt;T&gt;) &#123; if (comp.tid == -1) &#123; let manager = ECSManager.getInst(); if (manager._registerPool[compName]) &#123; console.warn(&quot;组件与标签重名:&quot;, compName); &#125; else &#123; comp.tid = manager._compTid++; comp.compName = compName; if (canNew) &#123; manager._comps.push(comp); manager._compPools.set(comp.tid, []); &#125; else &#123; manager._comps.push(null); &#125; manager._compAddOrRemove.set(comp.tid, []); console.log(&quot;组件&quot; + compName + &quot;注册成功:&quot;, comp.tid); manager._registerPool[compName] = true; &#125; &#125; else &#123; console.log(&quot;组件已注册&quot;); &#125; &#125;; &#125; /** * 注册tag * @returns */ public registerTag() &#123; return function (_class: any) &#123; let manager = ECSManager.getInst(); let tid = manager._compTid; for (let k in _class) &#123; if (manager._registerPool[k]) &#123; console.warn(&quot;标签与组件重名:&quot;, k); &#125; else &#123; tid = manager._compTid++; _class[k] = tid; manager._comps.push(tid); manager._compPools.set(tid, []); manager._compAddOrRemove.set(tid, []); manager._tags.set(tid, k); console.log(&quot;标签&quot; + k + &quot;注册成功:&quot;, tid); manager._registerPool[k] = true; &#125; &#125; &#125;; &#125; //-----注册----- //-----tag----- /** * 是否有tag * @param id * @returns */ public hasTag(id: number) &#123; return this._tags.has(id); &#125; /** * 获得tag * @param id * @returns */ public getTag(id: number): string &#123; return this._tags.get(id) as string; &#125; //-----tag----- //-----组件----- /** * 回收组件 * @param id 组件id * @param comp 组件实例 */ public recycle(id: number, comp: IComp) &#123; this._compPools.get(id)?.push(comp); &#125; /** * 创建组件 * @param comp * @returns */ public createComp&lt;T&gt;(comp: CompType&lt;T&gt;) &#123; if (!this._comps[comp.tid]) &#123; console.error(&quot;未找到组件&quot; + comp.compName); &#125; let compInstance = this._compPools.get(comp.tid)?.pop() || new this._comps[comp.tid](); return compInstance; &#125; /** * 获得所有组件 * @returns */ public getComps() &#123; return this._comps; &#125; /** * 实体身上组件有增删操作，广播通知对应的观察者。 * @param entity 实体对象 * @param componentTypeId 组件类型id */ public broadcastCompAddOrRemove(entity: Entity, componentTypeId: number) &#123; let events = this._compAddOrRemove.get(componentTypeId); if (events) &#123; for (let i = events.length - 1; i &gt;= 0; i--) &#123; events![i](entity); &#125; &#125; &#125; //-----组件----- //-----实体----- /** * 创建实体 * @returns */ public createEntity&lt;E extends Entity = Entity&gt;(): E &#123; let entity = this._eneityPool.pop(); if (!entity) &#123; entity = new Entity(); entity.eid = this._entityId++; &#125; this._eid2Entity.set(entity.eid, entity); return entity as E; &#125; /** * 移除实体 * @param id 实体id * @param entity 实体 */ public removeEntity(id: number, entity: Entity) &#123; if (this._eid2Entity.has(id)) &#123; this._eneityPool.push(entity); this._eid2Entity.delete(id); &#125; else &#123; console.warn(&quot;试图销毁不存在的实体&quot;); &#125; &#125; /** * 根据eid获取实体 * @param eid * @returns */ public getEntityByEid(eid: number) &#123; return this._eid2Entity.get(eid); &#125; /** * 获得当前活动实体数量 * @returns */ public activeEntityCount() &#123; return this._eid2Entity.size; &#125; /** * 清除 */ public clear() &#123; this._eid2Entity.forEach((entity) =&gt; &#123; entity.removeSelf(); &#125;); this._groups.forEach((group) =&gt; &#123; group.clear(); &#125;); this._compAddOrRemove.forEach((callbackLst) =&gt; &#123; callbackLst.length = 0; &#125;); this._eid2Entity.clear(); this._groups.clear(); &#125; //-----实体----- //-----群组----- /** * 创建群组 * @param matcher */ public createGroup&lt;E extends Entity = Entity&gt;(matcher: IMatcher): Group&lt;E&gt; &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = new Group(matcher); this._groups.set(matcher.mid, group); let careCompIds = matcher.indices; for (let i = 0, len = careCompIds.length; i &lt; len; i++) &#123; let child = this._compAddOrRemove.get(careCompIds[i]); if (!child) &#123; child = []; this._compAddOrRemove.set(careCompIds[i], child); &#125; child.push(group.onComponentAddOrRemove.bind(group)); &#125; &#125; return group as unknown as Group&lt;E&gt;; &#125; public query(matcher: IMatcher) &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = this.createGroup(matcher); this._eid2Entity.forEach(group.onComponentAddOrRemove, group); &#125; return group.matchEntities; &#125; //-----群组----- //-----过滤----- public getMatherId() &#123; return this._matcherId++; &#125; /** * 判断是否拥有所有对应组件 * @param args * @returns */ public allOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().allOf(...args); &#125; /** * 判断是否拥有任意对应组件 * @param args * @returns */ public anyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().anyOf(...args); &#125; /** * 判断是否只包含所有对应组件 * @param args * @returns */ public onlyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().onlyOf(...args); &#125; /** * 判断是否不包含任意对应组件 * @param args * @returns */ public excludeOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().excludeOf(); &#125; //-----过滤-----&#125; 使用方法Tag示例1234567import ECSManager from &quot;../../../ECS/ECSManager&quot;;@ECSManager.getInst().registerTag()export default class StatusTags &#123; public static StatusA = 0; public static StatusB = 1;&#125; Comp示例123456789101112import &#123; Comp &#125; from &quot;../../../ECS/Comp&quot;;import ECSManager from &quot;../../../ECS/ECSManager&quot;;@ECSManager.getInst().register(&quot;Transform&quot;)export default class TransformComp extends Comp &#123; /** 坐标 */ public position: Laya.Vector3 = new Laya.Vector3(); reset(): void &#123; this.position.set(0, 0, 0); &#125;&#125; Entity示例123456import Entity from &quot;../../../ECS/Entity&quot;;import TransformComp from &quot;../Comp/TransformComp&quot;;export default class RoleEntity extends Entity &#123; public Transform: TransformComp;&#125; ComblockSystem示例123456789101112131415161718192021222324252627import &#123; ComblockSystem &#125; from &quot;../../../ECS/ComBlockSystem&quot;;import ECSManager from &quot;../../../ECS/ECSManager&quot;;import &#123; IMatcher &#125; from &quot;../../../ECS/Interface/IMatcher&quot;;import &#123; IEntityEnterSystem &#125; from &quot;../../../ECS/Interface/ISystem&quot;;import ServantComp from &quot;../Comp/ServantComp&quot;;import WorkerComp from &quot;../Comp/WorkerComp&quot;;import RoleEntity from &quot;../Entity/RoleEntity&quot;;/** * 工作系统 */export default class WorkSystem extends ComblockSystem&lt;RoleEntity&gt; implements IEntityEnterSystem&lt;RoleEntity&gt;&#123; entityEnter(entities: RoleEntity[]): void &#123; for (let e of entities) &#123; &#125; &#125; filter(): IMatcher &#123; return ECSManager.getInst().anyOf(WorkerComp, ServantComp); &#125; update(entities: RoleEntity[]): void &#123; for (let e of entities) &#123; &#125; &#125;&#125; RootSystem示例1234567891011121314151617181920import Globals from &quot;../../../Config/Globals&quot;;import &#123; RootSystem &#125; from &quot;../../../ECS/RootSystem&quot;;import CarShopSystem from &quot;../System/CarShopSystem&quot;;import CarSystem from &quot;../System/CarSystem&quot;;import CustomSystem from &quot;../System/CustomSystem&quot;;import DollSystem from &quot;../System/DollSystem&quot;;import MoveSystem from &quot;../System/MoveSystem&quot;;import NpcSystem from &quot;../System/NpcSystem&quot;;import PathFindingSystem from &quot;../System/PathFindingSystem&quot;;import WorkSystem from &quot;../System/WorkSystem&quot;;/** * 慢速根系统 */export default class RootSlowSystem extends RootSystem &#123; constructor() &#123; super(); this.add(new WorkSystem()); &#125;&#125; 根系统调用示例123456789101112onAwake()&#123; this._rootSlowSystem = new RootSlowSystem(); this._rootSlowSystem.init();&#125;onUpdate()&#123; this._rootSlowSystem.execute(Laya.timer.delta);&#125;onDisable() &#123; this._rootSlowSystem.clear();&#125; 代码由于本项目代码较多，因此请移步 GitHub 查看详细代码。","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ECS","slug":"ECS","permalink":"https://busyogg.github.io/tags/ECS/"}]},{"title":"Laya实现FixedUpdate","slug":"Laya实现FixedUpdate","date":"2023-09-13T10:14:10.000Z","updated":"2024-05-18T15:37:43.771Z","comments":true,"path":"article/f6c36db9b473/","link":"","permalink":"https://busyogg.github.io/article/f6c36db9b473/","excerpt":"","text":"简介有时候我们需要固定每秒固定次数更新的功能的时候，例如 Unity 的 FixedUpdate，Laya 本身不提供这样的方法，或许有人用定时器实现，但是定时器不易管理。本项目提供一种基于帧更新的定时更新方法以解决这个问题。 基本原理每帧更新的时候计算总更新时间，根据总更新时间除以间隔时间获得当前帧需要更新的次数，根据更新次数循环更新。以此我们可以实现和帧率不同的更新频率。 本例设置间隔时间为 50ms，即每秒运行 20 次。如果当前总帧间隔时间小于 50ms 的情况下，_fiexdTimes运行次数为 0，于是当前帧不运行onFixedUpdate，反之运行 n 次。 60fps 的情况下，每三帧间隔时间达到 50ms，运行一次onFixedUpdate。 30fps 的情况下，头 2 次每 2 帧间隔时间超过 50ms，运行 1 次，第 3 次开始由于之前保存的时间为 _savedTime = 32 * 2 - 50 + 32 * 2 -50 = 28 ,加上当前帧的 32ms 于是大于 50ms，运行一次。即前 7 帧为 2 帧 2 次后 1 帧 1 次。 10fps 的情况下，每帧间隔 100ms，因此每帧运行两次onFixedUpdate。 通过动态平衡每帧需要执行的次数，就能控制每秒执行的总次数不变。 运行的过程中可能会出现单帧运行时间Math.floor(this._fiexdTimes) * this._intervals实际小于间隔时间this._deltaTime的情况，因此增设一个_savedTime来保存未参与运算的时间，同时为了防止保存的时间和帧间隔时间过长（小游戏挂到后台，游戏暂停导致 deltaTime 过大）导致重复运行次数过多，因此在每帧参与运算之前都会对其进行上限判断。这部分可以根据需要自行删改。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** 累计时间 */private _deltaTime = 0;/** 上一fixed update 剩余时间 */private _savedTime = 0;/** fixed update 执行次数 */private _fiexdTimes = 0;/** 逻辑帧间隔时间 单位毫秒 50即每秒更新20次*/private _intervals = 50; /** * 固定更新 */private fixedUpdate() &#123; let mark = false; let curDelta = Laya.timer.delta; curDelta = curDelta &lt; this._intervals ? curDelta : this._intervals; //防止出现长时间放置导致的保存时间过长 if (this._savedTime &gt; this._intervals) &#123; this._savedTime = this._intervals; &#125; //累计间隔时间 this._deltaTime += curDelta + this._savedTime; //更新次数 this._fiexdTimes = this._deltaTime / this._intervals; for (let i = 1; i &lt; this._fiexdTimes; i++) &#123; this.onFixedUpdate(); mark = true; &#125; if (mark) &#123; this._savedTime = this._deltaTime - Math.floor(this._fiexdTimes) * this._intervals; this._deltaTime = 0; &#125; else &#123; this._savedTime = 0; &#125;&#125;/** * 固定更新运行内容 */onFixedUpdate() &#123;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"四叉树空间管理","slug":"四叉树空间管理","date":"2023-09-11T18:56:40.000Z","updated":"2024-05-18T15:38:17.225Z","comments":true,"path":"article/3357cf00d6c0/","link":"","permalink":"https://busyogg.github.io/article/3357cf00d6c0/","excerpt":"","text":"简介在游戏开发的过程中，我们要对空间进行管理，一个比较常用的方法就是用四叉树进行管理，采用的是分治的思路，把一个大的空间分为若干小空间进行管理。 原理四叉树的思路很简单，和二分查找类似 首先我们要定义一个范围，作为空间管理的基础。 然后把这个范围划分为四块。 所有操作都按照这个空间来进行，当前格子不满足条件的情况就向下拓展。 现在，我们要找到空间中的一个物体，我们就不需要从大的黑色的这个范围全部遍历物体，而是在红色分割线划分出来的小空间里面遍历该空间中存储的物体。 如图所示，下面就是一个最基础的四叉树分割。我们把一个大的空间分为了四个小的空间。 四叉树定义现在，我们遇到了第一个问题，要通过什么规则来决定是否需要划分空间呢？ 这里就要引入节点深度和节点容量的概念。 节点深度决定四叉树能够拓展到多深 节点容量决定非最深节点能存储对象的最大数量。 当非最深节点的节点容量未满的时候，节点不进行分割，所有的对象都存储在当前的节点；当容量满了之后，节点分割为更小的四块，并且节点中存储的对象通过查询比较包围盒大小，满足条件的存入新的节点中，不满足条件的则继续存放在该节点。 现在，我们往这个空间里放入一些对象。我们假设深度为 2，容量也为 2。那么就有如下图所示的情况。 image.png 橙色代表插入的对象，我们可以观察到，在红色分割线划分的右上角格子中，我们插入了 4 个对象。此时该节点深度为 1，对象为 4 超过了节点的最大容量，因此我们继续分割，分割出粉色线四个格子。右上粉色格子对象数量为 3，此时虽然超出了最大容量，但由于格子的深度为 2，已经达到最大深度，因此无法继续分割，所有的对象都存储在该节点。 四叉树的数据结构可以根据以上概念得出 QTree12345678/** 最大深度 */public _maxDepth = 0;/** 最大数量 */public _maxObjCount = 0;/** 包围盒 */public _bound = &#123;&#125;;/** 根节点 */public _root: Qnode; 此处有一个 QNode 为四叉树节点，四叉树节点的数据结构如下 QNode12345678910111213141516/** 包围盒 */public _bound: &#123; x, z, w, h, maxX, minX, maxZ, minZ &#125;;/** 宽松包围盒 */public _looseBound: any = &#123;&#125;;/** 父节点 */public _parent: Qnode;/** 所属四叉树 */public _belongTree: Qtree;/** 对象列表 */public _objList = [];/** 子节点字典 */public _childDic = &#123;&#125;;/** 深度 */public _depth: number;/** 对象数量 */public _objCount = 0; 四叉树节点数据结构中的宽松包围盒为松散四叉树所使用，接下来会介绍。对象存储在数组中，子节点可以存为数组，也可以存为字典，最终的结果都是一样存放下一深度的四个节点，可以按照自己的喜好调整。 四叉树操作开始之前，我们要解决一个问题，如何进行对象插入的条件判断？ 在讨论方法之前，我们要先思考一个问题，如果四叉树切线边缘存在物体的情况该如何解决？这里有两种方法，一种是存在父节点，一种是每一个压到的节点都存放一个该对象。 假设这个蓝色的对象插入的时候压到了粉色边线，用第一种方法的时候，我们查找右上角粉色格子内的对象的时候，查找的结果必定会包含蓝色对象，因为蓝色对象本身是属于红色格子的。用第二种方法的时候，左下角和右下角的粉色格子都有保存蓝色对象的信息，占用了两份数据，如果是在粉色十字正中间的时候，存储的数据要变成四份。 这个时候，我们要引入一个松散四叉树的概念。我们在上面的四叉树定义中也提到过松散四叉树，松散四叉树是指每一个分割的格子的包围盒并不一定要严格分割四分之一父节点空间。 如图所示，右下角这个绿色的空间，就是右下角格子的松散包围盒。每一个格子都有自己的松散包围盒。当松散包围盒的大小是格子大小的 2 倍的时候会产生一个特性，那就是插入对象的中心点只要在格子中，那他必定在这个格子的松散包围盒之内 。因此一般常用 2 倍大小的松散包围盒。 这个时候，对象压线的问题就得到了解决，只要判断对象的中心属于哪个格子即可。 如图所示，假如橙色部分是插入对象的大小，当他的大小为最大，即红色格子大小时，他的中心点在红色格子的左下角时，依然不会超出绿色松散包围盒大小。 前期工作首先，我们要构造两个方法，一个是判断对象中心是否在格子内，还有一个是判断两个包围盒是否相交。 判断对象中心是否在格子内很简单，只要判断中心点的 x 和 z 是否大于包围盒最小值并且小于包围盒最大值即可。 中心点检测123456789101112/** * 检测是否在包围盒内 * @param rect * @returns */ private checkInAreaStrict(rect: RectBean, child: RectBean) &#123; if (rect.minX &gt; child.minX &amp;&amp; rect.maxX &lt; child.maxX &amp;&amp; rect.minZ &gt; child.minZ &amp;&amp; rect.maxZ &lt; child.maxZ) &#123; return true; &#125; return false; &#125; 检测包围盒是否相交的时候只要判断包围盒 A 的最大值是否小于包围盒 B 的最小值或者包围盒 A 的最小值是否大于包围盒 B 的最大值，这种情况下两包围盒必定不相交。这种方法即 AABB（Axially Aligned Bounding Box，按坐标轴排列的包围盒）检测。 AABB相交检测123456789101112131415/** * 检测是否相交 * @param rect * @param child * @returns */ private checkIntractive(rect: RectBean, child: RectBean) &#123; if (rect.maxX &lt; child.minX || rect.minX &gt; child.maxX || rect.maxZ &lt; child.minZ || rect.minZ &gt; child.maxZ) &#123; return false; &#125; return true; &#125; 四叉树插入首先，我们先判断是否需要拓展子节点，就按照上面说的，在不存在子节点并且是根节点，或者当前节点对象数量超出限制数量并且当前节点深度不是最大深度的时候拓展。 然后我们根据规则把对象插入到四叉树中即可。先判断对象是否可以插入当前格，然后判断当前格有无子节点，有子节点尽量把对象插入子节点，同时标记当前格（如果有子节点的话也包括子节点）存储的对象数量。 插入123456789101112131415161718192021222324252627282930313233343536373839/** * 插入对象 * @param obj * @returns */public insert(obj: QtreeObj) &#123; //判断是否创建子节点 if (!this._childDic[&quot;tl&quot;] &amp;&amp; (this._depth == 0 || this._objCount &gt;= this._belongTree._maxObjCount &amp;&amp; this._depth &lt; this._belongTree._maxDepth)) &#123; this.createChild(); //填充对象到新创建的子节点中 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //遍历子节点 for (let prop in this._childDic) &#123; //对象满足子节点条件的，插入到子节点中 if (this.checkInAreaStrict(this._objList[i].rect, this._childDic[prop]._bound)) &#123; this._childDic[prop].insert(this._objList[i]); this._objList.splice(i, 1); break; &#125; &#125; &#125; &#125; if (this._childDic[&quot;tl&quot;]) &#123; //尽可能地分到子节点 for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._objCount++; return this._childDic[key].insert(obj); &#125; &#125; &#125; this._objList.push(obj); ++this._objCount; return this;&#125; 四叉树移除四叉树的移除和插入类似，每个查找到的节点都和需要移除的对象进行对比，如果该节点没有需要移除的对象，就进入到子节点去继续查找，直到找到或者最大深度。移除之后要对插入该对象的每一层的对象数量进行减 1。如果四个子节点的对象数量都为 0 的情况下，父节点可以进行坍缩，即移除四个子节点。 移除12345678910111213141516171819202122232425262728293031/** * 移除对象 * @param obj * @returns */public remove(obj: QtreeObj) &#123; //父节点坍缩 if (this._parent._objCount &lt;= 0) &#123; this._parent._childDic = &#123;&#125;; &#125; //遍历移除 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //比较对象id是否相等，该条件可根据需要自行修改 if (this._objList[i].objId == obj.objId) &#123; this._objList.splice(i, 1); this._objCount--; return; &#125; &#125; //如果当前节点没有匹配对象，则遍历子节点寻找需要移除的对象 if (this._childDic[&quot;tl&quot;]) &#123; for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._childDic[key].remove(obj); this._objCount--; return; &#125; &#125; &#125;&#125; 四叉树查找接下来是四叉树的查找，四叉树的查找可以只查找当前源对象所在的区块，或者也可以进一步筛选和源对象相交的对象，即检测与查找范围包围盒相交的对象。本案例采取进一步筛选的模式。 在四叉树遍历的过程中，先对每个节点的对象进行相交检测，相交的物体加入查找结果数组。然后对于每个子节点，我们都要比较源对象的范围和子节点的松散包围盒是否相交。由于每个子节点都有可能和源对象交汇， 因此四个子节点都要进行判断。 查找1234567891011121314151617181920/** * 查找范围内所有节点 * @param rect */public findObjFromRect(rect: RectBean): QtreeObj[] &#123; let objs = []; //查找匹配对象 for (let key in this._objList) &#123; if (this.checkIntractive(rect, this._objList[key].rect)) &#123; objs.push(this._objList[key]); &#125; &#125; //遍历子节点 for (let key in this._childDic) &#123; if (this._childDic[key].checkIntractive(rect, this._childDic[key]._looseBound)) &#123; objs = objs.concat(this._childDic[key].findObjFromRect(rect)); &#125; &#125; return objs;&#125; 四叉树动态更新四叉树节点的更新也很简单。具体的逻辑如下图所示： 更新12345678910111213/** * 刷新对象在四叉树中的位置 * @param obj * @returns */public refresh(obj: QtreeObj) &#123; if (this.checkInAreaStrict(obj.rect, this._bound)) &#123; return this; &#125; else &#123; this.remove(obj); return this._belongTree.insert(obj); &#125;&#125; 代码包围盒数据结构1234567891011121314151617181920export default class RectBean &#123; constructor(x?, z?, w?, h?, maxX?, minX?, maxZ?, minZ?) &#123; this.x = x; this.z = z; this.w = w; this.h = h; this.maxX = maxX; this.minX = minX; this.maxZ = maxZ; this.minZ = minZ; &#125; public x; public z; public w; //宽 -- x方向 public h; //高 -- z方向 public maxX; public minX; public maxZ; public minZ;&#125; 四叉树对象数据结构123456789101112131415161718import &#123; BoxCollider &#125; from &quot;../../../../../libs/Collider&quot;;export default class QtreeObj &#123; constructor(id?, objId?, rect?, node?) &#123; this.id = id; this.objId = objId; this.rect = rect; this.node = node; &#125; /** id 一般只需要这个就够了 必要属性 */ public id: number; /** 对象id 此处为项目需要而增加的id */ public objId: number; /** 范围 必要属性 */ public rect; /** 节点 必要属性 */ public node: Laya.Sprite3D;&#125; 四叉树脚本12345678910111213141516171819202122232425262728293031import QtreeObj from &quot;./Bean/QtreeObj&quot;;import Qnode from &quot;./Qnode&quot;;export default class Qtree &#123; public _maxDepth = 0; public _maxObjCount = 0; public _bound = &#123;&#125;; /** 子节点 */ public _root: Qnode; constructor(bound, maxDepth, maxObjCount) &#123; this._bound = bound; this._maxDepth = maxDepth; this._maxObjCount = maxObjCount; this._root = new Qnode(bound, 0, this, this); &#125; public insert(obj: QtreeObj): void &#123; return this._root.insert(obj); &#125; public remove(obj: QtreeObj) &#123; this._root.remove(obj); &#125; public findObjFromRect(rect): QtreeObj[] &#123; return this._root.findObjFromRect(rect); &#125;&#125; 四叉树节点脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348import ModelFactory from &quot;../../Common/ModelFactory&quot;;import QtreeObj from &quot;./Bean/QtreeObj&quot;;import RectBean from &quot;./Bean/RectBean&quot;;import Qtree from &quot;./Qtree&quot;;export default class Qnode &#123; /** 包围盒 */ public _bound: &#123; x; z; w; h; maxX; minX; maxZ; minZ &#125;; /** 宽松包围盒 */ public _looseBound: any = &#123;&#125;; /** 父节点 */ public _parent: Qnode; /** 所属四叉树 */ public _belongTree: Qtree; /** 对象列表 */ public _objList = []; /** 子节点字典 */ public _childDic = &#123;&#125;; /** 深度 */ public _depth: number; /** 对象数量 */ public _objCount = 0; private _debugColor: Laya.Color = new Laya.Color(1, 0, 0, 1); private _debugColor2: Laya.Color = new Laya.Color(0, 1, 1, 1); private _debugView: Laya.PixelLineSprite3D; constructor(bound, depth, parent, belongTree) &#123; this._bound = bound; this._depth = depth; this._parent = parent; this._belongTree = belongTree; this._looseBound = &#123; x: bound.x, z: bound.z, w: bound.w * 2, h: bound.h * 2, maxX: bound.x + bound.w, minX: bound.x - bound.w, maxZ: bound.z + bound.h, minZ: bound.z - bound.h, &#125;; //绘制四叉树范围 // this.showDebugMode(); &#125; /** * 绘制四叉树范围 Laya版本 * @param loose 是否绘制松散范围 */ private showDebugMode(loose?) &#123; Laya.timer.once(1000, this, () =&gt; &#123; //场景中插入线段 this._debugView = new Laya.PixelLineSprite3D(99999); ModelFactory.getScene().addChild(this._debugView); for (let t = this._debugView.lineCount - 1; t &gt;= 0; t--) this._debugView.removeLine(t); //紧凑四叉树 this._debugView.addLine( new Laya.Vector3(this._bound.maxX, 0.1, this._bound.maxZ), new Laya.Vector3(this._bound.maxX, 0.1, this._bound.minZ), this._debugColor, this._debugColor ); this._debugView.addLine( new Laya.Vector3(this._bound.minX, 0.1, this._bound.maxZ), new Laya.Vector3(this._bound.minX, 0.1, this._bound.minZ), this._debugColor, this._debugColor ); this._debugView.addLine( new Laya.Vector3(this._bound.maxX, 0.1, this._bound.maxZ), new Laya.Vector3(this._bound.minX, 0.1, this._bound.maxZ), this._debugColor, this._debugColor ); this._debugView.addLine( new Laya.Vector3(this._bound.maxX, 0.1, this._bound.minZ), new Laya.Vector3(this._bound.minX, 0.1, this._bound.minZ), this._debugColor, this._debugColor ); if (loose) &#123; //松散四叉树 this._debugView.addLine( new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.maxZ), new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.minZ), this._debugColor2, this._debugColor2 ); this._debugView.addLine( new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.maxZ), new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.minZ), this._debugColor2, this._debugColor2 ); this._debugView.addLine( new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.maxZ), new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.maxZ), this._debugColor2, this._debugColor2 ); this._debugView.addLine( new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.minZ), new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.minZ), this._debugColor2, this._debugColor2 ); &#125; &#125;); &#125; /** * 插入对象 * @param obj * @returns */ public insert(obj: QtreeObj) &#123; //判断是否创建子节点 if ( !this._childDic[&quot;tl&quot;] &amp;&amp; (this._depth == 0 || (this._objCount &gt;= this._belongTree._maxObjCount &amp;&amp; this._depth &lt; this._belongTree._maxDepth)) ) &#123; this.createChild(); //填充对象到新创建的子节点中 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //遍历子节点 for (let prop in this._childDic) &#123; //对象满足子节点条件的，插入到子节点中 if ( this.checkInAreaStrict( this._objList[i].rect, this._childDic[prop]._bound ) ) &#123; this._childDic[prop].insert(this._objList[i]); this._objList.splice(i, 1); break; &#125; &#125; &#125; &#125; if (this._childDic[&quot;tl&quot;]) &#123; //尽可能地分到子节点 for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._objCount++; return this._childDic[key].insert(obj); &#125; &#125; &#125; this._objList.push(obj); ++this._objCount; return this; &#125; /** * 移除对象 * @param obj * @returns */ public remove(obj: QtreeObj) &#123; //父节点坍缩 if (this._parent._objCount &lt;= 0) &#123; this._parent._childDic = &#123;&#125;; &#125; //遍历移除 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //比较对象id是否相等，该条件可根据需要自行修改 if (this._objList[i].objId == obj.objId) &#123; this._objList.splice(i, 1); this._objCount--; return; &#125; &#125; //如果当前节点没有匹配对象，则遍历子节点寻找需要移除的对象 if (this._childDic[&quot;tl&quot;]) &#123; for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._childDic[key].remove(obj); this._objCount--; return; &#125; &#125; &#125; &#125; /** * 查找范围内所有节点 * @param rect */ public findObjFromRect(rect: RectBean): QtreeObj[] &#123; let objs = []; //查找匹配对象 for (let key in this._objList) &#123; if (this.checkIntractive(rect, this._objList[key].rect)) &#123; objs.push(this._objList[key]); &#125; &#125; //遍历子节点 for (let key in this._childDic) &#123; if ( this._childDic[key].checkIntractive( rect, this._childDic[key]._looseBound ) ) &#123; objs = objs.concat(this._childDic[key].findObjFromRect(rect)); &#125; &#125; return objs; &#125; /** * 刷新对象在四叉树中的位置 * @param obj * @returns */ public refresh(obj: QtreeObj) &#123; if (this.checkInAreaStrict(obj.rect, this._bound)) &#123; return this; &#125; else &#123; this.remove(obj); return this._belongTree.insert(obj); &#125; &#125; /** * 创建子节点 */ private createChild() &#123; let bound1 = &#123; x: this._bound.x + this._bound.w * 0.25, z: this._bound.z + this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x + this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x + this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z + this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z + this._bound.h * 0.25 - this._bound.h * 0.25, &#125;; this._childDic[&quot;tl&quot;] = new Qnode( bound1, this._depth + 1, this._parent, this._belongTree ); let bound2 = &#123; x: this._bound.x - this._bound.w * 0.25, z: this._bound.z + this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x - this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x - this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z + this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z + this._bound.h * 0.25 - this._bound.h * 0.25, &#125;; this._childDic[&quot;tr&quot;] = new Qnode( bound2, this._depth + 1, this._parent, this._belongTree ); let bound3 = &#123; x: this._bound.x + this._bound.w * 0.25, z: this._bound.z - this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x + this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x + this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z - this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z - this._bound.h * 0.25 - this._bound.h * 0.25, &#125;; this._childDic[&quot;bl&quot;] = new Qnode( bound3, this._depth + 1, this._parent, this._belongTree ); let bound4 = &#123; x: this._bound.x - this._bound.w * 0.25, z: this._bound.z - this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x - this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x - this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z - this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z - this._bound.h * 0.25 - this._bound.h * 0.25, &#125;; this._childDic[&quot;br&quot;] = new Qnode( bound4, this._depth + 1, this._parent, this._belongTree ); &#125; /** * 检测是否在包围盒内 * @param rect * @returns */ private checkInAreaStrict(rect: RectBean, child: RectBean) &#123; if ( rect.minX &gt; child.minX &amp;&amp; rect.maxX &lt; child.maxX &amp;&amp; rect.minZ &gt; child.minZ &amp;&amp; rect.maxZ &lt; child.maxZ ) &#123; return true; &#125; return false; &#125; /** * 检测是否相交 * @param rect * @param child * @returns */ private checkIntractive(rect: RectBean, child: RectBean) &#123; if ( rect.maxX &lt; child.minX || rect.minX &gt; child.maxX || rect.maxZ &lt; child.minZ || rect.minZ &gt; child.maxZ ) &#123; return false; &#125; return true; &#125;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"四叉树","slug":"四叉树","permalink":"https://busyogg.github.io/tags/%E5%9B%9B%E5%8F%89%E6%A0%91/"},{"name":"空间管理","slug":"空间管理","permalink":"https://busyogg.github.io/tags/%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"}]},{"title":"基于IP的SSL证书签发","slug":"基于IP的SSL证书签发","date":"2023-09-09T20:37:36.000Z","updated":"2024-05-18T15:40:08.395Z","comments":true,"path":"article/e01680050386/","link":"","permalink":"https://busyogg.github.io/article/e01680050386/","excerpt":"","text":"重要信息现在本方法基本失效了，因为免费证书有数量上限并且已过期证书无法删除。 简介网上大部分 SSL 证书都需要域名来签发，这里找到一个可以用 IP 来签发的 SSL 证书申请。 网址ZeroSSLhttps://app.zerossl.com/ 使用说明 由于没有使用过邮件验证，因此不提供具体方法。 如果选择 CNAME 验证，则到 DNS 管理填入 CNAME 给的参数，此处以 Cloudflare 举例 如果选 HTTP 验证 nginx 代理可以自行搜索 linux nginx 访问本地文件 证书签发后我们可以根据需要安装证书 然后选择对应的类型根据提示进行安装","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"SSL证书","slug":"SSL证书","permalink":"https://busyogg.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"}]},{"title":"Cloudflare加速github访问","slug":"Cloudflare加速github访问","date":"2023-09-09T19:27:19.000Z","updated":"2024-05-18T15:38:05.247Z","comments":true,"path":"article/ae66b10eef2c/","link":"","permalink":"https://busyogg.github.io/article/ae66b10eef2c/","excerpt":"","text":"简介利用 Cloudflare 代理访问 GitHub 地址，同理可应用于其他网址。 准备 Cloudflare 账号 域名（自行注册） 实现方法 登录 Cloudflare，把你的域名添加到 Cloudflare。 处理域名的 DNS 新增 Woker worker 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&quot;use strict&quot;;/** * static files (404.html, sw.js, conf.js) */const ASSET_URL = &quot;https://域名/&quot;;// 前缀，如果自定义路由为example.com/gh/*，将PREFIX改为 &#x27;/gh/&#x27;，注意，少一个杠都会错！const PREFIX = &quot;/&quot;;// 分支文件使用jsDelivr镜像的开关，0为关闭，默认关闭const Config = &#123; jsdelivr: 0,&#125;;const whiteList = []; // 白名单，路径里面有包含字符的才会通过，e.g. [&#x27;/username/&#x27;]/** @type &#123;RequestInit&#125; */const PREFLIGHT_INIT = &#123; status: 204, headers: new Headers(&#123; &quot;access-control-allow-origin&quot;: &quot;*&quot;, &quot;access-control-allow-methods&quot;: &quot;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&quot;, &quot;access-control-max-age&quot;: &quot;1728000&quot;, &#125;),&#125;;const exp1 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:releases|archive)\\/.*$/i;const exp2 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:blob|raw)\\/.*$/i;const exp3 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:info|git-).*$/i;const exp4 = /^(?:https?:\\/\\/)?raw\\.(?:githubusercontent|github)\\.com\\/.+?\\/.+?\\/.+?\\/.+$/i;const exp5 = /^(?:https?:\\/\\/)?gist\\.(?:githubusercontent|github)\\.com\\/.+?\\/.+?\\/.+$/i;const exp6 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/tags.*$/i;/** * @param &#123;any&#125; body * @param &#123;number&#125; status * @param &#123;Object&lt;string, string&gt;&#125; headers */function makeRes(body, status = 200, headers = &#123;&#125;) &#123; headers[&quot;access-control-allow-origin&quot;] = &quot;*&quot;; return new Response(body, &#123; status, headers &#125;);&#125;/** * @param &#123;string&#125; urlStr */function newUrl(urlStr) &#123; try &#123; return new URL(urlStr); &#125; catch (err) &#123; return null; &#125;&#125;addEventListener(&quot;fetch&quot;, (e) =&gt; &#123; const ret = fetchHandler(e).catch((err) =&gt; makeRes(&quot;cfworker error:\\n&quot; + err.stack, 502) ); e.respondWith(ret);&#125;);function checkUrl(u) &#123; for (let i of [exp1, exp2, exp3, exp4, exp5, exp6]) &#123; if (u.search(i) === 0) &#123; return true; &#125; &#125; return false;&#125;/** * @param &#123;FetchEvent&#125; e */async function fetchHandler(e) &#123; const req = e.request; const urlStr = req.url; const urlObj = new URL(urlStr); let path = urlObj.searchParams.get(&quot;q&quot;); if (path) &#123; return Response.redirect(&quot;https://&quot; + urlObj.host + PREFIX + path, 301); &#125; // cfworker 会把路径中的 `//` 合并成 `/` path = urlObj.href .substr(urlObj.origin.length + PREFIX.length) .replace(/^https?:\\/+/, &quot;https://&quot;); if ( path.search(exp1) === 0 || path.search(exp5) === 0 || path.search(exp6) === 0 || path.search(exp3) === 0 || path.search(exp4) === 0 ) &#123; return httpHandler(req, path); &#125; else if (path.search(exp2) === 0) &#123; if (Config.jsdelivr) &#123; const newUrl = path .replace(&quot;/blob/&quot;, &quot;@&quot;) .replace(/^(?:https?:\\/\\/)?github\\.com/, &quot;https://cdn.jsdelivr.net/gh&quot;); return Response.redirect(newUrl, 302); &#125; else &#123; path = path.replace(&quot;/blob/&quot;, &quot;/raw/&quot;); return httpHandler(req, path); &#125; &#125; else if (path.search(exp4) === 0) &#123; const newUrl = path .replace(/(?&lt;=com\\/.+?\\/.+?)\\/(.+?\\/)/, &quot;@$1&quot;) .replace( /^(?:https?:\\/\\/)?raw\\.(?:githubusercontent|github)\\.com/, &quot;https://cdn.jsdelivr.net/gh&quot; ); return Response.redirect(newUrl, 302); &#125; else &#123; return fetch(ASSET_URL + path); &#125;&#125;/** * @param &#123;Request&#125; req * @param &#123;string&#125; pathname */function httpHandler(req, pathname) &#123; const reqHdrRaw = req.headers; // preflight if ( req.method === &quot;OPTIONS&quot; &amp;&amp; reqHdrRaw.has(&quot;access-control-request-headers&quot;) ) &#123; return new Response(null, PREFLIGHT_INIT); &#125; const reqHdrNew = new Headers(reqHdrRaw); let urlStr = pathname; let flag = !Boolean(whiteList.length); for (let i of whiteList) &#123; if (urlStr.includes(i)) &#123; flag = true; break; &#125; &#125; if (!flag) &#123; return new Response(&quot;blocked&quot;, &#123; status: 403 &#125;); &#125; if (urlStr.startsWith(&quot;github&quot;)) &#123; urlStr = &quot;https://&quot; + urlStr; &#125; const urlObj = newUrl(urlStr); /** @type &#123;RequestInit&#125; */ const reqInit = &#123; method: req.method, headers: reqHdrNew, redirect: &quot;manual&quot;, body: req.body, &#125;; return proxy(urlObj, reqInit);&#125;/** * * @param &#123;URL&#125; urlObj * @param &#123;RequestInit&#125; reqInit */async function proxy(urlObj, reqInit) &#123; const res = await fetch(urlObj.href, reqInit); const resHdrOld = res.headers; const resHdrNew = new Headers(resHdrOld); const status = res.status; if (resHdrNew.has(&quot;location&quot;)) &#123; let _location = resHdrNew.get(&quot;location&quot;); if (checkUrl(_location)) resHdrNew.set(&quot;location&quot;, PREFIX + _location); else &#123; reqInit.redirect = &quot;follow&quot;; return proxy(newUrl(_location), reqInit); &#125; &#125; resHdrNew.set(&quot;access-control-expose-headers&quot;, &quot;*&quot;); // resHdrNew.set(&#x27;access-control-allow-origin&#x27;, &#x27;*&#x27;) resHdrNew.delete(&quot;content-security-policy&quot;); resHdrNew.delete(&quot;content-security-policy-report-only&quot;); resHdrNew.delete(&quot;clear-site-data&quot;); return new Response(res.body, &#123; status, headers: resHdrNew, &#125;);&#125; 设置路由 例如我的路由为 所有步骤完成后基本上就可以根据你的域名访问 GitHub 托管的博客了，如果没有效果的话可能要等 Cloudflare 域名激活或者等一会儿 worker 生效 GitHub 图床GitHub 图床也可以用这个 worker 代码来代理，新增一个 worker，注意 github 图片的代理地址要写https://raw.githubusercontent.com/GitHub用户名/图床仓库名/分支名/，根据个人情况进行修改。可以在域名下添加一个路由，我是用的是img.busyo.buzz/*进行路由，然后添加 img 的 DNS，访问图片只要使用https://img.busyo.buzz/仓库中的图片路径即可。 例： 12345678910//代理地址https://raw.githubusercontent.com/UserName/PictureReposity/main///仓库结构PictureReposity|- picture|-- test.png//访问地址https://domain.com/picture/test.png","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"https://busyogg.github.io/tags/GitHub/"},{"name":"网络加速","slug":"网络加速","permalink":"https://busyogg.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"}]},{"title":"Hexo博客搭建 美化篇","slug":"Hexo博客搭建-美化篇","date":"2023-09-01T00:07:42.000Z","updated":"2024-05-18T15:37:59.870Z","comments":true,"path":"article/38effc2a84e9/","link":"","permalink":"https://busyogg.github.io/article/38effc2a84e9/","excerpt":"","text":"简介本网站使用的是 Volantis 主题，并对其进行了自定义改造。 安装在 _config.yml 文件中修改以下项目 config.yml1theme: volantis 然后通过 npm 安装主题文件 主题安装1npm i hexo-theme-volantis 安装完主题后，在博客的根目录创建一个新的配置文件 _config.volantis.yml，并且从主题文件夹中复制配置文件的内容进来，以便修改配置。 因为我们是通过 npm 方式安装，因此主题配置文件在\\node_modules\\hexo-theme-volantis\\_config.yml 该主题自带的搜索功能需要安装额外模块 搜索安装1npm i -S hexo-generator-json-content 然后修改配置文件 _config.volantis.yml123search: enable: true service: hexo 配置主题主题配置可以阅读主题文档进行对应的配置。 主题配置https://volantis.js.org/v6/theme-settings/ 以下为本博客主要调节的配置 导航_config.volantis.yml12345678910111213141516171819202122232425navbar: width: auto visiable: always # always, auto effect: [shadow, blur] # [shadow, floatable, blur] logo: # choose [img] or [icon + title] img: /images/img_logo.png #logo图片路径 icon: title: menu: - name: 主页 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 暗黑模式 # 可自定义 icon: fa-solid fa-moon # 可自定义 toggle: darkmode search: Search... # Search bar placeholder 导航新增了分类和标签两个栏目，以及黑暗模式的切换按钮 分类和标签使用代码创建 12hexo new page categorieshexo new page tags 创建完成后，我们到 source 文件夹下对应的文件夹修改 index.md 文件 categories123456---layout: categoryindex: truetitle: 所有分类sidebar: [blogger, music, category, tagcloud, webinfo]--- tags123456---layout: tagindex: truetitle: 所有标签sidebar: [blogger, music, category, tagcloud, webinfo]--- 这里的 sidebar 是组件列表，可以根据需要参考主题文档自己修改 首页 Cover_config.volantis.yml1234567891011121314cover: height_scheme: half # full, half layout_scheme: featured # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) display: home: true archive: false others: false # can be written in front-matter &#x27;cover: true&#x27; background: https://gcore.jsdelivr.net/gh/MHG-LAB/cron@gh-pages/bing/bing.jpg #背景图 # background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &quot;Busyo&#x27;s Blog&quot; #中间显示的文字 subtitle: &quot;&quot; search: A Wonderful Theme for Hexo # search bar placeholder # features: 此处本博客选择占一半页面的 cover，为了保留博客名的显示，选择了非 blank 的布局，同时为了移除多余的按钮，注释了 features 的所有内容。display 可以选择在什么界面展示。 字体_config.volantis.yml12345678910111213141516171819fontfamily: logofont: fontfamily: &#x27; &quot;haipai&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &quot;haipai&quot; url: /fonts/haipai.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;haipai&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &quot;haipai&quot; url: /fonts/haipai.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &quot;FiraCode-SemiBold, haipai, Monaco&quot; name: &quot;FiraCode-SemiBold&quot; url: /fonts/FiraCode-SemiBold.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf weight: normal style: normal 此配置可以修改三个地方的字体 logo 字体、正文字体和代码字体，本博客使用的字体保存于/source/fonts/文件夹下，因此传入的路径去除 source 之后就是/fonts/字体 侧边栏组件_config.volantis.yml12345678sidebar: position: right # left right # 主页、分类、归档等独立页面 for_page: [blogger, music, category, tagcloud, webinfo] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: 侧边栏的组件列表内的内容都是从下面组件库中选择，并且组件可根据自己需求调整配置，详情可参考官方文档和配置注释。 文章作者_config.volantis.yml1234567meta_library: # 默认文章作者（可在 _data/author.yaml 中增加其他作者，并在 front-matter 中设置） # https://volantis.js.org/advanced-settings/#多人协同 author: avatar: /images/img_icon.png # 作者头像图片路径 name: 名字 url: / #作者网址 默认即博客网址 插件幻灯片背景_config.volantis.yml12345678910111213141516171819202122232425262728parallax: enable: true position: fixed # cover: 固定位置. fixed: 滚动跟随. shuffle: true # 乱序 duration: 10000 # 显示持续时间 单位毫秒 fade: 500 # 渐变时间 单位毫秒 images: # 图片列表 - volantis-static/media/wallpaper/minimalist/2020/001.webp - volantis-static/media/wallpaper/minimalist/2020/002.webp - volantis-static/media/wallpaper/minimalist/2020/003.webp - volantis-static/media/wallpaper/minimalist/2020/004.webp - volantis-static/media/wallpaper/minimalist/2020/005.webp - volantis-static/media/wallpaper/minimalist/2020/006.webp - volantis-static/media/wallpaper/minimalist/2020/012.webp - volantis-static/media/wallpaper/minimalist/2020/016.webp - volantis-static/media/wallpaper/minimalist/2020/019.webp - volantis-static/media/wallpaper/minimalist/2020/025.webp - volantis-static/media/wallpaper/minimalist/2020/033.webp - volantis-static/media/wallpaper/minimalist/2020/034.webp - volantis-static/media/wallpaper/minimalist/2020/035.webp - volantis-static/media/wallpaper/minimalist/2020/038.webp - volantis-static/media/wallpaper/minimalist/2020/039.webp - volantis-static/media/wallpaper/minimalist/2020/042.webp - volantis-static/media/wallpaper/minimalist/2020/046.webp - volantis-static/media/wallpaper/minimalist/2020/051.webp - volantis-static/media/wallpaper/minimalist/2020/052.webp - volantis-static/media/wallpaper/minimalist/2020/054.webp - volantis-static/media/wallpaper/minimalist/2020/056.webp 音乐播放器_config.volantis.yml1234567891011121314151617181920aplayer: enable: true js: aplayer: volantis-static/libs/aplayer/dist/APlayer.min.js # https://unpkg.com/aplayer@1.10/dist/APlayer.min.js meting: volantis-static/libs/meting/dist/Meting.min.js # https://unpkg.com/meting@2.0/dist/Meting.min.js css: volantis-static/libs/aplayer/dist/APlayer.min.css # https://unpkg.com/aplayer@1.10/dist/APlayer.min.css # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 897784673 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &quot;#1BCDFC&quot; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;yaml&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true autoHide: true # hide automaticaly 设置 enable 启用，server 选择音乐软件，type 选择类型，对应音乐软件中的类型，id 选择具体的曲目，本博客使用网易云的歌单，id 即代表对应的歌单。 如何获得类型和id？ 打开网页版网易云，搜索想要的内容，查看网址栏 统计_config.volantis.yml123456analytics: busuanzi: volantis-static/libs/busuanzi/js/busuanzi.pure.mini.js #https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js leancloud: # 请使用自己的 id &amp; key 以防止数据丢失 app_id: # u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI app_key: # jfHtEKVE24j0IVCGHbvuFClp custom_api_server: # 国际版一般不需要写，除非自定义了 API Server 本博客使用不蒜子统计，若需要更高级的统计，可参考主题文档接入其他统计。 字数统计_config.volantis.yml123# npm i hexo-wordcountwordcount: enable: true 字数统计功能需要安装对应的模块 1npm i hexo-wordcount 界面功能界面支持多种功能，比如评论、标签、摘要、引用等，具体可以参考 界面配置 主题覆盖首先我们在主题文件夹\\node_modules\\hexo-theme-volantis\\source\\css下新建一个文件夹，名字随意，我新建了一个_busyo文件夹。 然后在新建的文件夹下新建一个cover.styl文件用来保存覆盖的样式，一个extra.styl文件用来保存新增的样式，最后我们在_busyo文件夹统计目录下的style.styl文件最末尾新增一行@import &#39;_busyo/*&#39;即可。 之后我们所有的样式改动都可以写在这两个文件夹内。 覆盖样式对于覆盖样式，我们可以利用浏览器的开发者工具定位我们想要修改的元素 此处我们看到 class 有两个样式，一个叫 highlight，一个叫 yaml，我们就可以在 cover.styl 文件夹内新增同名内容来修改他们。格式如下： cover.styl1234.highlight border: 3px solid rgba(0,0,0,0.5) border-radius: 20px overflow:hidden 属性修改即是 css 的修改，可以根据 css 的相关内容自己调整。 新增样式对于新增样式，可以在extra.styl文件新增不重名的样式，然后在对应的布局文件中对应的部分的 class 内容中加上你增加的样式。 布局文件的路径在主题文件夹\\node_modules\\hexo-theme-volantis\\layout\\下，ejs 结尾的文件。 关于 ejs 写法请自行查找相关内容。 内容注入本主题支持在不修改主题文件的情况下向 head 和 body 中添加内容。 _config.yml123456import: head_begin: head_end: body_begin: body_end: # - &lt;script&gt;&lt;/script&gt; 注入内容可以是任意标签，也可以是 JavaScript 代码，不过需要注意的是，由于网页加载策略的原因，JavaScript 代码只有在第一次打开网站的时候会执行，之后就会再次执行，除非刷新网页。 为了解决这个问题，本博客选择在布局文件中硬编入 script 标签。 本博客的代码块样式就是由代码生成替换。通过 script 标签引入后处理文件，这样每次打开界面都会执行代码。 article.ejs1234&lt;!--省略上面代码--&gt;&lt;/article&gt;&lt;script src = &quot;/script/AfterProcess.js&quot;&gt;&lt;/script&gt;&lt;!--省略下面代码--&gt; JavaScript 代码界面美化（代码块、标题）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677window.AfterProcess = &#123; ResetCodeStyle: () =&gt; &#123; var eles = document.getElementsByClassName(&quot;highlight&quot;); var colors = [&quot;#ed6a5e&quot;, &quot;#f5bd4f&quot;, &quot;#61c454&quot;]; for (let i = 0, len = eles.length; i &lt; len; i++) &#123; let child = eles[i].firstChild; //创建按钮 let customDiv = document.createElement(&quot;div&quot;); customDiv.style.display = &quot;flex&quot;; customDiv.style.height = &quot;40px&quot;; customDiv.style.width = &quot;100%&quot;; for (let j = 0; j &lt; 3; j++) &#123; let btn = document.createElement(&quot;div&quot;); btn.style.backgroundColor = colors[j]; btn.style.height = &quot;20px&quot;; btn.style.width = &quot;20px&quot;; btn.style.border = &quot;1px solid &quot; + colors[j]; btn.style.borderRadius = &quot;10px&quot;; btn.style.margin = &quot;10px 5px 10px 5px&quot;; customDiv.appendChild(btn); &#125; console.log(&quot;是否匹配&quot;, child.nodeName); if (child.nodeName != &quot;FIGCAPTION&quot;) &#123; //没有标题 eles[i].insertBefore(customDiv, child); &#125; else &#123; eles[i].replaceChild(customDiv, child); //有标题 let p = document.createElement(&quot;p&quot;); p.style.width = customDiv.offsetWidth - 40 * 3 + &quot;px&quot;; p.style.height = &quot;40px&quot;; p.style.textAlign = &quot;center&quot;; p.style.margin = &quot;0px&quot;; p.style.lineHeight = &quot;40px&quot;; p.innerText = child.firstChild.innerText; p.style.fontSize = &quot;20px&quot;; customDiv.appendChild(p); &#125; &#125; &#125;, ResetTitle: () =&gt; &#123; var eles = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;); var picker = window.getComputedStyle; for (let i = 1, len = eles.length; i &lt; len; i++) &#123; let child = eles[i].firstChild; let eleStyle = picker(eles[i]); //创建标识 let customDiv = document.createElement(&quot;div&quot;); customDiv.style.display = &quot;flex&quot;; customDiv.style.width = &quot;15px&quot;; customDiv.style.backgroundColor = &quot;#61c454&quot;; customDiv.style.height = eleStyle.fontSize; customDiv.style.marginRight = &quot;10px&quot;; customDiv.style.marginTop = (parseFloat(eleStyle.lineHeight) - parseFloat(eleStyle.fontSize)) * 0.5 + &quot;px&quot;; customDiv.style.borderRadius = &quot;5px&quot;; // console.log(&quot;字体大小&quot;,eleStyle.fontSize,parseFloat(eleStyle.lineHeight),parseFloat(eleStyle.fontSize)) // customDiv.style.verticalAlign eles[i].style.display = &quot;flex&quot;; eles[i].style.verticalAlign = &quot;center&quot;; eles[i].insertBefore(customDiv, child); &#125; &#125;, Init: () =&gt; &#123; console.log(&quot;初始化界面&quot;); AfterProcess.ResetCodeStyle(); AfterProcess.ResetTitle(); &#125;,&#125;;AfterProcess.Init();","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"教程/Hexo","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/Hexo/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://busyogg.github.io/tags/Hexo/"}]},{"title":"Hexo博客搭建 基础篇","slug":"Hexo博客搭建-基础篇","date":"2023-08-31T20:09:13.000Z","updated":"2024-05-18T15:38:01.307Z","comments":true,"path":"article/e834ef617110/","link":"","permalink":"https://busyogg.github.io/article/e834ef617110/","excerpt":"","text":"基础介绍Hexo 是一个快速、简洁且高效的博客框架，具有超快速度、支持 Markdown、一键部署、插件和可扩展性（引自官网简介）。 该框架可以部署到个人服务器或者 GitHub 上，本文主要是介绍如何部署到 GitHub，以及配置的调整。 依赖Hexo 博客需要安装相关依赖程序 Node.js Git 安装方法请自行查找。 Hexo 安装Hexo 博客利用 Node.js 的 npm 安装，我们打开 cmd 或者 powershell，输入以下命令安装 Hexo 相关的工具 1npm install -g hexo-cli 然后我们使用以下命令创建我们的博客文件夹，其中 folder 代表要创建文件夹的路径，不指定的话默认在当前文件夹创建，然后我们进入文件夹开始创建我们的博客 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 如果出现无法加载文件 C:\\Users\\*\\AppData\\Roaming\\npm\\nodemon.ps1之类的报错，可以使用以下方法解决（参考链接）： 12Start-Process powershell -Verb runAsset-ExecutionPolicy RemoteSigned 或者进入项目文件夹，运行： 1npx nodemon run dev 现在我们的博客文件夹的雏形就创建好了。接下来就是把我们的博客部署到 GitHub 上了。 部署 GitHub 首先我们要有一个 GitHub 的账号。 然后我们创建一个 git 仓库，用户名即你的 git 账户名 打开博客文件夹下的_comfig.yml，找到对应项目填入以下内容（没找到就自己写入） 1234deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: main 安装 Hexo 的 git 工具 1npm install --save hexo-deployer-git 打开 git 终端 输入以下命令，第一条为清空发布文件夹，第二条为生成发布文件夹，第三条为上传。 123hexo cleanhexo ghexo d 此时会遇到一个问题，err: Error: Spawn failed，我们需要去生成新 SSH 密钥，GitHub 官方文档生成 ssh，然后我们在 git 终端获取我们创建的 SSH 秘钥 12cd ~/.sshcat id_rsa.pub 然后填入这个界面 New SSH key 接下来我们推送博客到 GitHub 上应该就没有问题了，推送后过一会儿我们就能通过 用户名.github.io 的链接访问博客了 基本命令官网文档 - 指令https://hexo.io/zh-cn/docs/commands 创建文章可以用如下命令来创建一个 md 后缀的 markdown 页面，这个命令还有其他按参数，具体可以查阅官网文档。 1hexo new &quot;文章名&quot; 其他项目相关的命令如下 运行本地服务器1hexo server 生成发布文件夹1hexo generate 部分文件使用要先生成才能链接成功 清除发布文件夹1hexo clean 发布到git1hexo d 本命令需要在git终端执行 配置修改除了上文提到的 deploy 设置外，我们还可以更改博客的一些信息 123456789# Sitetitle: 博客名subtitle: 副标题description: 简介keywords:author: 作者名language: zh-CNtimezone: &#x27;&#x27;favicon: /images/img_icon.png #网站图标 这里的图标我用了本地文件，在 source 文件夹下创建的 images 文件夹内的 img_icon.png，在生成后路径会变成/public/images/img_icon.png，这里的 public 就是生成的文件夹，images 前面加斜杠代表从根目录开始，否则会以打开的路径后面加图标路径。其他资源的调用也是类似的情况。这里也可以用网络路径。 其次就是文章访问路径的修改，默认是以时间+文章名作为访问路径，我们可以通过以下配置修改 123456url: https://busyogg.github.io/ #网址permalink: article/:category/:title/ #访问路径permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 路径的规则为 | 变量 | 描述 || ———– | ————————————————————— | —— || :year | 文章的发表年份（4 位数） || :month | 文章的发表月份（2 位数） || :i_month | 文章的发表月份（不含前导零） || :day | 文章的发表日期 (2 位数) || :i_day | 文章的发表日期（不含前导零） || :hour | 文章发表时的小时 (2 位数) || :minute | 文章发表时的分钟 (2 位数) || :second | 文章发表时的秒钟 (2 位数) || :title | 文件名称 (相对于 “source&#x2F;_posts&#x2F;“ 文件夹) || :name | 文件名称 || :post_title | 文章标题 || :id | 文章 ID (清除缓存时不具有持久性) || :category | 分类。如果文章没有分类，则是 default_category 配置 | 信息。 || :hash | 文件名（与 :title 相同）和日期的 SHA1 哈希值（12 位 16 进制数） | 路径开头不带斜杠，我路径的 article 为文章存放的根文件夹，可加可不加，可自定义名称，根据个人需求决定。 其他注意事项 所有对 config 文件的修改都需要重新执行 hexo server命令 source 文件夹用于保存项目文件，对文章的修改可以实时更新，但要增加 source 文件夹下面的文件的话就需要重新执行hexo generate来生成文件 文章创建的样板文件为post.md，在 scaffolds 文件夹下，在创建文章的时候会帮你提前输入一些内容。其他样板文件同理。","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"教程/Hexo","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/Hexo/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"https://busyogg.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://busyogg.github.io/tags/Hexo/"}]},{"title":"Unity Console控制台打印拓展工具","slug":"Unity-Console控制台打印拓展工具","date":"2023-08-28T11:23:58.000Z","updated":"2024-05-18T15:37:10.187Z","comments":true,"path":"article/ad277da9d73c/","link":"","permalink":"https://busyogg.github.io/article/ad277da9d73c/","excerpt":"","text":"简介本项目旨在展开 console 控制台打印的内容显示，减少打印对象内容未知的情况，同时简化多参数打印的调用。 本项目部分功能使用 LitJson 实现，数组、字典、json 数据均会另起一行显示，其他数据之间会空一格显示 基本原理 利用 params 关键字，允许用户轻松打印不定数量的参数。 对部分变量类型进行手动序列化以在 console 控制台显示具体内容 整合所有参数最终的结果，拼为一个 string 并调用对应 Debug 方法打印 使用方法1234567891011121314151617181920212223//json数据string str = &quot;&#123; &#x27;a&#x27;:1 &#125;&quot;;JsonData jd = JsonMapper.ToObject(str);//字典内容Dictionary&lt;string, int[]&gt; testDic = new Dictionary&lt;string, int[]&gt;();testDic.Add(&quot;testA&quot;, new int[] &#123; 1, 2, 3 &#125;);testDic.Add(&quot;testB&quot;, new int[] &#123; 1 &#125;);//对象GameObject obj = new GameObject();obj.name = &quot;test_obj&quot;;//向量Vector3 vec = new Vector3();//对象object testObj = new object[] &#123; &quot;str1&quot;, 2 &#125;;//数组int[] ints = new int[] &#123; 1, 2, 3 &#125;;//输出测试ConsoleUtils.Log(&quot;输出通知内容1 ----- &quot;, ints, testObj, jd, testDic, obj, vec);ConsoleUtils.Warn(&quot;输出通知内容1 ----- &quot;, ints, testObj, jd, testDic, obj, vec);ConsoleUtils.Error(&quot;输出通知内容1 ----- &quot;, ints, testObj, jd, testDic, obj, vec); 运行效果 代码test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234using LitJson;using System;using UnityEngine;namespace Game&#123; public class ConsoleUtils &#123; private static string PrintDic(dynamic dic) &#123; string res = &quot;&#123; &quot;; foreach (dynamic data in dic) &#123; string key = data.Key.ToString(); string valueName = data.Value.GetType().Name; if (valueName.IndexOf(&quot;Dictionary&quot;) != -1) &#123; res += key + &quot;:&quot; + PrintDic(data.Value) + &quot;,&quot;; &#125; else if (valueName.IndexOf(&quot;List&quot;) != -1) &#123; res += key + &quot;:&quot; + PrintList(data.Value) + &quot;,&quot;; &#125; else &#123; res += key + &quot;:&quot; + data.Value.ToString() + &quot;,&quot;; &#125; &#125; res = res.Substring(0, res.Length - 1) + &quot; &#125;&quot;; return res; &#125; private static string PrintList(dynamic list) &#123; string res = &quot;[ &quot;; for(int i = 0,len = list.Count; i &lt; len; i++) &#123; string valueName = list[i].GetType().Name; if (valueName.IndexOf(&quot;Dictionary&quot;) != -1) &#123; res += PrintDic(list[i]) + &quot;,&quot;; &#125; else if (valueName.IndexOf(&quot;List&quot;) != -1) &#123; res += PrintList(list[i]) + &quot;,&quot;; &#125; else &#123; res += list[i].ToString() + &quot;,&quot;; &#125; &#125; res = res.Substring(0,res.Length - 1) + &quot; ]&quot;; return res; &#125; /// &lt;summary&gt; /// 打印到控制台 /// &lt;/summary&gt; /// &lt;param name=&quot;objs&quot;&gt;&lt;/param&gt; public static void Log(params object[] objs) &#123; string str = string.Empty; bool isWrap = false; foreach (object obj in objs) &#123; if (obj == null) continue; Type type = obj.GetType(); string extra = string.Empty; if (type.Name.IndexOf(&quot;[]&quot;) != -1) &#123; extra = &quot;,\\r\\n[ &quot;; Array objArray = (Array)obj; int i = 0; int len = objArray.Length; foreach (object data in objArray) &#123; extra += data.ToString() + (i == len - 1 ? string.Empty : &quot; , &quot;); i++; &#125; extra += &quot; ]&quot;; str += extra; isWrap = true; &#125; else if (type == typeof(JsonData)) &#123; string json = ((JsonData)obj).ToJson(); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;Dictionary&quot;) != -1) &#123; string json = PrintDic(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;List&quot;) != -1) &#123; string json = PrintList(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else &#123; if (isWrap) &#123; isWrap = false; str += &quot;,\\r\\n&quot;; &#125; str += obj.ToString() + &quot; &quot;; &#125; &#125; Debug.Log(str); &#125; public static void Warn(params object[] objs) &#123; string str = string.Empty; bool isWrap = false; foreach (object obj in objs) &#123; Type type = obj.GetType(); string extra = string.Empty; if (type.Name.IndexOf(&quot;[]&quot;) != -1) &#123; extra = &quot;,\\r\\n[ &quot;; Array objArray = (Array)obj; int i = 0; int len = objArray.Length; foreach (object data in objArray) &#123; extra += data.ToString() + (i == len - 1 ? string.Empty : &quot; , &quot;); i++; &#125; extra += &quot; ]&quot;; str += extra; isWrap = true; &#125; else if (type == typeof(JsonData)) &#123; string json = ((JsonData)obj).ToJson(); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;Dictionary&quot;) != -1) &#123; string json = PrintDic(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;List&quot;) != -1) &#123; string json = PrintList(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else &#123; if (isWrap) &#123; isWrap = false; str += &quot;\\r\\n&quot;; &#125; str += obj.ToString() + &quot; &quot;; &#125; &#125; Debug.LogWarning(str); &#125; public static void Error(params object[] objs) &#123; string str = string.Empty; bool isWrap = false; foreach (object obj in objs) &#123; Type type = obj.GetType(); string extra = string.Empty; if (type.Name.IndexOf(&quot;[]&quot;) != -1) &#123; extra = &quot;,\\r\\n[ &quot;; Array objArray = (Array)obj; int i = 0; int len = objArray.Length; foreach (object data in objArray) &#123; extra += data.ToString() + (i == len - 1 ? string.Empty : &quot; , &quot;); i++; &#125; extra += &quot; ]&quot;; str += extra; isWrap = true; &#125; else if (type == typeof(JsonData)) &#123; string json = ((JsonData)obj).ToJson(); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;Dictionary&quot;) != -1) &#123; string json = PrintDic(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;List&quot;) != -1) &#123; string json = PrintList(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else &#123; if (isWrap) &#123; isWrap = false; str += &quot;\\r\\n&quot;; &#125; str += obj.ToString() + &quot; &quot;; &#125; &#125; Debug.LogError(str); &#125; &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Js/Ts缓动系统","slug":"Js-Ts缓动系统","date":"2023-08-24T13:45:16.000Z","updated":"2024-05-18T15:37:51.956Z","comments":true,"path":"article/923369eacdd4/","link":"","permalink":"https://busyogg.github.io/article/923369eacdd4/","excerpt":"","text":"基本原理概述缓动的基本原理很简单，就是设置一个初值和终值，在每帧更新的时候根据特定的缓动函数算出对应的中间值并插值。 本工具类分为 4 个部分：缓动工具类、缓动辅助类、缓动核心类、缓动时间类。同时，本工具提供链式调用，方便进行多个缓动动作的连续执行。 缓动工具类负责管理缓动的调用，以及一个作用域所有的缓动。 缓动辅助类负责管理单个缓动的初始化，同时也是链式调用的核心类。 缓动核心类负责管理具体的缓动逻辑，所以缓动都是通过该类执行。 缓动时间类负责管理缓动的更新调用，本项目托管到 Laya 的更新脚本上。 由于本类在设计之初是在 Laya 引擎运行，因此小部分代码依托 Laya 存在，使用的时候需要根据具体项目进行修改。 使用方法所有的操作均从缓动工具类调用，但首先在运行之前要执行 TweenUtil.start()方法来初始化整个缓动工具的更新逻辑。 to 和 from 方法表示两个不同的缓动类型，to 为从当前状态到目标状态，from 为从目标状态到当前状态。这两个方法都会返回一个 subTween 对象，我们可以以这个 subTween 对象进行链式调用，以点的方法重复调用 to、from 等方法。 例如： 1234567891011121314151617181920let obj = &#123; x: 0 &#125;;TweenUtil.to( obj, &#123; x: 1, &#125;, 100) .to( &#123; x: 2, &#125;, 100 ) .to( &#123; x: 3, &#125;, 200 ); 此处执行了三个缓动，obj 的 x 值从 0 到 1 到 2 再到 3。三个缓动按照顺序执行一次。 同时，本项目也提供了循环执行缓动的功能，只需要在最后调用 loop() 方法，就可以对 loop 之前的所有步骤重复执行。另外，本项目也支持设置循环次数，只需要如下调用即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243let obj = &#123; x: 0 &#125;;TweenUtil.to( obj, &#123; x: 1, &#125;, 100) .to( &#123; x: 2, &#125;, 100 ) .to( &#123; x: 3, &#125;, 200 ) .loop();let obj2 = &#123; x: 0 &#125;;TweenUtil.to( obj2, &#123; x: 1, &#125;, 100) .to( &#123; x: 2, &#125;, 100 ) .to( &#123; x: 3, &#125;, 200 ) .loop(3); 如果存在两个 loop，若前面的 loop 为无限循环，则后面的 loop 无法执行，若不是无限循环，则后面的 loop 会执行第一个 loop 到第二个 loop 之间的缓动行为，第一个 loop 之前的缓动行为全部舍弃。其他情况同理。 如果要清理缓动，有两种方法，一种是调用 TweenUtil.clear() 方法，传入一个缓动对象，则这个缓动对象会被清理，另一种是清理作用域上的所有缓动对象，调用 TweenUtil.clearAll() 方法，传入作用域，则该作用域上的所有缓动对象都会被清理。 特别注意，本项目目前不支持缓动对象池，因为有可能会出现引用 bug，因此需要缓动对象池的话请自行实现。 缓动工具类原理本类内置 3 个变量 _tweenId ，_tweenDic ， _tweenClock _tweenId 变量用于自增缓动 id，也是缓动对象字典中的唯一标识符，每个作用域对应一个缓动 id。 _tweenDic 变量为缓动对象字典，用于存储缓动对象，结构为 { tweenId : SubTween[] } , key 为缓动 id，value 为缓动辅助类数组，保存该作用域上的所有缓动对象。 _tweenClock 变量为缓动核心类对象，在缓动核心类中会调用它来获取缓动时间类 本类的核心方法 to 和 from 的原理相同，方法分为两个部分： 创建一个缓动辅助类对象，设置对象的目标并且调用对应 to&#x2F;from 方法。 检查作用域的缓动 id，如果不存在，则初始化缓动 id，然后检查字典中是否存在对应 id 并把创建的对象保存到数组中，最后再返回这个对象。 清除缓动的原理则如下方详细代码所示。 缓动辅助类原理本类内置 8 个变量 target ， _listIndex ， _tweenList ， _tweening ， _tweenObj ， _tweenIndex ， _loop ， _limit target 变量如名字所示，就是缓动的目标对象。 _listIndex 变量用于缓动列表的索引，主要是区别各个 loop 缓动动作组，只有调用 loop 的情况下会增加。 _tweenList 变量用于保存缓动动作，是一个二维数组，第一维保存缓动动作组，第二维保存缓动动作序列。 _tweening 变量用于判断当前是否正在缓动 _tweenObj 变量保存本类当前实例化的缓动核心类对象 _tweenIndex 变量用于缓动序列的索引 _loop 变量用于判断是否开启循环 _limit 变量用于保存缓动循环次数限制，是个一维数组 本类的核心方法 to 和 from 的原理相同，方法分为两个部分： 保存缓动参数到 _tweenList[ _listIndex ] 数组中 如果缓动未启动，则启动缓动 本类最关键的，就是启动缓动的逻辑，具体逻辑如下图所示 本类的启动缓动，实际上就是上一个缓动动作和下一个缓动动作的连接，具体的缓动执行和结束，还得看缓动核心类。 缓动核心类原理本类内置 11 个变量 _target ， _prop ， _duration ， _ease ， _complete ， _delay ， _direction ， _isDone ， _time ， _def ， _isDelay _target 变量如名字所示是缓动的对象 _prop 变量保存需要缓动的所有属性 _duration 变量是缓动的持续时间 _ease 变量为缓动函数，所有缓动属性都需要通过该函数进行插值 _complete 变量为回调函数，在缓动结束后执行，主要是执行缓动辅助类中的 doTween _delay 变量是缓动延迟时间，在延迟时间结束后才会开始执行缓动 _direction 变量用于区分 to 和 from _isDone 变量用于标记是否完成缓动 _time 变量用于记录当前缓动执行时间 _def 变量用于保存缓动对象的原始属性 _isDelay 变量用于标记是否延迟执行缓动 本类的 to 和 from 方法也是初始化传入的缓动参数，并且把本类对象推到缓动时间类的遍历列表中。 本类最关键的就是缓动每一帧更新的逻辑，具体逻辑如下图所示 注意，缓动函数的传参格式为： 经过时间，起始值，结束值，总时长，返回值为 0 到 1 的之间的数值 缓动时间类原理本类在当前示例中依托 Laya 更新，也可以自定义定时器来更新。核心逻辑主要就是 update，遍历 _tweens ，先判断缓动核心对象是否结束缓动，结束缓动就移除，否则就执行 update 函数 ，传入 deltaTime 即 dt，单位为毫秒。 注意本类一般需要在整个项目中成为单例，不过本类并没有实现单例类，如果需要的话可自行实现。记得配合修改 TweenUtil.start 的内容。 代码缓动工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394export default class TweenUtil &#123; public static _tweenId = 1; public static _tweenDic = &#123;&#125;; private static _tweenClock: TweenClock; /** * 启动缓动工具类 本函数负责启动缓动时间类，函数体可根据需求自定义修改 */ public static start() &#123; let scriptScene = new Laya.Scene3D(); Laya.stage.addChild(scriptScene); this._tweenClock = scriptScene.addComponent(TweenClock); &#125; public static getTweenClock() &#123; return this._tweenClock; &#125; /** * to缓动 同Laya.Tween.to * @param target * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public static to(caller, target, prop, time, ease?, delay?, callback?) &#123; // console.log(&quot;缓动&quot;,target); let subTween = new SubTween(); subTween.target = target; subTween.to(prop, time, ease, delay, callback); if (!caller.tweenId) &#123; caller.tweenId = this._tweenId++; &#125; if (!this._tweenDic[caller.tweenId]) &#123; this._tweenDic[caller.tweenId] = []; &#125; this._tweenDic[caller.tweenId].push(subTween); return subTween; &#125; /** * from缓动 同Laya.Tween.to * @param target * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public static from(caller, target, prop, time, ease?, delay?, callback?) &#123; let subTween = new SubTween(); subTween.target = target; subTween.to(prop, time, ease, delay, callback); if (!caller.tweenId) &#123; caller.tweenId = this._tweenId++; &#125; if (!this.caller[caller.tweenId]) &#123; this.caller[caller.tweenId] = []; &#125; this._tweenDic[caller.tweenId].push(subTween); return subTween; &#125; /** * 清除目标缓动 * @param tweenObj */ public static clear(tweenObj: SubTween) &#123; tweenObj.clear(); &#125; /** * 清除目标节点所有缓动 * @param target */ public static clearAll(caller) &#123; // console.log(&quot;清除&quot;, caller) if (!this._tweenDic[caller.tweenId]) return; let len = this._tweenDic[caller.tweenId].length; for (let i = 0; i &lt; len; i++) &#123; (this._tweenDic[caller.tweenId][i] as SubTween).clear(); &#125; this._tweenDic[caller.tweenId] = []; &#125;&#125; 缓动辅助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166export class SubTween &#123; /** 目标节点 */ public target; /** 缓动列表索引 */ private _listIndex = 0; /** 缓动列表 */ private _tweenList; /** 是否正在缓动 */ private _tweening = false; /** 缓动对象 */ private _tweenObj: TweenCore; /** 缓动索引 */ private _tweenIndex = 0; /** 是否循环 */ private _loop = false; /** 缓动循环次数限制列表 */ private _limit: number[] = []; /** * 缓动 从现在属性到目标属性 * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public to(prop, time, ease?, delay?, callback?) &#123; if (!this._tweenList) &#123; this._tweenList = []; &#125; if (!this._tweenList[this._listIndex]) &#123; this._tweenList[this._listIndex] = []; &#125; this._tweenList[this._listIndex].push(&#123; prop: prop, time: time, ease: ease, delay: delay, callback: callback, type: 0, &#125;); this.startTween(); return this; &#125; /** * 缓动 从目标属性到现在属性 * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public from(prop, time, ease?, delay?, callback?) &#123; if (!this._tweenList) &#123; this._tweenList = []; &#125; if (!this._tweenList[this._listIndex]) &#123; this._tweenList[this._listIndex] = []; &#125; this._tweenList[this._listIndex].push(&#123; prop: prop, time: time, ease: ease, delay: delay, callback: callback, type: 1, &#125;); this.startTween(); return this; &#125; /** * 循环前面所有的动作 * @param 循环次数 不填或者0为无限循环 只有在非无限循环的情况下可以执行本次loop后面的缓动 */ public loop(limit = 0) &#123; this._loop = true; this._limit[this._listIndex] = limit - 1; this._listIndex++; return this; &#125; /** * 清除缓动 */ public clear() &#123; if (this._tweenObj) &#123; this._tweenObj.clear(); &#125; this._tweenList = null; return this; &#125; /** * 开始缓动 */ private startTween() &#123; if (!this._tweening) &#123; this._tweening = true; this.doTween(); &#125; &#125; /** * 执行缓动 */ private doTween() &#123; let self = this; if (!this._tweenList) return; let param = this._tweenList[0][this._tweenIndex++]; if (param) &#123; if (param.type == 0) &#123; this._tweenObj = new TweenCore(); this._tweenObj.to( this.target, param.prop, param.time, param.ease, () =&gt; &#123; param.callback &amp;&amp; param.callback(); self.doTween(); &#125;, param.delay ); &#125; else &#123; this._tweenObj = new TweenCore(); this._tweenObj.from( this.target, param.prop, param.time, param.ease, () =&gt; &#123; param.callback &amp;&amp; param.callback(); self.doTween(); &#125;, param.delay ); &#125; &#125; else &#123; if (this._loop) &#123; this._tweenIndex = 0; if (this._limit[0] == -1) &#123; this.doTween(); &#125; else &#123; if (this._limit[0] &gt; 0) &#123; this._limit[0]--; &#125; else &#123; this._tweenList.shift(); this._limit.shift(); this._listIndex--; if (this._tweenList.length == 0) &#123; this._tweenList = null; &#125; &#125; this.doTween(); &#125; &#125; else &#123; this._tweenList = null; this._limit = []; &#125; &#125; &#125;&#125; 缓动核心类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115export class TweenCore &#123; private _target; private _prop; private _duration; private _ease; private _complete; private _delay; private _direction; private _isDone; private _time = 0; private _def = &#123;&#125;; private _isDelay = false; public to( target: any, props: any, duration: number, ease?: Function | null, complete?, delay?: number ) &#123; this._target = target; this._prop = props; this._duration = duration; this._ease = ease || Laya.Ease.linearInOut; this._complete = complete; this._delay = delay ? delay : 0; this._delay &amp;&amp; (this._isDelay = true); this._direction = 1; this._isDone = false; for (let key in this._prop) &#123; this._def[key] = this._target[key]; &#125; TweenUtil.getTweenClock().push(this); return this; &#125; public from( target: any, props: any, duration: number, ease?: Function | null, complete?, delay?: number ) &#123; this._target = target; this._prop = props; this._duration = duration; this._ease = ease || Laya.Ease.linearInOut; this._complete = complete; this._delay = delay ? delay : 0; this._delay &amp;&amp; (this._isDelay = true); this._direction = 0; this._isDone = false; for (let key in this._prop) &#123; this._def[key] = this._target[key]; &#125; TweenUtil.getTweenClock().push(this); return this; &#125; public update(dt) &#123; if (this._target &amp;&amp; !this._isDone) &#123; //计算进度 this._time += dt; if (this._isDelay) &#123; if (this._time &gt;= this._delay) &#123; this._isDelay = false; this._time = 0; &#125; &#125; else &#123; if (this._time &gt; this._duration) &#123; this._time = this._duration; this._isDone = true; &#125; //更新 let ease = this._ease(this._time, 0, 1, this._duration); for (let key in this._prop) &#123; if (key == &quot;update&quot;) &#123; this._prop[key](); &#125; else &#123; this._target[key] = this._def[key] + (this._prop[key] - this._def[key]) * (this._direction ? ease : 1 - ease); &#125; &#125; //结束回调 if (this._isDone) &#123; this.clear(); this._complete &amp;&amp; this._complete(); this._complete = null; &#125; &#125; &#125; &#125; public clear() &#123; TweenUtil.getTweenClock().sub(this); this._target = null; this._prop = null; this._duration = null; this._ease = null; this._delay = null; this._direction = null; this._isDone = null; this._time = 0; this._def = &#123;&#125;; this._isDelay = false; &#125; public getDone() &#123; return this._isDone; &#125;&#125; 缓动时钟类此处挂载到 Laya 上，也可以自定义更新逻辑 12345678910111213141516171819202122232425262728293031export class TweenClock extends Laya.Script3D &#123; private _tweens: TweenCore[] = []; onAwake() &#123; console.log(&quot;TweenClock启动&quot;); &#125; public push(tween) &#123; this._tweens.push(tween); &#125; public sub(tween) &#123; let index = this._tweens.indexOf(tween); index != -1 &amp;&amp; this._tweens.splice(index, 1); &#125; public onUpdate() &#123; let time = Laya.timer.delta; let tween: TweenCore; for (let i = this._tweens.length - 1; i &gt;= 0; i--) &#123; tween = this._tweens[i]; if (tween) &#123; if (tween.getDone()) &#123; this._tweens.splice(i, 1); continue; &#125; tween.update(time); &#125; &#125; &#125;&#125; Laya 缓动函数参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179class Ease &#123; static linearNone(t, b, c, d) &#123; return (c * t) / d + b; &#125; static linearIn(t, b, c, d) &#123; return (c * t) / d + b; &#125; static linearInOut(t, b, c, d) &#123; return (c * t) / d + b; &#125; static linearOut(t, b, c, d) &#123; return (c * t) / d + b; &#125; static bounceIn(t, b, c, d) &#123; return c - Ease.bounceOut(d - t, 0, c, d) + b; &#125; static bounceInOut(t, b, c, d) &#123; if (t &lt; d * 0.5) return Ease.bounceIn(t * 2, 0, c, d) * 0.5 + b; else return Ease.bounceOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b; &#125; static bounceOut(t, b, c, d) &#123; if ((t /= d) &lt; 1 / 2.75) return c * (7.5625 * t * t) + b; else if (t &lt; 2 / 2.75) return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b; else if (t &lt; 2.5 / 2.75) return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b; else return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b; &#125; static backIn(t, b, c, d, s = 1.70158) &#123; return c * (t /= d) * t * ((s + 1) * t - s) + b; &#125; static backInOut(t, b, c, d, s = 1.70158) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * (t * t * (((s *= 1.525) + 1) * t - s)) + b; return (c / 2) * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b; &#125; static backOut(t, b, c, d, s = 1.70158) &#123; return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b; &#125; static elasticIn(t, b, c, d, a = 0, p = 0) &#123; var s; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * 0.3; if (!a || (c &gt; 0 &amp;&amp; a &lt; c) || (c &lt; 0 &amp;&amp; a &lt; -c)) &#123; a = c; s = p / 4; &#125; else s = (p / Ease.PI2) * Math.asin(c / a); return ( -( a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t * d - s) * Ease.PI2) / p) ) + b ); &#125; static elasticInOut(t, b, c, d, a = 0, p = 0) &#123; var s; if (t == 0) return b; if ((t /= d * 0.5) == 2) return b + c; if (!p) p = d * (0.3 * 1.5); if (!a || (c &gt; 0 &amp;&amp; a &lt; c) || (c &lt; 0 &amp;&amp; a &lt; -c)) &#123; a = c; s = p / 4; &#125; else s = (p / Ease.PI2) * Math.asin(c / a); if (t &lt; 1) return ( -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t * d - s) * Ease.PI2) / p)) + b ); return ( a * Math.pow(2, -10 * (t -= 1)) * Math.sin(((t * d - s) * Ease.PI2) / p) * 0.5 + c + b ); &#125; static elasticOut(t, b, c, d, a = 0, p = 0) &#123; var s; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * 0.3; if (!a || (c &gt; 0 &amp;&amp; a &lt; c) || (c &lt; 0 &amp;&amp; a &lt; -c)) &#123; a = c; s = p / 4; &#125; else s = (p / Ease.PI2) * Math.asin(c / a); return ( a * Math.pow(2, -10 * t) * Math.sin(((t * d - s) * Ease.PI2) / p) + c + b ); &#125; static strongIn(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125; static strongInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t * t * t + b; return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b; &#125; static strongOut(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125; static sineInOut(t, b, c, d) &#123; return -c * 0.5 * (Math.cos((Math.PI * t) / d) - 1) + b; &#125; static sineIn(t, b, c, d) &#123; return -c * Math.cos((t / d) * Ease.HALF_PI) + c + b; &#125; static sineOut(t, b, c, d) &#123; return c * Math.sin((t / d) * Ease.HALF_PI) + b; &#125; static quintIn(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125; static quintInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t * t * t + b; return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b; &#125; static quintOut(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125; static quartIn(t, b, c, d) &#123; return c * (t /= d) * t * t * t + b; &#125; static quartInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t * t + b; return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b; &#125; static quartOut(t, b, c, d) &#123; return -c * ((t = t / d - 1) * t * t * t - 1) + b; &#125; static cubicIn(t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125; static cubicInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t + b; return c * 0.5 * ((t -= 2) * t * t + 2) + b; &#125; static cubicOut(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125; static quadIn(t, b, c, d) &#123; return c * (t /= d) * t + b; &#125; static quadInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t + b; return -c * 0.5 * (--t * (t - 2) - 1) + b; &#125; static quadOut(t, b, c, d) &#123; return -c * (t /= d) * (t - 2) + b; &#125; static expoIn(t, b, c, d) &#123; return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001; &#125; static expoInOut(t, b, c, d) &#123; if (t == 0) return b; if (t == d) return b + c; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b; return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b; &#125; static expoOut(t, b, c, d) &#123; return t == d ? b + c : c * (-Math.pow(2, (-10 * t) / d) + 1) + b; &#125; static circIn(t, b, c, d) &#123; return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b; &#125; static circInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b; return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b; &#125; static circOut(t, b, c, d) &#123; return c * Math.sqrt(1 - (t = t / d - 1) * t) + b; &#125;&#125;Ease.HALF_PI = Math.PI * 0.5;Ease.PI2 = Math.PI * 2;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"}]},{"title":"Unity自定义事件系统","slug":"Unity自定义事件系统","date":"2023-08-24T09:03:15.000Z","updated":"2024-05-30T12:20:37.468Z","comments":true,"path":"article/2474251272a9/","link":"","permalink":"https://busyogg.github.io/article/2474251272a9/","excerpt":"","text":"基本原理在事件传递的过程中设置一个中间对象，负责管理监听者和发送者，以达到解耦合的目的。 首先我们定义一个方法来注册监听对象，该对象包含节点（即作用域）、事件名和事件函数，然后我们在事件触发的时候调用触发函数，来触发所有监听该事件的对象。触发函数包含事件名和参数。 此处我们以字典 _eventDictionary 来存储监听对象，以事件名作为字典的 key，在字典里我们以作用域为 key 定义另一个字典，防止同名事件冲突以及同作用域事件重复添加。 同时，由于我们需要一个清除节点上所有事件的方法，因此我们单独设置一个字典 _eventNode 用来保存节点和事件的关系。在清除节点上所有事件的时候只需要遍历该字典 _eventNode 中对应作用域（传入的 node）的事件并且从事件字典 _eventDictionary 中查找对应的事件对象及其作用域即可。 具体的调用过程如下图所示： 这就是最基本的事件系统。 粘性通知为了防止部分情况中出现通知不到位的情况（即先通知后监听），这里我们引入了粘性通知的功能。 此处我们定义一个字典 _stickyDic 来保存通知的内容，这里我们分为两种情况，一种情况是该粘性通知只需要通知一次，则我们只需要让新的通知覆盖旧的通知；另一种是需要多次通知，则我们设置一个数组来保存多次通知的内容，所以我们增设一个字典 _stickyArrayFlag 用于保存粘性通知类型。 粘性通知和普通通知的触发事件逻辑相似，可以说前半部分的代码和普通通知一样，只不过我们增设一个通知标识符，用于判断是否通知到位，若没有通知到位，则进入粘性通知内容保存的流程。 注册监听者的部分代码也有改动，在注册完成后，若从粘性通知字典 _stickyDic 取到对应事件名的内容，则立刻进行一次通知，通知结束后删除对应的内容。 简单来说，粘性通知就是在监听和通知这两个过程之后增加一个判断，对于监听者来说，就是要判断有无通知的内容，而对于通知来说，就是判断是否有监听者监听过该通知内容。 代码事件数据类1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections;namespace Game&#123; public class EventData &#123; private Action&lt;ArrayList&gt; _event = null; private string _eventName = string.Empty; public EventData(string eventName, Action&lt;ArrayList&gt; eventCallback) &#123; _eventName = eventName; _event = eventCallback; &#125; public void SetEventCallBack(Action&lt;ArrayList&gt; eventCallback) &#123; _event = eventCallback; &#125; public void RemoveEvent() &#123; _event = null; &#125; public void Triggered(ArrayList obj) &#123; if (_event != null) &#123; _event.Invoke(obj); &#125; &#125; &#125;&#125; 事件管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270using System;using System.Collections;using System.Collections.Generic;using UnityEngine;namespace Game&#123; public class EventManager &#123; /// &lt;summary&gt; /// 事件字典 /// &lt;/summary&gt; private static Dictionary&lt;string, Dictionary&lt;string, EventData&gt;&gt; _eventDictionary = new Dictionary&lt;string, Dictionary&lt;string, EventData&gt;&gt;(); /// &lt;summary&gt; /// 节点字典 /// &lt;/summary&gt; private static Dictionary&lt;string, Dictionary&lt;string, bool&gt;&gt; _eventNode = new Dictionary&lt;string, Dictionary&lt;string, bool&gt;&gt;(); /// &lt;summary&gt; /// 粘性通知字典 /// &lt;/summary&gt; private static Dictionary&lt;string, ArrayList&gt; _stickyDic = new Dictionary&lt;string, ArrayList&gt;(); /// &lt;summary&gt; /// 存储当前事件的粘性通知是否为队列通知 /// &lt;/summary&gt; private static Dictionary&lt;string, bool&gt; _stickyArrayFlag = new Dictionary&lt;string, bool&gt;(); /// &lt;summary&gt; /// 在需要监听某个事件的脚本中，调用这个方法来监听这个事件 /// &lt;/summary&gt; /// &lt;param name = &quot;id&quot;&gt;当前节点id&lt;/param&gt; /// &lt;param name=&quot;eventName&quot;&gt;事件名&lt;/param&gt; /// &lt;param name&quot;Action&quot;&gt;注册监听的函数&lt;/param&gt; public static void AddListening(string id, string eventName, Action&lt;ArrayList&gt; action) &#123; EventData eventData = null; if (!_eventDictionary.ContainsKey(eventName)) &#123; _eventDictionary.Add(eventName, new Dictionary&lt;string, EventData&gt;()); &#125; Dictionary&lt;string, EventData&gt; eventDic = _eventDictionary[eventName]; eventDic.TryGetValue(id, out eventData); if (eventData != null) &#123; eventData.SetEventCallBack(action); &#125; else &#123; eventData = new EventData(eventName, action); eventDic.Add(id, eventData); &#125; if (_eventNode.ContainsKey(id)) &#123; // _eventNode[id][eventName] = true; &#125; else &#123; Dictionary&lt;string, bool&gt; dicNode = new Dictionary&lt;string, bool&gt; &#123; &#123; id, true &#125; &#125;; _eventNode.Add(id, dicNode); &#125; //触发粘性通知 ArrayList stickyArray; _stickyDic.TryGetValue(eventName, out stickyArray); if (stickyArray != null) &#123; //有粘性通知的情况下一定能获取到是否为通知队列 bool isArray = _stickyArrayFlag[eventName]; if (isArray) &#123; for (int i = 0, len = stickyArray.Count; i &lt; len; i++) &#123; TriggerEvent(eventName, stickyArray[i] as ArrayList); &#125; &#125; else &#123; TriggerEvent(eventName, stickyArray); &#125; //完成通知，移除数据 _stickyArrayFlag.Remove(eventName); _stickyDic.Remove(eventName); &#125; &#125; /// &lt;summary&gt; /// 在不需要监听的时候停止监听 /// &lt;/summary&gt; /// &lt;param name = &quot;id&quot;&gt;当前节点id&lt;/param&gt; /// &lt;param name=&quot;eventName&quot;&gt;事件名&lt;/param&gt; public static void RemoveListening(string id, string eventName) &#123; EventData eventData = null; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(eventName, out eventDic); if (eventDic != null) &#123; eventDic.TryGetValue(id, out eventData); if (eventData != null) &#123; eventData.RemoveEvent(); //移除事件字典中的事件对应的作用域 eventDic.Remove(id); //如果事件字典中事件的作用域为0 则移除该事件 if (eventDic.Count &lt;= 0) &#123; _eventDictionary.Remove(eventName); &#125; //如果有事件存在，则一定在对应的node字典中存在 _eventNode[id].Remove(eventName); Debug.Log(&quot;移除事件&quot; + id + eventName); &#125; &#125; &#125; /// &lt;summary&gt; /// 移除节点上的所有事件 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;节点&lt;/param&gt; public static void RemoveAll(string id) &#123; if (_eventNode.ContainsKey(id)) &#123; foreach (var data in _eventNode[id]) &#123; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(data.Key, out eventDic); if (eventDic != null) &#123; EventData eventData = null; eventDic.TryGetValue(id, out eventData); if (eventData != null) &#123; //移除事件 eventData.RemoveEvent(); //移除事件字典中的事件对应的作用域 eventDic.Remove(id); //如果事件字典中事件的作用域为0 则移除该事件 if (eventDic.Count &lt;= 0) &#123; _eventDictionary.Remove(data.Key); &#125; &#125; &#125; &#125; //移除节点字典中的对应节点数据 _eventNode.Remove(id); &#125; &#125; /// &lt;summary&gt; /// 触发某个事件 /// &lt;/summary&gt; /// &lt;param name=&quot;eventName&quot;&gt;事件名&lt;/param&gt; /// &lt;param name=&quot;obj&quot;&gt;参数列表，可以为空，但是记得在回调函数里面对该参数进行判空处理&lt;/param&gt; public static void TriggerEvent(string eventName, ArrayList obj) &#123; if (_eventDictionary.ContainsKey(eventName)) &#123; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(eventName, out eventDic); if (eventDic != null) &#123; EventData triggerEvent = null; foreach (var data in eventDic) &#123; triggerEvent = data.Value; triggerEvent.Triggered(obj); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 粘性通知 /// &lt;/summary&gt; /// &lt;param name=&quot;eventName&quot;&gt;通知名&lt;/param&gt; /// &lt;param name=&quot;obj&quot;&gt;数据&lt;/param&gt; /// &lt;param name=&quot;isArray&quot;&gt;是否队列&lt;/param&gt; public static void TriggerEventSticky(string eventName, ArrayList obj, bool isArray = false) &#123; if (_eventDictionary.ContainsKey(eventName)) &#123; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(eventName, out eventDic); if (eventDic != null) &#123; EventData triggerEvent = null; foreach (var data in eventDic) &#123; triggerEvent = data.Value; triggerEvent.Triggered(obj); &#125; &#125; &#125; else &#123; //保存通知内容 bool arrayFlag; _stickyArrayFlag.TryGetValue(eventName, out arrayFlag); if (isArray) &#123; arrayFlag = true; ArrayList res; _stickyDic.TryGetValue(eventName, out res); if (res == null) &#123; res = new ArrayList(); _stickyDic.Add(eventName, res); _stickyArrayFlag.Add(eventName, arrayFlag); &#125; //else //&#123; // _stickyDic[eventName] = res; // _stickyArrayFlag[eventName] = arrayFlag; //&#125; res.Add(obj); &#125; else &#123; arrayFlag = false; if (_stickyDic.ContainsKey(eventName)) &#123; _stickyDic[eventName] = obj; &#125; else &#123; _stickyDic.Add(eventName, obj); &#125; if (arrayFlag) &#123; _stickyArrayFlag[eventName] = arrayFlag; &#125; else &#123; if (!_stickyArrayFlag.ContainsKey(eventName)) &#123; _stickyArrayFlag.Add(eventName, arrayFlag); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ## 其他版本 Laya 版本","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"}]},{"title":"Laya自定义事件系统","slug":"Laya自定义事件系统","date":"2023-08-23T15:18:02.000Z","updated":"2024-05-18T15:37:40.642Z","comments":true,"path":"article/1099d6589f61/","link":"","permalink":"https://busyogg.github.io/article/1099d6589f61/","excerpt":"","text":"基本原理在事件传递的过程中设置一个中间对象，负责管理监听者和发送者，以达到解耦合的目的。 首先我们定义一个方法来注册监听对象，该对象包含节点（即作用域）、事件名和事件函数，然后我们在事件触发的时候调用触发函数，来触发所有监听该事件的对象。触发函数包含事件名和参数。 此处我们以字典 _eventDic 来存储监听对象，以事件名作为字典的 key，在字典里我们以作用域为 key 定义另一个字典，防止同名事件冲突以及同作用域事件重复添加。 同时，由于我们需要一个清除节点上所有事件的方法，因此我们单独设置一个字典 _nodeEventDic 用来保存节点和事件的关系。在清除节点上所有事件的时候只需要遍历该字典 _nodeEventDic 中对应作用域（传入的 node）的事件并且从事件字典 _eventDic 中查找对应的事件对象及其作用域即可。 具体的调用过程如下图所示： 这就是最基本的事件系统。 粘性通知为了防止部分情况中出现通知不到位的情况（即先通知后监听），这里我们引入了粘性通知的功能。 此处我们定义一个字典 _stickyArr 来保存通知的内容，这里我们分为两种情况，一种情况是该粘性通知只需要通知一次，则我们只需要让新的通知覆盖旧的通知；另一种是需要多次通知，则我们设置一个数组来保存多次通知的内容。 粘性通知和普通通知的触发事件逻辑相似，可以说前半部分的代码和普通通知一样，只不过我们增设一个通知标识符，用于判断是否通知到位，若没有通知到位，则进入粘性通知内容保存的流程。 注册监听者的部分代码也有改动，在注册完成后，若从粘性通知字典 _stickyArr 取到对应事件名的内容，则立刻进行一次通知，通知结束后删除对应的内容。 简单来说，粘性通知就是在监听和通知这两个过程之后增加一个判断，对于监听者来说，就是要判断有无通知的内容，而对于通知来说，就是判断是否有监听者监听过该通知内容。 代码事件数据类1234567891011export default class EventInfo &#123; public node; public event: Function; public type: string; constructor(node, type: string, event: Function) &#123; this.node = node; this.event = event; this.type = type; &#125;&#125; 事件管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import EventInfo from &quot;../bean/EventInfo&quot;;export default class EventManager &#123; /** 事件id */ private static _eventId = 1; /** 事件字典 类型-节点-事件 */ private static _eventDic = &#123;&#125;; /** 节点对应事件 节点-事件 */ private static _nodeEventDic = &#123;&#125;; /** 粘性通知字典 */ private static _stickyArr = &#123;&#125;; /** * 发送监听 * @param type 监听类型 * @param data 发送的数据 */ public static dispatchEvent(type, data): void &#123; for (let key in this._eventDic[type]) &#123; let event = this._eventDic[type][key] as EventInfo; event.event.call(event.node, data); &#125; &#125; /** * 粘性通知 * @param type * @param data */ public static dispatchEventSticky(type, data, isArr?) &#123; let eventOk = false; //普通通知部分 for (let key in this._eventDic[type]) &#123; let event = this._eventDic[type][key] as EventInfo; event.event.call(event.node, data); eventOk = true; &#125; //如果没有执行普通通知，则保存通知内容 if (!eventOk) &#123; if (isArr) &#123; if (!this._stickyArr[type]) &#123; this._stickyArr[type] = []; &#125; this._stickyArr[type].push(data); &#125; else &#123; this._stickyArr[type] = data; &#125; &#125; &#125; /** * 注册监听 * @param node 监听的节点 * @param type 监听类型 * @param event 监听事件 */ public static onEvent(node, type: string, event: Function) &#123; var obj = new EventInfo(node, type, event); if (!this._eventDic[type]) &#123; this._eventDic[type] = &#123;&#125;; &#125; //如果节点上没有事件id，则添加 if (node.eventId == undefined) &#123; node.eventId = &quot;event_&quot; + this._eventId++; &#125; //添加事件 this._eventDic[type][node.eventId] = obj; //获取粘性通知数据 let data = this._stickyArr[type]; if (data) &#123; //根据是否数组决定是否多次执行事件 if (data.length) &#123; let event = this._eventDic[type][node.eventId] as EventInfo; for (let i = 0, len = data.length; i &lt; len; i++) &#123; event.event.call(event.node, data[i]); &#125; delete this._stickyArr[type]; &#125; else &#123; let event = this._eventDic[type][node.eventId] as EventInfo; event.event.call(event.node, data); delete this._stickyArr[type]; &#125; &#125; //汇总节点上的所有事件 if (!this._nodeEventDic[node.eventId]) &#123; this._nodeEventDic[node.eventId] = &#123;&#125;; &#125; this._nodeEventDic[node.eventId][type] = true; &#125; /** * 清除某一节点上的所有监听 * @param node */ public static offAllEventByNode(node) &#123; if (!node || !this._nodeEventDic[node.eventId]) return; for (let key in this._nodeEventDic[node.eventId]) &#123; delete this._eventDic[key][node.eventId]; if (Object.keys(this._eventDic[key]).length == 0) &#123; delete this._eventDic[key]; &#125; &#125; delete this._nodeEventDic[node.eventId]; &#125;&#125; 其他版本Unity 版本","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"}]},{"title":"关于Laya对接微信开放域的问题","slug":"关于Laya对接微信开放域的问题","date":"2023-08-23T15:09:11.000Z","updated":"2024-05-30T12:24:44.916Z","comments":true,"path":"article/fcfc4d29d0e4/","link":"","permalink":"https://busyogg.github.io/article/fcfc4d29d0e4/","excerpt":"","text":"Laya 对接微信开放域可以新建开放域项目来创建一个范例，开放域项目打包的时候不会打包资源文件，因此要在主域提前加载对应的资源文件并传递给开放域，能传递的有两种类型，一是 ui 图集，二是 json，亮着调用不同接口例： 12345678Laya.loader.load( &quot;res/atlas/rank.atlas&quot;, Laya.Handler.create(this, (res) =&gt; &#123; Laya.MiniAdpter.sendAtlasToOpenDataContext(&quot;res/atlas/rank.atlas&quot;); //json //Laya.MiniAdpter.sendJsonDataToDataContext() &#125;)); 展示子域的时候 laya 会自动设置 canvas，但是子域一旦有嵌套层级，该方法就会产生偏移，解决方法为： 调整子域对象层级到根层级 手动触发changeMatrix事件。注意，如果手动触发该事件，则需要按照源码对应的格式构造传递的参数。例： 123456789101112//此处canvasData为自定义对象，包含matrix，width，height三个属性，可以不需要按照此处代码构建对象，但一定要传入对应属性的参数this.openData.postMsg(&#123; type: &quot;changeMatrix&quot;, a: canvasData.matrix.a, b: canvasData.matrix.b, c: canvasData.matrix.c, d: canvasData.matrix.d, tx: canvasData.matrix.tx, ty: canvasData.matrix.ty, w: canvasData.width, h: canvasData.height,&#125;); 注意，如果要手动触发该事件，则需要延迟一帧的时间，防止 UI 界面还没有自动适配好宽高导致传入的 canvas 坐标偏移","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"解决方案","slug":"Laya/解决方案","permalink":"https://busyogg.github.io/categories/Laya/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"微信开放域","slug":"微信开放域","permalink":"https://busyogg.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%9F%9F/"},{"name":"解决方案","slug":"解决方案","permalink":"https://busyogg.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"关于LAYA编译await/async语法报错的问题","slug":"关于LAYA编译await-async语法报错的问题","date":"2023-08-23T14:52:19.000Z","updated":"2024-05-18T15:40:12.187Z","comments":true,"path":"article/810371225f39/","link":"","permalink":"https://busyogg.github.io/article/810371225f39/","excerpt":"","text":"在项目中安装 tslib 即可，可以在 vscode 终端中输入 npm install tslib 或者在 tsconfig.js 中配置添加 lib，promise（未测试）","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"Bug","slug":"Laya/Bug","permalink":"https://busyogg.github.io/categories/Laya/Bug/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Bug","slug":"Bug","permalink":"https://busyogg.github.io/tags/Bug/"}]},{"title":"Jszip在Laya引擎上的应用","slug":"Jszip在Laya引擎上的应用","date":"2023-08-23T13:17:56.000Z","updated":"2024-05-18T15:37:55.728Z","comments":true,"path":"article/47f96467aabe/","link":"","permalink":"https://busyogg.github.io/article/47f96467aabe/","excerpt":"","text":"小游戏平台对于资源的大小限制很严格， 在 OV 平台上，由于快游戏本身自带压缩机制，所以包体大小的问题相对不是那么严重。在微信平台上，包体是没有压缩的。一般来说有两种解决方案， 一个是把资源放在云端，还有一个就是压缩本地资源。 在资源很多但又不是那么多的情况下，我们可以采用压缩包的方式存储资源。有的平台有文件读写的接口，有的没有。为了通用性，我们采取解压到内存中的方式。通过 jszip，我们可以很好的压缩和解压文件。 Laya 引擎中有多重不同的文件格式，解压压缩文件到内存中的时候其实就是读取文件并格式化，然后保存到 Laya 的缓存系统中，通过缓存读取文件的时候就能够直接读取到我们解压到内存中的内容。不过，由于机制问题，暂时还不支持天空盒的格式化，因此天空盒目前还只能放在本地。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337export default class ZipManager &#123; private static instance: ZipManager; public static getInstance(): ZipManager &#123; if (!this.instance) &#123; return new ZipManager(); &#125; return this.instance; &#125; public loadZip(resurl: string, cacheUrl: string, callback: Function): void &#123; var zip = Laya.loader.getRes(resurl); if (!zip) &#123; Laya.loader.load( [&#123; type: Laya.Loader.BUFFER, url: resurl &#125;], Laya.Handler.create(this, function (data) &#123; Laya.loader.cacheRes(cacheUrl, Laya.loader.getRes(resurl)); Laya.loader.clearRes(resurl); if (callback) &#123; callback(); &#125; &#125;) ); &#125; else &#123; callback(); &#125; &#125; public loadZipFiles( resUrl: string, cacheUrl: string, callback: Function ): void &#123; // console.log(&quot;0----------&quot;,Laya.Browser.window); var self = this; let skyBox; let jsZip = new JSZip(); let zipBuff = Laya.loader.getRes(resUrl); let resources = &#123;&#125;; // console.log(&quot;测试压缩包&quot;); var loadZipComplete = function () &#123; Laya.loader.clearRes(resUrl); callback(); &#125;; //获取ZIP包内容传入JSZip中解析 jsZip.loadAsync(zipBuff).then((data) =&gt; &#123; //保存文件路径到数组 for (let file in data.files) &#123; // console.log(&quot;------------file&quot;, data.files[file]); if (!data.files[file].dir) &#123; if (file.indexOf(&quot;.lh&quot;) != -1) &#123; //存入模型文件 if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; else if (file.indexOf(&quot;.png&quot;) != -1 || file.indexOf(&quot;.jpg&quot;) != -1) &#123; //存入图片 if (!resources[&quot;image&quot;]) &#123; resources[&quot;image&quot;] = []; &#125; resources[&quot;image&quot;].push(file); &#125; else if (file.indexOf(&quot;.json&quot;) != -1) &#123; //存入json if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; else if (file.indexOf(&quot;.csv&quot;) != -1) &#123; //存入csv if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; else if ( file.indexOf(&quot;.lm&quot;) != -1 || file.indexOf(&quot;.ltc&quot;) != -1 || file.indexOf(&quot;.lmat&quot;) != -1 || //存入网格 天空盒材质解析文件 材质 file.indexOf(&quot;.lani&quot;) != -1 ) &#123; if (!resources[&quot;mat&quot;]) &#123; resources[&quot;mat&quot;] = []; &#125; if (file.indexOf(&quot;.ltc&quot;) != -1) &#123; let fileParts = file.split(&quot;/&quot;); let name = fileParts[fileParts.length - 1].replace(&quot;.ltc&quot;, &quot;&quot;); skyBox = name; &#125; resources[&quot;mat&quot;].push(file); &#125; else &#123; //存入其他 if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; &#125; &#125; loadImage(); &#125;); //格式化文件并存入缓存 let subCount = 0; let subTotal = 0; let loadImage = () =&gt; &#123; if (resources[&quot;image&quot;]) &#123; for (let key in resources[&quot;image&quot;]) &#123; subTotal++; let file = resources[&quot;image&quot;][key]; jsZip .file(file) .async(&quot;base64&quot;) .then((content: any) =&gt; &#123; let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; let imgBase64; if (file.indexOf(&quot;.png&quot;) != -1) &#123; imgBase64 = &quot;data:image/png;base64,&quot; + content; &#125; else &#123; imgBase64 = &quot;data:image/jpg;base64,&quot; + content; &#125; let image: HTMLImageElement = document.createElement(&quot;img&quot;); let onImageLoaded: EventListenerOrEventListenerObject = () =&gt; &#123; image.removeEventListener(&quot;load&quot;, onImageLoaded); //接下来就可以把贴图对象赋值给材质了 if (skyBox &amp;&amp; file.indexOf(skyBox) != -1) &#123; // skyBox = null; Laya.loader.cacheRes(cacheUrl + &quot;/&quot; + file, image); &#125; else &#123; let texture: Laya.Texture2D = new Laya.Texture2D(); texture.loadImageSource(image); Laya.loader.cacheRes(cacheUrl + &quot;/&quot; + file, texture); // console.log(&quot;图片纹理&quot;, Laya.loader.getRes(cacheUrl + &quot;/&quot; + file)); &#125; subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadLm(); &#125; &#125;; image.addEventListener(&quot;load&quot;, onImageLoaded); image.src = imgBase64; &#125;); &#125; &#125; else &#123; loadLm(); &#125; &#125;; let loadLm = () =&gt; &#123; if (resources[&quot;mat&quot;]) &#123; for (let key in resources[&quot;mat&quot;]) &#123; subTotal++; let file = resources[&quot;mat&quot;][key]; if (file.indexOf(&quot;.ltc&quot;) != -1) &#123; jsZip .file(file) .async(&quot;text&quot;) .then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create( cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadOther(); &#125; &#125;) ); &#125;); &#125; else if (file.indexOf(&quot;.lmat&quot;) != -1) &#123; jsZip .file(file) .async(&quot;text&quot;) .then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create( cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;,file, rses); subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadOther(); &#125; &#125;) ); &#125;); &#125; else &#123; jsZip .file(file) .async(&quot;uint8array&quot;) .then((content: any) =&gt; &#123; let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; data.json[cacheUrl + &quot;/&quot; + file] = content; func.call(Laya.Loader, data); Laya.loader.create( cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadOther(); &#125; &#125;) ); &#125;); &#125; &#125; &#125; else &#123; loadOther(); &#125; &#125;; let loadOther = () =&gt; &#123; for (let key in resources[&quot;other&quot;]) &#123; subTotal++; let file = resources[&quot;other&quot;][key]; if (file.indexOf(&quot;.lh&quot;) != -1) &#123; jsZip .file(file) .async(&quot;text&quot;) .then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create( cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;,file, res); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;) ); &#125;); &#125; else if (file.indexOf(&quot;.json&quot;) != -1) &#123; jsZip .file(file) .async(&quot;text&quot;) .then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create( cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;) ); &#125;); &#125; else if (file.indexOf(&quot;.csv&quot;) != -1) &#123; jsZip .file(file) .async(&quot;text&quot;) .then((content: any) =&gt; &#123; Laya.loader.cacheRes(cacheUrl + &quot;/&quot; + file, content); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;); &#125; else &#123; jsZip .file(file) .async(&quot;uint8array&quot;) .then((content: any) =&gt; &#123; let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125;; data.json[cacheUrl + &quot;/&quot; + file] = content; func.call(Laya.Loader, data); Laya.loader.create( cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;) ); &#125;); &#125; &#125; &#125;; &#125;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"Jszip","slug":"Jszip","permalink":"https://busyogg.github.io/tags/Jszip/"}]},{"title":"Laya进度条shader","slug":"Laya进度条shader","date":"2023-08-23T13:17:56.000Z","updated":"2024-05-18T15:37:46.314Z","comments":true,"path":"article/23513e7655b5/","link":"","permalink":"https://busyogg.github.io/article/23513e7655b5/","excerpt":"","text":"原理 根据传入的进度[0,1]剔除对应颜色值 RGB 之一的像素，上图为进度条所需的从颜色值 0 到颜色值 1 的贴图（透明底图，进度条的圈为从白到黑的不透明圆环）。 此代码负责剔除一定颜色值的像素，利用 step 函数的原理（step(a,b)，当 b&gt;&#x3D;a 时返回 1，否则返回 0），其中 1.0-col.r 决定进度条动画的方向，代表从白向黑，也可以直接使用 col.r 从黑向白。 1float colorMinus = step(1.0-col.r,u_progress); 这段代码包括两个部分，前面的部分决定进度条的颜色，后面的部分决定背景的颜色，我们可以从加号的地方拆开来看。前面的部分构造了一个三维向量，假如 colorMinus 为 1，则前面的向量就是全 1，此时和传入的进度条颜色值相乘可得进度条的颜色。后面构造了一个和前面相反的三维向量，此时后面的向量为全 0，和传入的背景颜色相乘依然是 0。 由此可得，当此处的像素筛选为进度条的时候，进度条的颜色值发挥作用，而背景颜色值不发挥作用；相反，此处像素筛选为背景时，进度条颜色值不发挥作用而背景颜色值发挥作用。为什么要这么做呢，因为 GPU 运算的时候是大量并行的，条件判断语句对于 GPU 来说每个分支都要执行，性能会有损失。 12vec4 final = vec4(colorMinus);final.xyz = vec3(colorMinus) * u_edgeColor.xyz + vec3(1.0-colorMinus) * u_bgColor.xyz; 只有上述代码的话，运行时的效果并不能符合我们的需要，进度条之外的像素也会有填充。因此我们需要对透明度进行剔除。 1final.a = (step(1.0-col.a,0.0) * colorMinus * u_edgeColor.a) + step(colorMinus,0.0) * u_bgColor.a; 由于我们支持自定义进度条和进度条背景的透明度，因此这两个部分也需要进行处理。 关于进度条的透明度，起判断的部分只有 colorMinus * u_edgeColor.a。为什么要乘上 step(1.0-col.a,0.0)呢，主要是为了筛去透明的部分，col.a 是原材质贴图的透明度，当其为 1 的时候（不透明）所得值为 0，step(1.0-col.a,0.0)的值才为 1，进度条的颜色才生效。当然这里可以设置为你所需要的任意值。 关于背景的透明度，和进度条同理可得 step(colorMinus,0.0) * u_bgColor.a。 进度条 shader 代码片元着色器12345678910111213141516171819202122#ifdef FSHIGHPRECISION precision highp float;#else precision mediump float;#endifuniform sampler2D u_DiffuseTexture;uniform float u_progress;uniform vec4 u_edgeColor;uniform vec4 u_bgColor;varying vec2 v_Texcoord0;void main()&#123; vec4 col = texture2D(u_DiffuseTexture, v_Texcoord0); float colorMinus = step(1.0-col.r,u_progress); vec4 final = vec4(colorMinus); final.xyz = vec3(colorMinus) * u_edgeColor.xyz + vec3(1.0-colorMinus) * u_bgColor.xyz; final.a = (step(1.0-col.a,0.0) * colorMinus * u_edgeColor.a) + step(colorMinus,0.0) * u_bgColor.a; gl_FragColor = final;&#125; 顶点着色器1234567891011121314#include &quot;Lighting.glsl&quot;;attribute vec4 a_Position;attribute vec2 a_Texcoord0;varying vec2 v_Texcoord0;uniform mat4 u_MvpMatrix;uniform vec4 u_TilingOffset;void main()&#123; v_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset); gl_Position=remapGLPositionZ(gl_Position);&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"Shader","slug":"Laya/Shader","permalink":"https://busyogg.github.io/categories/Laya/Shader/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"Opengl","slug":"Opengl","permalink":"https://busyogg.github.io/tags/Opengl/"}]},{"title":"关于Laya 2.13版本 粒子特效内存泄漏问题","slug":"关于Laya-2-13版本-粒子特效内存泄漏问题","date":"2023-08-23T13:17:56.000Z","updated":"2024-05-18T15:40:13.707Z","comments":true,"path":"article/07675fbaf5d8/","link":"","permalink":"https://busyogg.github.io/article/07675fbaf5d8/","excerpt":"","text":"该版本的粒子有两类，支持 GPUInstance 的 ShurikenParticleInstance 和 ShurikenParticle，前者在不停创建销毁的过程中在统计面板上会累计内存增长，看上去和内存泄漏一样。其原因为销毁对象的时候没有对_instanceParticleVertexBuffer 对象进行内存统计。 解决方案 在 destroy()方法中针对_instanceParticleVertexBuffer 改为如下内容 123456if (this._instanceParticleVertexBuffer) &#123; var memorySize = this._instanceParticleVertexBuffer._byteLength; Laya.Resource._addMemory(-memorySize, -memorySize); this._instanceParticleVertexBuffer.destroy(); this._instanceParticleVertexBuffer = null;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"Bug","slug":"Laya/Bug","permalink":"https://busyogg.github.io/categories/Laya/Bug/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Bug","slug":"Bug","permalink":"https://busyogg.github.io/tags/Bug/"}]}],"categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"},{"name":"Shader","slug":"Unity/Shader","permalink":"https://busyogg.github.io/categories/Unity/Shader/"},{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"},{"name":"设计思路","slug":"设计思路","permalink":"https://busyogg.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"},{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"},{"name":"逆向运动学","slug":"算法/逆向运动学","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"Hexo","slug":"教程/Hexo","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/Hexo/"},{"name":"解决方案","slug":"Laya/解决方案","permalink":"https://busyogg.github.io/categories/Laya/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Bug","slug":"Laya/Bug","permalink":"https://busyogg.github.io/categories/Laya/Bug/"},{"name":"Shader","slug":"Laya/Shader","permalink":"https://busyogg.github.io/categories/Laya/Shader/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"框架","slug":"框架","permalink":"https://busyogg.github.io/tags/%E6%A1%86%E6%9E%B6/"},{"name":"VisualElement","slug":"VisualElement","permalink":"https://busyogg.github.io/tags/VisualElement/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"线段","slug":"线段","permalink":"https://busyogg.github.io/tags/%E7%BA%BF%E6%AE%B5/"},{"name":"GraphView","slug":"GraphView","permalink":"https://busyogg.github.io/tags/GraphView/"},{"name":"脚本","slug":"脚本","permalink":"https://busyogg.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://busyogg.github.io/tags/ffmpeg/"},{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Cloudflare","slug":"Cloudflare","permalink":"https://busyogg.github.io/tags/Cloudflare/"},{"name":"IMGUI","slug":"IMGUI","permalink":"https://busyogg.github.io/tags/IMGUI/"},{"name":"Untiy","slug":"Untiy","permalink":"https://busyogg.github.io/tags/Untiy/"},{"name":"序列化","slug":"序列化","permalink":"https://busyogg.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"字典","slug":"字典","permalink":"https://busyogg.github.io/tags/%E5%AD%97%E5%85%B8/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"胶囊体","slug":"胶囊体","permalink":"https://busyogg.github.io/tags/%E8%83%B6%E5%9B%8A%E4%BD%93/"},{"name":"UI","slug":"UI","permalink":"https://busyogg.github.io/tags/UI/"},{"name":"反射","slug":"反射","permalink":"https://busyogg.github.io/tags/%E5%8F%8D%E5%B0%84/"},{"name":"特性","slug":"特性","permalink":"https://busyogg.github.io/tags/%E7%89%B9%E6%80%A7/"},{"name":"Attribute","slug":"Attribute","permalink":"https://busyogg.github.io/tags/Attribute/"},{"name":"对象存储","slug":"对象存储","permalink":"https://busyogg.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"},{"name":"OSS","slug":"OSS","permalink":"https://busyogg.github.io/tags/OSS/"},{"name":"定点数","slug":"定点数","permalink":"https://busyogg.github.io/tags/%E5%AE%9A%E7%82%B9%E6%95%B0/"},{"name":"确定性","slug":"确定性","permalink":"https://busyogg.github.io/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7/"},{"name":"解决方案","slug":"解决方案","permalink":"https://busyogg.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"渲染","slug":"渲染","permalink":"https://busyogg.github.io/tags/%E6%B8%B2%E6%9F%93/"},{"name":"物理","slug":"物理","permalink":"https://busyogg.github.io/tags/%E7%89%A9%E7%90%86/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://busyogg.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://busyogg.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"FRP","slug":"FRP","permalink":"https://busyogg.github.io/tags/FRP/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://busyogg.github.io/tags/ChatGPT/"},{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"IK","slug":"IK","permalink":"https://busyogg.github.io/tags/IK/"},{"name":"Fabrik","slug":"Fabrik","permalink":"https://busyogg.github.io/tags/Fabrik/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"射线","slug":"射线","permalink":"https://busyogg.github.io/tags/%E5%B0%84%E7%BA%BF/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"},{"name":"SAT分离轴","slug":"SAT分离轴","permalink":"https://busyogg.github.io/tags/SAT%E5%88%86%E7%A6%BB%E8%BD%B4/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ECS","slug":"ECS","permalink":"https://busyogg.github.io/tags/ECS/"},{"name":"四叉树","slug":"四叉树","permalink":"https://busyogg.github.io/tags/%E5%9B%9B%E5%8F%89%E6%A0%91/"},{"name":"空间管理","slug":"空间管理","permalink":"https://busyogg.github.io/tags/%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"},{"name":"SSL证书","slug":"SSL证书","permalink":"https://busyogg.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"},{"name":"GitHub","slug":"GitHub","permalink":"https://busyogg.github.io/tags/GitHub/"},{"name":"网络加速","slug":"网络加速","permalink":"https://busyogg.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://busyogg.github.io/tags/Hexo/"},{"name":"微信开放域","slug":"微信开放域","permalink":"https://busyogg.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%9F%9F/"},{"name":"Bug","slug":"Bug","permalink":"https://busyogg.github.io/tags/Bug/"},{"name":"Jszip","slug":"Jszip","permalink":"https://busyogg.github.io/tags/Jszip/"},{"name":"Opengl","slug":"Opengl","permalink":"https://busyogg.github.io/tags/Opengl/"}]}