{"meta":{"title":"Busyo's Blog","subtitle":"Busyo的博客","description":"Busyo的博客，分享记录与思考","author":"Busyo","url":"https://busyogg.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2023-08-24T10:07:23.840Z","updated":"2023-08-24T10:07:23.840Z","comments":true,"path":"categories/index.html","permalink":"https://busyogg.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-01-27T20:05:02.675Z","updated":"2024-01-27T20:05:02.675Z","comments":true,"path":"script/AfterProcess.js","permalink":"https://busyogg.github.io/script/AfterProcess.js","excerpt":"","text":"window.AfterProcess = { ResetCodeStyle: () => { var eles = document.getElementsByClassName(\"highlight\"); var colors = [ \"#ed6a5e\", \"#f5bd4f\", \"#61c454\" ] for (let i = 0, len = eles.length; i < len; i++) { let child = eles[i].firstChild; //创建按钮 let customDiv = document.createElement(\"div\"); customDiv.style.display = \"flex\"; customDiv.style.height = \"40px\"; customDiv.style.width = \"100%\"; for (let j = 0; j < 3; j++) { let btn = document.createElement(\"div\"); btn.style.backgroundColor = colors[j]; btn.style.height = \"20px\"; btn.style.width = \"20px\"; btn.style.border = \"1px solid \" + colors[j]; btn.style.borderRadius = \"10px\"; btn.style.margin = \"10px 5px 10px 5px\"; customDiv.appendChild(btn); } console.log(\"是否匹配\", child.nodeName); if (child.nodeName != \"FIGCAPTION\") { //没有标题 eles[i].insertBefore(customDiv, child); } else { eles[i].replaceChild(customDiv, child); //有标题 let p = document.createElement(\"p\"); p.style.width = (customDiv.offsetWidth - 40 * 3) + \"px\"; p.style.height = \"40px\"; p.style.textAlign = \"center\"; p.style.margin = \"0px\"; p.style.lineHeight = \"40px\"; p.innerText = child.firstChild.innerText; p.style.fontSize = \"20px\"; customDiv.appendChild(p); } } }, ResetTitle: ()=>{ let colors = { \"H1\":\"#61c454\", \"H2\":\"#61c454\", \"H3\":\"#f5bd4f\", \"H4\":\"#ed6a5e\", \"H5\":\"#e40056\", \"H6\":\"#029ae2\", } var eles = document.querySelectorAll(\"h1,h2,h3,h4,h5,h6\"); var picker = window.getComputedStyle; for (let i = 1, len = eles.length; i < len; i++) { let child = eles[i].firstChild; let eleStyle = picker(eles[i]); //创建标识 let customDiv = document.createElement(\"div\"); customDiv.style.display = \"flex\"; customDiv.style.width = \"15px\"; customDiv.style.backgroundColor = colors[eles[i].tagName]; customDiv.style.height = eleStyle.fontSize; customDiv.style.marginRight = \"10px\"; customDiv.style.marginTop = (parseFloat(eleStyle.lineHeight) - parseFloat(eleStyle.fontSize)) * 0.5 + \"px\"; customDiv.style.borderRadius = \"5px\"; // console.log(\"字体大小\",eleStyle.fontSize,parseFloat(eleStyle.lineHeight),parseFloat(eleStyle.fontSize)) // customDiv.style.verticalAlign eles[i].style.display = \"flex\"; eles[i].style.verticalAlign = \"center\" eles[i].insertBefore(customDiv, child); } }, Init: () => { console.log(\"初始化界面\"); AfterProcess.ResetCodeStyle(); AfterProcess.ResetTitle(); } } AfterProcess.Init();"},{"title":"所有标签","date":"2023-08-24T10:08:12.138Z","updated":"2023-08-24T10:08:12.138Z","comments":true,"path":"tags/index.html","permalink":"https://busyogg.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-08-31T17:58:45.623Z","updated":"2023-08-31T17:58:45.623Z","comments":true,"path":"script/marked.min.js","permalink":"https://busyogg.github.io/script/marked.min.js","excerpt":"","text":"/** * marked v4.3.0 - a markdown parser * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed) * https://github.com/markedjs/marked */ !function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=\"undefined\"!=typeof globalThis?globalThis:e||self).marked={})}(this,function(r){\"use strict\";function i(e,t){for(var u=0;u"}],"posts":[{"title":"定点数原理","slug":"定点数原理","date":"2024-01-27T09:48:46.000Z","updated":"2024-01-27T21:21:14.034Z","comments":true,"path":"article/fbf1414ac525/","link":"","permalink":"https://busyogg.github.io/article/fbf1414ac525/","excerpt":"","text":"简介在某些情况下，我们需要保证同样的输入得到同样的结果。因此我们要么使用整形，要么就使用定点数。 本文主要介绍定点数的原理。 什么是定点数定点数是指小数点位置固定的数，用整数来表示小数。所以本质上，定点数的运算其实就是整数的运算。由于浮点数使用的是科学计数法来表示，还原成数字的时候会产生误差，因此使用整数运算的定点数不会产生精度误差。 定点数原理我们约定定点数的名字叫做FP。 定点数表示本文定点数用long长整型来表示。长整型一共64位，最高位表示符号，除符号位外，前31位表示整数部分，后32位表示小数部分。 定点数运算类型转换加法减法乘法除法求余其他运算符首先我们定义一个基本单位，用于计算。 12public const int FRACTIONAL_PLACES = 32;public const long ONE = 1L &lt;&lt; FRACTIONAL_PLACES; ONE代表FP的一个单位大小，所以我们在类型转换的时候通过原来的数值大小乘以ONE，就可以得到转变为FP类型之后的值。 在二进制的视角下，就相当于原来的数左移了32位。 浮点数转换的时候需要显示转换为long。 从FP转换到其他类型的话只要进行相反的操作，即除以ONE，然后如果是int类型就在计算完后显示转换为int，如果是浮点类型就提前显示转换为浮点类型即可。 通过重载类型转换，我们可以在使用的时候更方便地进行类型转换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public FP(long value)&#123; _value = value;&#125;public static implicit operator FP(long value)&#123; FP res; res._value = value * ONE; return res;&#125;public static implicit operator FP(int value)&#123; FP res; res._value = value * ONE; return res;&#125;public static implicit operator FP(float value)&#123; FP res; res._value = (long)(value * ONE); return res;&#125;public static implicit operator FP(double value)&#123; FP res; res._value = (long)(value * ONE); return res;&#125;public static explicit operator int(FP fp)&#123; return (int)(fp._value / ONE);&#125;public static explicit operator long(FP fp)&#123; return fp._value &gt;&gt; FRACTIONAL_PLACES;&#125;public static explicit operator float(FP fp)&#123; return (float)fp._value / ONE;&#125;public static explicit operator double(FP fp)&#123; return (double)fp._value / ONE;&#125; 我们只要通过如下方法，就可以得到FP数： 12FP num = 1;FP num2 = 1.1f;我们重载加法运算符。 加法只要把两个FP的值相加，得到一个新的值即可。 如果相加之后出现超出FP能表示的最大位数，则该结果溢出，所以我们需要进行溢出判断。 溢出判断主要是对符号位进行检测。 首先我们通过异或判断 xl ^ yl 两个参数的符号位是否相同，相同情况得到的结果，符号位为0，否则为1。 然后我们对该结果取反，即我们检测两个参数为同号的情况。因为只有同号相加的情况，才会产生溢出，异号相加的结果只会在正负极限值之内。 接着我们判断 xl ^ sum 参数1与结果的符号是否相同（也可以用参数2）。 根据前面的结果，我们接下来判断 (~(xl ^ yl) &amp; (xl ^ sum)) 符号位是否相同。这里会出现两种结果： 两个参数同号：~(xl ^ yl) 符号位为1。由于溢出会使符号相反，因此如果 (xl ^ sum) 同号，即为0，不溢出，则在符号位上，1 &amp; 0 = 0；如果(xl ^ sum) 异号，即为1，溢出，则在符号位上，1 &amp; 1 = 1。 两个参数异号：~(xl ^ yl) 符号位为0，则符号位结果必为0。 5.最后我们跟Min_Value求与，Min_Value是float的最小数，即最高位符号位为1，其余都是0。这样就能单独比较符号位的结果是否为0，不是则溢出。 1234567891011121314public static FP operator +(FP x,FP y)&#123; var xl = x._value; var yl = y._value; var sum = xl + yl; //通过符号位判断溢出 if (((~(xl ^ yl) &amp; (xl ^ sum)) &amp; Min_Value) != 0) &#123; sum = xl &gt; 0 ? Max_Value : Min_Value; &#125; FP result; result._value = sum; return result;&#125;我们重载减法运算符。 加法只要把两个FP的值相减，得到一个新的值即可。 如果相加之后出现超出FP能表示的最大位数，则该结果溢出，所以我们需要进行溢出判断。 溢出判断主要是对符号位进行检测。 首先我们通过异或判断 xl ^ yl 两个参数的符号位是否相同，相同情况得到的结果，符号位为0，否则为1。 此处我们不对该结果取反，和加法相反。因为只有异号相减的情况，才会产生溢出，同号相减的结果只会在正负极限值之内。 接着我们判断 xl ^ sum 参数1与结果的符号是否相同（也可以用参数2）。 根据前面的结果，我们接下来判断 ((xl ^ yl) &amp; (xl ^ sum)) 符号位是否相同。这里会出现两种结果： 两个参数异号：(xl ^ yl) 符号位为1。由于溢出会使符号相反，因此如果 (xl ^ sum) 同号，即为0，不溢出，则在符号位上，1 &amp; 0 = 0；如果(xl ^ sum) 异号，即为1，溢出，则在符号位上，1 &amp; 1 = 1。 两个参数同号：(xl ^ yl) 符号位为0，则符号位结果必为0。 5.最后我们跟Min_Value求与，Min_Value是float的最小数，即最高位符号位为1，其余都是0。这样就能单独比较符号位的结果是否为0，不是则溢出。 1234567891011121314public static FP operator -(FP x, FP y)&#123; var xl = x._value; var yl = y._value; var diff = xl - yl; //通过符号位判断溢出 if ((((xl ^ yl) &amp; (xl ^ diff)) &amp; Min_Value) != 0) &#123; diff = xl &gt; 0 ? Max_Value : Min_Value; &#125; FP result; result._value = diff; return result;&#125;我们重载乘法运算符。 乘法运算我们分为两个部分，四个步骤进行。两个部分是整数部分和小数部分，四个步骤，是两个参数的整数和小数分别相乘。最后我们把得到的结果相加，就是乘法的结果了。 我们可以类比为竖式计算的过程，这样或许会更好理解。 比如 $1.1 \\times 1.1$ ,我们根据规则得到以下四个式子： $0.1 \\times 0.1 &#x3D; 0.01$ $1 \\times 0.1 &#x3D; 0.1$ $1 \\times 0.1 &#x3D; 0.1$ $1 \\times 1 &#x3D; 1$ 最后把结果加起来就是 $0.01+0.1+0.1+1&#x3D;1.21$ 我们对小数部分与0x00000000FFFFFFFF求与，得到小数部分表示为整数的值；对整数部分右移32位，得到正确的整数值（而不是定点数表示的整数值）。 小数部分相乘的情况下，得到的结果会变成64位，因此我们需要右移32位使其归位。 整数部分相乘的情况下，得到的结果左移32位，使其回到定点数表示的整数位置。 小数与整数相乘的情况下，不会使小数位数产生变化，进位的值也会自动进入整数位置，因此不需要进行操作。 接着我们逐个相加，每次相加都判断是否有溢出。 这里判断溢出的方式和加法不同，这里只需要判断同号的情况，因为我们已经把两个参数转为同号，所以只要判断两个参数和得到的结果是否同号即可。 最后我们通过之前判断的两个参数是否同号，决定乘法结果的正负。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static FP operator *(FP x, FP y)&#123; var xl = x._value; var yl = y._value; bool opSignsEqual = ((xl ^ yl) &amp; Min_Value) == 0; if (xl &lt; 0) &#123; xl = -xl; &#125; if(yl &lt; 0) &#123; yl = -yl; &#125; var xlo = (xl &amp; 0x00000000FFFFFFFF); var xhi = xl &gt;&gt; FRACTIONAL_PLACES; var ylo = (yl &amp; 0x00000000FFFFFFFF); var yhi = yl &gt;&gt; FRACTIONAL_PLACES; //分解计算过程 var lolo = xlo * ylo; var lohi = xlo * yhi; var hilo = xhi * ylo; var hihi = xhi * yhi; //修正位数 var loResult = lolo &gt;&gt; FRACTIONAL_PLACES; var midResult1 = hilo; var midResult2 = lohi; var hiResult = hihi &lt;&lt; FRACTIONAL_PLACES; bool overflow = false; var sum = AddOverflowHelper(loResult, midResult1, ref overflow); sum = AddOverflowHelper(sum, midResult2, ref overflow); sum = AddOverflowHelper(sum, hiResult, ref overflow); if(overflow) &#123; sum = Max_Value; &#125; if (!opSignsEqual) &#123; sum = -sum; &#125; FP result; result._value = sum; return result;&#125;/// &lt;summary&gt;/// 只在同号情况下有用，计算是否溢出/// &lt;/summary&gt;/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;overflow&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static long AddOverflowHelper(long x, long y, ref bool overflow)&#123; var sum = x + y; // x + y overflows if sign(x) ^ sign(y) != sign(sum) overflow |= ((x ^ y ^ sum) &amp; Min_Value) != 0; return sum;&#125;我们重载除法运算符。 除法的运算是模拟我们数学上除法的过程。 如果除数是0，直接返回最大值。 我们定义余数remainder，除数divider，商quotient，计算位数bitPos。 余数初始化为参数1，除数初始化为参数2，商初始化为0，计算位数初始化为33位。 然后我们开始计算： 先判断小数部分有没有多余的0，此处选择每次右移4位（2的4次幂），即一个十六进制0。这样可以快速移动到最小计算位数。 然后我们开始循环，如果有余数并且计算位数大于等于0的情况，我们就进行一次除法。 我们先获得余数前导零个数，然后和需要计算的位数进行比较，防止溢出。 然后我们左移余数，这一步是为了防止在循环的过程中余数不够位数参与运算。同时我们剩余的计算位数要减去左移的位数。 接着我们求商和余数，新的余数赋值给原来的余数，商根据左移位数同样移动并且加到总商上。 判断结果有没有溢出。 余数进位，继续循环。 商+1并右移一位，进行舍入。 最后判断是否异号，是的话符号位就取反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public static FP operator /(FP x, FP y)&#123; var xl = x._value; var yl = y._value; if (yl == 0) &#123; return Max_Value; //throw new DivideByZeroException(); &#125; var remainder = (ulong)(xl &gt;= 0 ? xl : -xl); var divider = (ulong)(yl &gt;= 0 ? yl : -yl); var quotient = 0UL; var bitPos = Num_Bit / 2 + 1; //加速除法，减少小数部分多余的0数量 // If the divider is divisible by 2^n, take advantage of it. while ((divider &amp; 0xF) == 0 &amp;&amp; bitPos &gt;= 4) &#123; divider &gt;&gt;= 4; bitPos -= 4; &#125; //除法计算 while (remainder != 0 &amp;&amp; bitPos &gt;= 0) &#123; //计算被除数前导零数量 int shift = CountLeadingZeroes(remainder); if (shift &gt; bitPos) &#123; shift = bitPos; &#125; //移动被除数到允许的最高位 remainder &lt;&lt;= shift; bitPos -= shift; //求商和余数 var div = remainder / divider; remainder = remainder % divider; //把商加到总商中 quotient += div &lt;&lt; bitPos; // Detect overflow //0xFFFFFFFFFFFFFFFF &gt;&gt; bitPos得到64-bitPos个1 //取反得到11100....（64-bitPos个0） //如果结果不为0，说明超出最大位数，溢出 if ((div &amp; ~(0xFFFFFFFFFFFFFFFF &gt;&gt; bitPos)) != 0) &#123; return ((xl ^ yl) &amp; Min_Value) == 0 ? MaxValue : MinValue; &#125; //前进一位 remainder &lt;&lt;= 1; --bitPos; &#125; // rounding ++quotient; var result = (long)(quotient &gt;&gt; 1); if (((xl ^ yl) &amp; Min_Value) != 0) &#123; result = -result; &#125; FP r; r._value = result; return r; //return new FP(result);&#125;/// &lt;summary&gt;/// 求前导0个数/// &lt;/summary&gt;/// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static int CountLeadingZeroes(ulong x)&#123; int result = 0; //如果最高四位（二进制）都为0，则左移四位，加速计算 while ((x &amp; 0xF000000000000000) == 0) &#123; result += 4; x &lt;&lt;= 4; &#125; //如果最高一位（二进制）为0，则左移一位 while ((x &amp; 0x8000000000000000) == 0) &#123; result += 1; x &lt;&lt;= 1; &#125; return result;&#125;我们重载求余运算符。 求余只增加一种情况判定，防止溢出，其他和原本的求余一样。 12345678910public static FP operator %(FP x, FP y)&#123; FP result; // 判断是否为特殊情况：被除数是最小负数且除数是-1 // 这种情况下整数溢出会导致结果为0 result._value = x._value == Min_Value &amp; y._value == -1 ? 0 : x._value % y._value; return result;&#125;1234567891011121314151617181920212223242526272829303132333435public static FP operator -(FP x)&#123; //负数比正数多表示一位，因此正数可以直接转为负数，而最小负数不能直接转为正数，而是转为最大正值 return x._value == Min_Value ? MaxValue : new FP(-x._value);&#125;public static bool operator ==(FP x, FP y)&#123; return x._value == y._value;&#125;public static bool operator !=(FP x, FP y)&#123; return x._value != y._value;&#125;public static bool operator &gt;(FP x, FP y)&#123; return x._value &gt; y._value;&#125;public static bool operator &lt;(FP x, FP y)&#123; return x._value &lt; y._value;&#125;public static bool operator &gt;=(FP x, FP y)&#123; return x._value &gt;= y._value;&#125;public static bool operator &lt;=(FP x, FP y)&#123; return x._value &lt;= y._value;&#125; 更新日志2024-01-28 补上引用内容 2024-01-28 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"定点数","slug":"定点数","permalink":"https://busyogg.github.io/tags/%E5%AE%9A%E7%82%B9%E6%95%B0/"},{"name":"确定性","slug":"确定性","permalink":"https://busyogg.github.io/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7/"}]},{"title":"逻辑与渲染分离","slug":"逻辑与渲染分离","date":"2024-01-22T18:00:49.000Z","updated":"2024-01-27T20:09:09.003Z","comments":true,"path":"article/ce948424ad1b/","link":"","permalink":"https://busyogg.github.io/article/ce948424ad1b/","excerpt":"","text":"简介逻辑与渲染分离，即逻辑运算为一个部分，渲染表现为一个部分。渲染表现依赖于逻辑运算的结果，但逻辑运算不会受到渲染表现的影响。 因此，逻辑与渲染可以获得不同的更新频率，通常是逻辑计算的频率要低于渲染，这样可以减少复杂逻辑的性能开销。 渲染表现在每两个逻辑帧之间进行插值，这样就能使画面平滑，不会因为低频逻辑更新而产生顿感。 实现如果项目结构是面向对象的话，可以考虑使用事件来通知渲染对象更新数据并插值，或者渲染对象持有逻辑对象，在更新的时候获取对应数据。 本例使用的是ECS的结构，因此只需要在渲染系统写好插值逻辑，系统自然会遍历更新。 如果目标位置或旋转有更新，直接重置上一位置和旋转为当前渲染对象的坐标和旋转，并重置插值进度为0。 更新插值进度。 根据上一位置或上一旋转和目标位置或目标旋转，进行lerp插值，然后赋值给渲染对象。 如果插值进度完成，则重置上一位置和旋转为当前渲染对象的坐标和旋转，并重置插值进度为0。 如果有缩放需求的也可以同理操作。 上图白色线框为逻辑包围盒位置，可以看出逻辑更新频率低的情况下有顿感，渲染对象的方块追逐逻辑位置插值靠近。 更新日志2024-01-23 更新基础内容。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"解决方案","slug":"解决方案","permalink":"https://busyogg.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"渲染","slug":"渲染","permalink":"https://busyogg.github.io/tags/%E6%B8%B2%E6%9F%93/"}]},{"title":"物理引擎Demo思路","slug":"物理引擎Demo思路","date":"2024-01-21T20:08:06.000Z","updated":"2024-01-27T20:09:15.300Z","comments":true,"path":"article/b83ee5a642c0/","link":"","permalink":"https://busyogg.github.io/article/b83ee5a642c0/","excerpt":"","text":"移动移动的时候只需要以对象坐标为基础，加上移动的方向和速度，即可得到下一个坐标。 碰撞在一帧移动完成后，检测最新位置是否有和其他物体碰撞，如果有的话： 计算碰撞法线，碰撞法线是其他物体被碰撞的面的法线。 计算碰撞深度。 当前位置 +&#x3D; 碰撞法线 * 碰撞深度。 这样就可以得到碰撞后应该在的位置。我称之为排斥。 多个碰撞体的情况设置一个向量 offset 用来记录排斥的值，每个碰撞物体的排斥值都要加到 offset 中。最后我们会得到一个总的排斥值，加到当前位置中即可。 当两个碰撞物体排成一排时，会出现无法越过交界处的情况。 因此我选择每次排斥都更新一下自体碰撞盒。这样就能保证碰撞法线的方向相同。不过每次刷新包围盒的时候都会重新计算包围盒信息，增加了计算量。 不过这样会存在一个问题，就是如果碰撞的顺序不同的话，得到的结果也不同，因此我选择保存接触到的碰撞对象，每次碰撞检测的时候检测上次的碰撞物体是否存在于列表中，存在则不动，不存在则新增到列表后面，没碰撞的物体移除列表。这样就能保证每次碰撞的顺序是按照接触到的物体顺序，而不是遍历的顺序。 下落我选择的是根据下落的公式 $v_g&#x3D;-gt$ 得到下落速度，乘以每帧时间 $v_{g_{dt}}&#x3D;v_g*dt$ 得到每帧的下落速度，再加到当前坐标的y值上即可。 跳跃跳跃是在下落的基础上，增加一个初始速度，通过公式 $v&#x3D;v_0-v_g$ 得到下落速度，然后跟上面下落一样处理得到新的y值。 爬坡在爬坡的时候，我根据坡面的法线方向和自体的上方向，得到一个旋转的四元数，然后用该四元数乘以前进方向，使前进方向旋转到坡面，这样在坡面的移动就相当于把原来的坐标系转移到坡面的坐标系中，再在坡面坐标系实现位移。 用一个平面图来表示的话就像下图所示： 推广到三维空间也是一样。 判断是否在平台上跳跃和坡面都需要判断是否在平台上，在平台上的话就停止下落并重置状态。 判断是否在顶部，就判断自体最低点是否大于等于碰撞物体最高点；判断是会否在坡面，就判断移动方向和自体下方向的投影的绝对值是否大于0并小于自定义的坡度（0-1之间）。 跨台阶跨台阶就是在做排斥的时候，判断自体最低点是否小于碰撞物体最高点，并且自体最低点加上自定义跨越高度是否大于碰撞物体最高点，都满足的情况下令排斥值的y值等于碰撞物体最高点减去自体最低点，即： 1234if (self.minY &lt; other.maxY &amp;&amp; self.minY + self.stepHeight &gt;= other.maxY)&#123; offset.y = other.maxY - self.minY;&#125; 否则就按照正常的排斥计算。 攀爬攀爬判定发生碰撞并且移动方向和碰撞法线的投影小于一定值（自定义）超过一定时间的时候判定为开始攀爬。 头顶有障碍物的时候取消攀爬。（攀爬面法线y值小于一定值为头顶有障碍物） 攀爬计算攀爬和爬坡一样需要把坐标系转移到攀爬平面上。 令原始输入方向（即输入值ADWS）面向攀爬平面法线的反方向，得到面向输入方向。 计算自体上方向和攀爬平面法线的旋转四元数。 旋转四元数乘以面向输入方向得到最终攀爬方向。（和爬坡一样的操作） 攀爬与爬坡不同的是，爬坡用的是自体的移动方向做原始输入，攀爬用的是键盘输入的移动方向做原始输入。 攀爬的时候需要单独计算排斥，使其刚好处于碰撞物体表面。并且，碰撞物体的最近中心坐标在不碰撞的时候不清除，这样就可以拐弯。 自动攀爬到顶判断自体最高点是否大于碰撞物体最高点一定值，是则开始自动攀爬并禁用攀爬移动。 攀爬跳跃默认情况下向上跳跃，有按方向的情况下按照所按方向跳跃。 和攀爬到顶一样，攀爬跳跃也禁用攀爬，然后自动进行数帧的位移。完成后重启攀爬。 更新日志2024-01-22 更新基础内容移动碰撞下落跳跃爬坡判定平台跨台阶攀爬","categories":[{"name":"设计思路","slug":"设计思路","permalink":"https://busyogg.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"}],"tags":[{"name":"物理","slug":"物理","permalink":"https://busyogg.github.io/tags/%E7%89%A9%E7%90%86/"}]},{"title":"用自己买的服务器进行内网穿透","slug":"用自己买的服务器进行内网穿透","date":"2024-01-20T17:07:09.000Z","updated":"2024-01-27T20:09:18.596Z","comments":true,"path":"article/90abd34fc86f/","link":"","permalink":"https://busyogg.github.io/article/90abd34fc86f/","excerpt":"","text":"简介大部分时候我们自己网络的IP是内网IP，又想要别人能够通过外网来访问我们电脑里的项目，这时候就需要内网穿透。 除了花生壳等第三方以外，我们还可以用自己买的服务器的公网IP来进行内网穿透。 当然，如果你条件允许的话，直接用高配的服务器就好。此处的适用场景为服务器配置不足，自己电脑配置足够的情况下，通过服务器转发访问到我们自己的电脑。 方法我们可以使用开源项目 FRP 来实现。 首先我们下载release中对应平台的文件。 其次我们在服务端部署frps相关的所有文件到任意目录。然后修改配置文件（也可以默认不修改，默认端口为7000）。然后通过 ./frps -c ./frps.toml 命令来启动服务。 接下来我们在客户端部署frpc相关的所有文件到任意目录。然后按照下面的要求修改配置文件。最后通过 ./frpc -c ./frpc.toml 命令来启动服务。 1234567891011serverAddr = &quot;x.x.x.x&quot; //服务器ipserverPort = 7000 //服务端端口，和frps配置的一致# 如果默认的 STUN 服务器不可用，可以配置一个新的 STUN 服务器# natHoleStunServer = &quot;xxx&quot;[[proxies]]name = &quot;test-tcp&quot; //随便写type = &quot;tcp&quot; //协议localIP = &quot;127.0.0.1&quot; //本地服务iplocalPort = 22 //本地服务端口remotePort = 6000 //访问时使用的端口 更多配置请前往 官方文档 查看。 只要服务端出现 frps started successfully，本地出现 start proxy success 字样就穿透成功了。 接下来只要使用 x.x.x.x:6000 就能访问到内网的服务了。 更新日志2024-01-21 1.更新基本内容。","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://busyogg.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://busyogg.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"FRP","slug":"FRP","permalink":"https://busyogg.github.io/tags/FRP/"}]},{"title":"ChatGPT访问方法","slug":"ChatGPT访问方法","date":"2023-12-15T15:49:03.000Z","updated":"2023-12-15T16:01:50.466Z","comments":true,"path":"article/0adcafccba95/","link":"","permalink":"https://busyogg.github.io/article/0adcafccba95/","excerpt":"","text":"设置代理地址为支持ChatGPT的国家或地区，如美国（香港不支持）。 清除浏览器cookie。 地址栏输入javascript:window.localStorage.removeItem(Object.keys(window.localStorage).find(i=&gt;i.startsWith(&#39;@@auth0spajs&#39;)))，其中javascript:需要手动输入。 以上方法根据情况自由选择搭配使用（代理必须要做）。清除cookie需要重启浏览器。清除缓存不需要。","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://busyogg.github.io/tags/ChatGPT/"}]},{"title":"Unity-配置类生成器","slug":"Unity-配置类生成器","date":"2023-12-10T13:32:35.000Z","updated":"2023-12-19T17:03:14.720Z","comments":true,"path":"article/7fe0212fb1a1/","link":"","permalink":"https://busyogg.github.io/article/7fe0212fb1a1/","excerpt":"","text":"简介自动监听Json配置文件夹，目前实现一件生成配置类，有空的话再增加配置查看和修改的功能。 使用说明工具说明 按照图片红框所示的步骤即可一件生成配置类文件。本工具监听配置文件夹，只要有变化自动就会改变面板显示的内容。 工具代码放在Unity项目的Editor文件夹下。 配置类说明配置类会保存到配置类输出文件夹的Bean目录下。 在输出文件夹根目录中存在一个 ConfigsPathConfig 文件，该文件包含所有配置的名字和配置文件夹的名字。 例： 配置文件说明配置表属性名后面添加 | 可以分割属性名和类型。 如果我们需要一个本配置类的类型，则我们在对应的配置项就置空。 例： 如果我们需要一个特定的枚举类型或者类的类型，则可以用 | 来表示我们要生成的类型，即 PropName|EnumType，这样就能生成 EnumType prop。 例： 如果该类型是int类型的列表，但是第一项中没有内容，我们只要把属性名写成 PropName|int 即可生成 List&lt;int&gt;。 例： 如果该类型是本数据类，则我们不用写类型，但是要在配置项的位置写一个空列表 [] ，这样生成的时候就会生成 List&lt;ClassName&gt;。 例： 如果要生成一个字典，则我们可以再加一个 | 来表示键值对类型，即写成 PropName|type|type，并且在配置项写一个空对象 &#123;&#125;，这样就能生成 Dictionary&lt;type,type&gt;。目前支持的key类型为string和int。 例： 如果要生成一个对象数组，只需要在数组中写入对象键值对，即可生成对象辅助类。本类型不支持自定义数组和字典类型，只能按照输入的内容创建基本数据类型的数组和字典。 例： 配置管理器说明使用 ConfigManager.Ins().GetConfig&lt;T&gt;(string folder, string name) 来获取对应的配置。 使用 ConfigManager.Ins().Clear() 来清除缓存。 配置路径修改修改文件 ConfigEditor 中的 _jsonUrl 属性即可修改读取json文件的文件夹路径。 修改文件 ConfigEditor 中的 _outputUrl 属性即可修改写入配置类的路径。 注意 配置文件夹下不能创建和配置文件夹同名的文件夹。 配置文件夹只能存在最多二级文件夹，即最大路径为 /Configs/Folder/Config.json。 代码ConfigEditor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using LitJson;public class ConfigEditor : EditorWindow&#123; /// &lt;summary&gt; /// 配置文件路径 /// &lt;/summary&gt; private string _jsonUrl; /// &lt;summary&gt; /// 配置类输出路径 /// &lt;/summary&gt; private string _outputUrl; private Dictionary&lt;string, List&lt;FileInfo&gt;&gt; _allConfigs = new Dictionary&lt;string, List&lt;FileInfo&gt;&gt;(); private int _configsNum = 0; private bool _foldConfigs = true; private Vector2 _scrollRoot; ConfigEditor() &#123; titleContent = new GUIContent(&quot;配置编辑器&quot;); &#125; [MenuItem(&quot;PreUtils/EditorEditor&quot;)] static public void ShowEditor() &#123; // Debug.Log(&quot;启动配置编辑器&quot;); EditorWindow.GetWindow(typeof(ConfigEditor)); &#125; private void OnEnable() &#123; _jsonUrl = Application.dataPath + &quot;/Configs/&quot;; _outputUrl = Application.dataPath + &quot;/Script/Loader/Config/&quot;; //获取所有配置 GetAllConfigs(); //监听配置文件夹变化 Debug.Log(&quot;启动文件夹监听&quot;); FileSystemWatcher watcher = new FileSystemWatcher(); watcher.IncludeSubdirectories = true; watcher.Path = _jsonUrl; watcher.NotifyFilter = NotifyFilters.LastWrite; watcher.Filter = &quot;*.json&quot;; FileSystemEventHandler changeHandle = new FileSystemEventHandler(OnJsonFileChanged); watcher.Changed += changeHandle; //watcher.Deleted += changeHandle; watcher.Created += changeHandle; watcher.EnableRaisingEvents = true; watcher.InternalBufferSize = 10240; &#125; public void OnGUI() &#123; GUILayout.Space(10); //获取所有配置 _foldConfigs = EditorGUILayout.BeginFoldoutHeaderGroup(_foldConfigs, &quot;所有配置&quot;); if (_foldConfigs) &#123; GUILayout.Label(&quot;总配置数量：&quot; + _configsNum); GUILayout.BeginHorizontal(); GUILayout.Space(10); _scrollRoot = EditorGUILayout.BeginScrollView(_scrollRoot, GUILayout.Height(400), GUILayout.Width(position.width - 20)); GUIStyle configButtonStyle = new GUIStyle(GUI.skin.button); configButtonStyle.fixedHeight = 22; configButtonStyle.fontSize = 16; configButtonStyle.alignment = TextAnchor.MiddleLeft; GUIStyle configLabelStyle = new GUIStyle(GUI.skin.label); configLabelStyle.fontSize = 18; configLabelStyle.alignment = TextAnchor.MiddleLeft; configLabelStyle.fixedHeight = 20; foreach (var fileInfo in _allConfigs) &#123; EditorGUILayout.LabelField(fileInfo.Key + &quot;【&quot; + fileInfo.Value.Count + &quot;个配置文件】:&quot;, configLabelStyle); GUILayout.Space(5); for (int i = 0, len = fileInfo.Value.Count; i &lt; len; i++) &#123; FileInfo file = fileInfo.Value[i]; //EditorGUILayout.LabelField(&quot;测试&quot;); GUIContent name = new GUIContent((i + 1) + &quot;.&quot; + file.Name.Replace(&quot;.json&quot;, &quot;&quot;)); if (GUILayout.Button(name, configButtonStyle)) &#123; //EditorWindow.GetWindow(typeof(ConfigDetailEditor)); &#125; GUILayout.Space(2); &#125; GUILayout.Space(10); &#125; EditorGUILayout.EndScrollView(); GUILayout.EndHorizontal(); &#125; EditorGUILayout.EndFoldoutHeaderGroup(); GUILayout.Space(10); if (GUILayout.Button(&quot;一键生成所有配置文件数据类&quot;)) &#123; GenerateDataClass(); GenerateConfigPath(); &#125; &#125; /// &lt;summary&gt; /// 创建数据类 /// &lt;/summary&gt; private void GenerateDataClass() &#123; //生成基类 string ns = &quot;Bean&quot;; string baseClass = &quot;namespace &quot; + ns + &quot;\\r\\n&#123;\\r\\n&quot; + &quot;\\tpublic class ConfigBaseData\\r\\n&quot; + &quot;\\t&#123;\\r\\n&quot; + &quot;\\t\\tpublic int id;\\r\\n&quot; + &quot;\\t&#125;\\r\\n&#125;&quot;; string output = _outputUrl + &quot;ConfigBaseData.cs&quot;; GeneratorUtils.WriteFile(output, baseClass); //创建所有数据类 foreach (var fileInfo in _allConfigs) &#123; //生成数据类 for (int i = 0, len = fileInfo.Value.Count; i &lt; len; i++) &#123; FileInfo file = fileInfo.Value[i]; string content = GeneratorUtils.ReadFile(file.FullName); JsonData jsonData = JsonMapper.ToObject(content); GenerateClass(GeneratorUtils.UpperCaseFirstChar(file.Name.Split(&#x27;.&#x27;)[0]) + &quot;Data&quot;, jsonData, fileInfo.Key); &#125; &#125; &#125; /// &lt;summary&gt; /// 创建类 /// &lt;/summary&gt; /// &lt;param name=&quot;clsName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;folder&quot;&gt;&lt;/param&gt; private void GenerateClass(string clsName, JsonData json, string folder) &#123; List&lt;string&gt; listClass = new List&lt;string&gt;(); List&lt;string&gt; listProps = new List&lt;string&gt;(); string ns = &quot;Bean&quot;; //创建命名空间 listClass.Add(&quot;using System;\\r\\n&quot; + &quot;using System.Collections.Generic;\\r\\n&quot; + &quot;namespace &quot; + ns + &quot;&#123;\\r\\n&quot;); //创建类头 listClass.Add(&quot;\\tpublic class &quot; + clsName + &quot;: ConfigBaseData, ICloneable&#123;\\r\\n&quot;); //创建构造函数 string strConstructor = &quot;\\t\\tpublic &quot; + clsName + &quot;()&#123;\\r\\n&quot;; //遍历属性 IDictionary props = json[0]; foreach (var key in props.Keys) &#123; Dictionary&lt;string, bool&gt; dicClass = new Dictionary&lt;string, bool&gt;(); string propName = key.ToString(); if (propName == &quot;id&quot;) continue; JsonData child = json[0][propName]; object type = child == null ? JsonType.None : child.GetJsonType(); if (type.Equals(JsonType.None)) &#123; listClass.Add(&quot;\\t\\tpublic &quot; + clsName + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; else if (type.Equals(JsonType.Array)) &#123; //属性为数组 if (child.Count == 0) &#123; //最终类型非对象，该属性为纯数组 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; string[] propSplit = propName.Split(&#x27;|&#x27;); string strType; if (propSplit.Length &gt; 1) &#123; //strList += propSplit[1] + strListEnd; strType = propSplit[1]; &#125; else &#123; strType = clsName; &#125; strList += strType + strListEnd; Debug.Log(&quot;list数组 ==== &quot; + strList); //cls += &quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; listClass.Add(&quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propSplit[0] + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propSplit[0] + &quot; = new List&lt;&quot; + strType + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; else &#123; //获取最终类型 JsonData tempData = child[0]; JsonType tempType = tempData.GetJsonType(); int loop = 1; while (tempData.GetJsonType().Equals(JsonType.Array)) &#123; tempData = tempData[0]; tempType = tempData.GetJsonType(); loop++; &#125; if (tempType.Equals(JsonType.Object)) &#123; //最终类型为对象 //创建附属类 string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dicClass.ContainsKey(strListClassName)) &#123; GeneratorUtils.GenerateSubClass(child, strListClassName, listClass, dicClass); dicClass.Add(strListClassName, true); &#125; //创建附属类列表 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += strListClassName + strListEnd; &#125; &#125; //strListClass += &quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; listClass.Add(&quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propName + &quot; = new List&lt;&quot; + strListClassName + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; else &#123; //最终类型非对象，该属性为纯数组 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += GeneratorUtils.GetType(tempType) + strListEnd; &#125; &#125; Debug.Log(&quot;list数组 ==== &quot; + strList); //cls += &quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; listClass.Add(&quot;\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propName + &quot; = new List&lt;&quot; + GeneratorUtils.GetType(tempType) + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; &#125; &#125; else if (type.Equals(JsonType.Object)) &#123; //属性为对象 string[] propSplits = propName.Split(&quot;|&quot;); if (propSplits.Length &gt; 1) &#123; listClass.Add(&quot;\\t\\tpublic Dictionary&lt;&quot; + propSplits[1] + &quot;,&quot; + propSplits[2] + &quot;&gt; &quot; + propSplits[0] + &quot;;\\r\\n&quot;); string strConstructorChild = &quot;\\t\\t\\t&quot; + propSplits[0] + &quot; = new Dictionary&lt;&quot; + propSplits[1] + &quot;,&quot; + propSplits[2] + &quot;&gt;();\\r\\n&quot;; strConstructor += strConstructorChild; &#125; else &#123; //创建附属类 string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dicClass.ContainsKey(strListClassName)) &#123; GeneratorUtils.GenerateSubClass(child, strListClassName, listClass, dicClass); dicClass.Add(strListClassName, true); &#125; listClass.Add(&quot;\\t\\tpublic &quot; + strListClassName + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; &#125; else &#123; //属性为基本类型 //Debug.Log(&quot;属性名&quot; + propName + &quot;,&quot; + type + &quot;,&quot; + json[0][propName]); //cls += &quot;\\t\\tpublic &quot; + GetType(type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;; if (type == null) &#123; listClass.Add(&quot;\\t\\tpublic &quot; + clsName + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; else &#123; string[] propSplit = propName.Split(&#x27;|&#x27;); if (propSplit.Length &gt; 1) &#123; listClass.Add(&quot;\\t\\tpublic &quot; + propSplit[1] + &quot; &quot; + propSplit[0] + &quot;;\\r\\n&quot;); &#125; else &#123; listClass.Add(&quot;\\t\\tpublic &quot; + GeneratorUtils.GetType((JsonType)type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;); &#125; &#125; &#125; listProps.Add(propName); &#125; strConstructor += &quot;\\t\\t&#125;\\r\\n&quot;; listClass.Add(strConstructor); string strGenerator = &quot;&quot;; strGenerator += &quot;\\t\\tpublic &quot; + clsName + &quot;(&quot; + clsName + &quot; obj)&#123;\\r\\n&quot;; for (int i = 0, len = listProps.Count; i &lt; len; i++) &#123; string[] propSplit = listProps[i].Split(&#x27;|&#x27;); if (propSplit.Length &gt; 1) &#123; strGenerator += &quot;\\t\\t\\t&quot; + propSplit[0] + &quot; = obj.&quot; + propSplit[0] + &quot;;\\r\\n&quot;; &#125; else &#123; strGenerator += &quot;\\t\\t\\t&quot; + listProps[i] + &quot; = obj.&quot; + listProps[i] + &quot;;\\r\\n&quot;; &#125; &#125; strGenerator += &quot;\\t\\t&#125;\\r\\n&quot;; listClass.Add(strGenerator); //创建克隆函数 listClass.Add(&quot;\\t\\tpublic object Clone()\\r\\n&quot; + &quot;\\t\\t&#123;\\r\\n&quot; + &quot;\\t\\t\\treturn new &quot; + clsName + &quot;(this);\\r\\n&quot; + &quot;\\t\\t&#125;\\r\\n&quot;); //补充文件结构 listClass.Add(&quot;\\t&#125;&quot; + &quot;\\r\\n&#125;&quot;); //拼装数据类内容 string cls = &quot;&quot;; for (int i = 0, len = listClass.Count; i &lt; len; i++) &#123; cls += listClass[i]; &#125; //保存数据类 Debug.Log(&quot;生成类&quot; + cls); string strFolder; if (folder == &quot;Configs&quot;) &#123; strFolder = &quot;&quot;; &#125; else &#123; strFolder = folder + &quot;/&quot;; &#125; string output = _outputUrl + &quot;Bean/&quot; + strFolder + clsName + &quot;.cs&quot;; GeneratorUtils.WriteFile(output, cls); &#125; private void GenerateConfigPath() &#123; //string ns = &quot;Bean&quot;; string cls = &quot;namespace Bean&#123;\\r\\n&quot; + &quot;\\tpublic class ConfigsFolderConfig\\r\\n&quot; + &quot;\\t&#123;\\r\\n&quot;; string folders = &quot;\\t\\tpublic const string Null = null;\\r\\n&quot;; string names = &quot;&quot;; //配置名字典，防止重名配置重复添加 Dictionary&lt;string, bool&gt; dicNames = new Dictionary&lt;string, bool&gt;(); //创建所有数据类 foreach (var fileInfo in _allConfigs) &#123; if (fileInfo.Key != &quot;Configs&quot;) &#123; folders += &quot;\\t\\tpublic const string &quot; + fileInfo.Key + &quot; = \\&quot;&quot; + fileInfo.Key + &quot;\\&quot;;\\r\\n&quot;; &#125; //生成数据类 for (int i = 0, len = fileInfo.Value.Count; i &lt; len; i++) &#123; FileInfo file = fileInfo.Value[i]; string fileName = file.Name.Replace(&quot;.json&quot;, &quot;&quot;); if (!dicNames.ContainsKey(fileName)) &#123; names += &quot;\\t\\tpublic const string &quot; + GeneratorUtils.UpperCaseFirstChar(fileName) + &quot; = \\&quot;&quot; + fileName + &quot;\\&quot;;\\r\\n&quot;; dicNames.Add(fileName, true); &#125; &#125; &#125; cls += folders; cls += &quot;\\t&#125;\\r\\n\\r\\n&quot; + &quot;\\tpublic class ConfigsNameConfig\\r\\n&quot; + &quot;\\t&#123;\\r\\n&quot;; cls += names; cls += &quot;\\t&#125;\\r\\n&quot; + &quot;&#125;&quot;; Debug.Log(&quot;生成配置表路径配置\\n&quot; + cls); GeneratorUtils.WriteFile(_outputUrl + &quot;ConfigsPathConfig.cs&quot;, cls); &#125; //-----自动函数----- /// &lt;summary&gt; /// 配置文件发生变化后的响应事件 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; private void OnJsonFileChanged(object obj, FileSystemEventArgs args) &#123; Debug.Log(&quot;配置文件发生变化，重载配置文件&quot;); _allConfigs.Clear(); GetAllConfigs(); &#125; /// &lt;summary&gt; /// 获取所有配置 /// &lt;/summary&gt; private void GetAllConfigs() &#123; Debug.Log(&quot;获取所有配置1:&quot; + _jsonUrl); DirectoryInfo directoryInfo = new DirectoryInfo(_jsonUrl); FileInfo[] files = directoryInfo.GetFiles(&quot;*&quot;, SearchOption.AllDirectories); _configsNum = 0; for (int i = 0, len = files.Length; i &lt; len; i++) &#123; FileInfo file = files[i]; if (file.Name.EndsWith(&quot;.meta&quot;)) continue; string[] folders = file.DirectoryName.Split(&#x27;\\\\&#x27;); string parent = folders[folders.Length - 1]; //_allConfigs.Add(file); if (!_allConfigs.ContainsKey(parent)) &#123; _allConfigs.Add(parent, new List&lt;FileInfo&gt;()); &#125; _allConfigs[parent].Add(file); //ConsoleUtils.Log(&quot;添加路径&quot; , (file.DirectoryName + &quot;/&quot;), _jsonUrl); _configsNum++; &#125; &#125;&#125; GeneratorUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181using System.Collections;using System.Collections.Generic;using UnityEngine;using LitJson;using System.IO;using System.Text;public class GeneratorUtils&#123; /// &lt;summary&gt; /// 生成辅助类 /// &lt;/summary&gt; /// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;className&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;dic&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string GenerateSubClass(JsonData json, string className, List&lt;string&gt; list, Dictionary&lt;string, bool&gt; dic) &#123; string strListClass = &quot;\\t\\tpublic class &quot; + className + &quot; &#123;\\r\\n&quot;; Debug.Log(&quot;json数据 ===== &quot; + json.ToJson()); IDictionary classProps = json.GetJsonType().Equals(JsonType.Array) ? json[0] : json; foreach (var classKey in classProps.Keys) &#123; string propName = classKey.ToString(); //JsonData child = json[0][propName]; //strListClass += &quot;\\t\\tpublic &quot; + GetType(type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;; JsonData child = (JsonData)classProps[classKey]; JsonType type = child.GetJsonType(); if (type.Equals(JsonType.Array)) &#123; string[] propSplit = propName.Split(&#x27;|&#x27;); //获取最终类型 JsonData tempData = child[0]; JsonType tempType = tempData.GetJsonType(); int loop = 1; while (tempData.GetJsonType().Equals(JsonType.Array)) &#123; tempData = tempData[0]; tempType = tempData.GetJsonType(); loop++; &#125; if (tempType.Equals(JsonType.Object)) &#123; string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dic.ContainsKey(strListClassName)) &#123; GenerateSubClass(child, strListClassName, list, dic); dic.Add(strListClassName, true); &#125; //创建附属类列表 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += strListClassName + strListEnd; &#125; &#125; strListClass += &quot;\\t\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; else &#123; //非对象，该属性为纯数组 string strList = &quot;&quot;; string strListEnd = &quot;&quot;; for (int i = 0; i &lt; loop; i++) &#123; strList += &quot;List&lt;&quot;; strListEnd += &quot;&gt;&quot;; if (i == loop - 1) &#123; strList += GetType(tempType) + strListEnd; &#125; &#125; strListClass += &quot;\\t\\t\\tpublic &quot; + strList + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; &#125; else if (type.Equals(JsonType.Object)) &#123; string strListClassName = GeneratorUtils.UpperCaseFirstChar(propName) + &quot;Data&quot;; if (!dic.ContainsKey(strListClassName)) &#123; GenerateSubClass(child, strListClassName, list, dic); &#125; strListClass += &quot;\\t\\t\\tpublic &quot; + strListClassName + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; else &#123; string[] propSplit = propName.Split(&#x27;|&#x27;); Debug.Log(&quot;分离:&quot; + propSplit.Length); if (propSplit.Length &gt; 1) &#123; strListClass += &quot;\\t\\t\\tpublic &quot; + propSplit[1] + &quot; &quot; + propSplit[0] + &quot;;\\r\\n&quot;; &#125; else &#123; strListClass += &quot;\\t\\t\\tpublic &quot; + GetType(type) + &quot; &quot; + propName + &quot;;\\r\\n&quot;; &#125; &#125; &#125; strListClass += &quot;\\t\\t&#125;\\r\\n&quot;; list.Insert(2, strListClass); return strListClass; &#125; public static string GetType(JsonType name) &#123; switch (name) &#123; case JsonType.Int: return &quot;int&quot;; case JsonType.Boolean: return &quot;bool&quot;; case JsonType.String: return &quot;string&quot;; case JsonType.Double: return &quot;double&quot;; case JsonType.Long: return &quot;long&quot;; &#125; return &quot;&quot;; &#125; /// &lt;summary&gt; /// 首字母大写 /// &lt;/summary&gt; /// &lt;param name=&quot;s&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string UpperCaseFirstChar(string s) &#123; if (string.IsNullOrEmpty(s)) &#123; return string.Empty; &#125; char[] a = s.ToCharArray(); a[0] = char.ToUpper(a[0]); return new string(a); &#125; /// &lt;summary&gt; /// 创建文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;info&quot;&gt;&lt;/param&gt; public static void WriteFile(string path, string content) &#123; //if (File.Exists(path)) &#123; //&#125; string folderPath = Path.GetDirectoryName(path); if (!Directory.Exists(folderPath)) &#123; Directory.CreateDirectory(folderPath); &#125; File.WriteAllText(path, content, Encoding.Default); &#125; /// &lt;summary&gt; /// 读取文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ReadFile(string path) &#123; path = path.Replace(&quot;/&quot;, &quot;\\\\&quot;); return File.ReadAllText(path); &#125;&#125; FileUtils123456789101112131415161718192021222324252627282930313233343536using System.IO;using System.Text;public class FileUtils&#123; // Start is called before the first frame update /// &lt;summary&gt; /// 创建文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;info&quot;&gt;&lt;/param&gt; public static void WriteFile(string path, string content) &#123; //if (File.Exists(path)) &#123; //&#125; string folderPath = Path.GetDirectoryName(path); if (!Directory.Exists(folderPath)) &#123; Directory.CreateDirectory(folderPath); &#125; File.WriteAllText(path, content, Encoding.Default); &#125; /// &lt;summary&gt; /// 读取文件 /// &lt;/summary&gt; /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ReadFile(string path) &#123; path = path.Replace(&quot;/&quot;, &quot;\\\\&quot;); return File.ReadAllText(path); &#125;&#125; ConfigManager1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System.Collections.Generic;using System.IO;using UnityEngine;using System.Linq;using LitJson;using Bean;using System.Text.RegularExpressions;public class ConfigManager:Singleton&lt;ConfigManager&gt;&#123; private Dictionary&lt;string, object&gt; _configs = new Dictionary&lt;string, object&gt;(); private Dictionary&lt;string, Dictionary&lt;string, FileInfo&gt;&gt; _fileInfo; /// &lt;summary&gt; /// 读取配置 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;folder&quot;&gt;配置分类&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;配置名&lt;/param&gt; /// &lt;returns&gt;配置字典&lt;/returns&gt; public Dictionary&lt;int, T&gt; GetConfig&lt;T&gt;(string folder, string name) where T : ConfigBaseData &#123; object obj = null; string path = folder + &quot;_&quot; + name; _configs.TryGetValue(path, out obj); if (obj != null) &#123; Debug.Log(&quot;读取配置缓存【&quot; + name + &quot;】&quot;); return (Dictionary&lt;int, T&gt;)obj; &#125; else &#123; string config = FileUtils.ReadFile(Application.dataPath + &quot;/Configs/&quot; + (folder != null ? folder + &quot;/&quot; : &quot;&quot;) + name + &quot;.json&quot;); config = Regex.Replace(config, &quot;(\\\\|).*(?=\\&quot;)&quot;, &quot;&quot;); Debug.Log(&quot;配置读取路径 - &quot; + Application.dataPath + &quot;/Configs/&quot; + (folder != null ? folder + &quot;/&quot; : &quot;&quot;) + name + &quot;.json&quot;); Debug.Log(&quot;读取内容 = &quot; + config); if (!string.IsNullOrEmpty(config)) &#123; T[] json = JsonMapper.ToObject&lt;T[]&gt;(config); obj = json.ToDictionary(key =&gt; key.id, value =&gt; value); _configs.Add(path, obj); return (Dictionary&lt;int, T&gt;)obj; &#125; else &#123; Debug.LogWarning(&quot;不存在配置【&quot; + name + &quot;】&quot;); return null; &#125; &#125; &#125; /// &lt;summary&gt; /// 清除目标缓存 /// &lt;/summary&gt; /// &lt;param name=&quot;folder&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;name&quot;&gt;&lt;/param&gt; public void Clear(string folder, string name) &#123; string path = folder + &quot;_&quot; + name; if (_configs.ContainsKey(path)) &#123; _configs.Remove(path); &#125; &#125; /// &lt;summary&gt; /// 清除所有缓存 /// &lt;/summary&gt; public void ClearAll() &#123; _configs.Clear(); &#125;&#125; 更新日志2023-12-13 更新配置读取管理器。修改LitJson序列化使其支持int类型作为字典的key。 2023-12-09 更新基础版本。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"Unity-时间轮定时器","slug":"Unity-时间轮定时器","date":"2023-12-08T19:20:26.000Z","updated":"2024-01-27T20:09:25.121Z","comments":true,"path":"article/57f2cacfb66b/","link":"","permalink":"https://busyogg.github.io/article/57f2cacfb66b/","excerpt":"","text":"简介我们在开发的过程中，有时候需要一个行为延迟一定时间，或者是重复执行，这时候我们就需要用到定时器。Unity没有专门的定时器系统，不过有协程的方式来实现这一行为。不过协程的使用难免有些不方便，也有一些性能上的消耗，因此决定自己造轮子。本系统使用时间轮的思想构建定时器系统，有别于传统的全遍历方式。 原理时间轮网图： 假设我们有一个时间轮盘，这个轮盘有好几个槽位，每个槽位里面有一个链表用于保存符合当前条件的定时任务。 每个定时任务放入对应槽位的规则为 当前时间 + 延迟时间 + 每次循环时间，这样每个槽位就对应着触发任务的时间。 我们按照当前时间来访问对应的槽位，即到了需要触发任务的时间，任务触发。 如果我们按照一个最小时间间隔，每个时间都开设一个槽位的话，需要的存储空间就太大了。因此我们需要多层时间轮，就好像水表有好几个转盘表示不同的刻度。我们把时间分为年（需要的话）、月、日、时、分、毫秒，本例中没有年轮，总共是六个时间轮。毫秒轮的数量太大，我们也可以按照设定的最小时间间隔减少划分（本例按照50ms为最小粒度划分20个槽位）。本例中时间轮用字典保存，任务列表用链表保存。 当我们的任务为定时到5秒后，我们就把当前任务放入月轮当月的槽位，然后我们在轮询的时候按照六个符合当前时间的时间轮槽位依次遍历链表。由于我们每次添加任务都是添加到最顶层的月轮，因此我们把当前时间的月轮槽位中的所有任务都取出并添加到日轮。日轮也是同样的操作，依次执行之后任务就到达毫秒轮中。 任务最终到达毫秒轮后，我们就遍历当前毫秒轮槽位的链表，比较当前时间和任务目标时间，大于等于的情况下执行任务并移除出链表。移除之后，我们还要判断当前任务是否需要循环，需要循环的话我们把当前任务又重新添加到月轮中，执行下一个循环。 链式调用为了让定时器更加实用，我们引入了链式调用。我们在创建定时器的时候会返回一个链式调用的对象，这样就可以在创建一次定时器之后再点出一个新的定时器。这个新的定时器的延迟时间为前面所有定时器的总经过时间再加上自己的延迟时间，这样就可以避免定时器的嵌套。 使用方式使用之前先调用 TimerUtils.Init() 来初始化，结束之后调用 TimerUtils.Stop() 来结束。 调用定时器的方式分为两种，一种是同步任务，一种是异步任务。由于Unity对象只有在主线程上才能访问，因此如果要延迟操作Unity对象的话就需要用同步任务，其他情况可以选择异步调用，根据需求即可。 延迟执行：TimerChain Once(int delay, Action action)下面的例子是延迟一秒后打印消息到控制台。 1234TimerUtils.Once(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;执行&quot;, DateTime.Now, chain.GetId());&#125;); 循环执行：TimerChain Loop(int interval, Action action, int delay = 0, int loopTimes = -1)下面的例子是循环三次，每次1秒间隔，延迟时间为0，不传入循环次数就是无限循环。 1234TimerUtils.Loop(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;循环&quot;, DateTime.Now);&#125;, 0, 3); 清除定时器 12345678TimerChain chain = TimerUtils.Loop(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;循环&quot;, DateTime.Now);&#125;, 0, 3);//清除定时器chain.Clear();//或者用下面的方式，两种都一样TimerUtils.Clear(chain); 链式调用 1234567TimerUtils.Loop(1000, () =&gt;&#123; ConsoleUtils.Log(&quot;循环&quot;, DateTime.Now);&#125;, 0, 3).Once(5000, () =&gt;&#123; ConsoleUtils.Log(&quot;等待&quot;, DateTime.Now);&#125;); 异步的调用和同步的一样，只是函数名不同（带Async）。 代码TimerTask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Threading.Tasks;public class TimerTask&#123; public int id; public int delay; public int interval; public int loopTimes; public Action action; public DateTime dateTime; public TimerType type; public bool isRemove; public TimerTask(int id, int interval, Action action, int loopTimes, int delay, TimerType type) &#123; this.id = id; this.interval = interval; this.action = action; this.loopTimes = loopTimes; this.delay = delay; this.type = type; isRemove = false; dateTime = DateTime.Now.AddMilliseconds(interval + delay); &#125; public void Run() &#123; if (type == TimerType.Sync) &#123; TimerUtils.AddAction(id, action); &#125; else &#123; RunAsync(); &#125; &#125; public async Task RunAsync() &#123; await Task.Run(() =&gt; &#123; action.Invoke(); &#125;); &#125; public bool CheckLoop() &#123; if (isRemove) &#123; return false; &#125; if (loopTimes &lt; 0) &#123; dateTime = DateTime.Now.AddMilliseconds(interval); return true; &#125; else &#123; loopTimes--; dateTime = DateTime.Now.AddMilliseconds(interval); return loopTimes &gt; 0; &#125; &#125;&#125; TimerChain12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System;public class TimerChain&#123; private TimeWheel _timeWheel; //private int _id = -1; private TimerTask _task; private int _delay = 0; public TimerChain(TimeWheel wheel) &#123; _timeWheel = wheel; &#125; public TimerChain Once(int delay, Action action) &#123; _task = _timeWheel.SetTimeout(_task != null ? _task.id : -1, delay + _delay, action); _delay = delay; return this; &#125; public TimerChain Loop(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; _task = _timeWheel.SetInterval(_task != null ? _task != null ? _task.id : -1 : -1, interval, action, delay + _delay, loopTimes); ; _delay = interval * loopTimes + delay; return this; &#125; public TimerChain OnceAsync(int delay, Action action) &#123; _task = _timeWheel.SetTimeoutAsync(_task != null ? _task.id : -1, delay + _delay, action); _delay = delay; return this; &#125; public TimerChain LoopAsync(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; _task = _timeWheel.SetIntervalAsync(_task != null ? _task.id : -1, interval, action, delay + _delay, loopTimes); _delay = interval * loopTimes + delay; return this; &#125; public TimerChain Clear() &#123; _task.isRemove = true; _timeWheel.ClearInterval(_task != null ? _task.id : -1, true); //ConsoleUtils.Log(&quot;清除任务Chain&quot;, _task.id); return this; &#125; public int GetId() &#123; return _task != null ? _task.id : -1; &#125;&#125; TimerUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using System;using System.Threading;using UnityEngine;public class TimerUtils&#123; private static TimeWheel _timeWheel; private static Thread _thread; private static bool _isRunning = false; private static TimerScript _timerScript; public static void Init() &#123; _timeWheel = new TimeWheel(); _isRunning = true; _thread = new Thread(Update); _thread.Start(); GameObject obj = new GameObject(); obj.name = &quot;TimerUtils&quot;; _timerScript = obj.AddComponent&lt;TimerScript&gt;(); &#125; public static void Stop() &#123; _isRunning = false; //_thread.Abort(); &#125; private static void Update() &#123; while (_isRunning) &#123; _timeWheel.Update(); &#125; &#125; /// &lt;summary&gt; /// 同步定时器 /// &lt;/summary&gt; /// &lt;param name=&quot;delay&quot;&gt;延时 单位毫秒&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain Once(int delay, Action action) &#123; return new TimerChain(_timeWheel).Once(delay, action); &#125; /// &lt;summary&gt; /// 同步循环 第一次触发时间为 interval + delay /// &lt;/summary&gt; /// &lt;param name=&quot;interval&quot;&gt;循环间隔时间&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;param name=&quot;delay&quot;&gt;延时&lt;/param&gt; /// &lt;param name=&quot;loopTimes&quot;&gt;循环次数 默认为-1 无限循环&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain Loop(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; return new TimerChain(_timeWheel).Loop(interval, action, delay, loopTimes); &#125; /// &lt;summary&gt; /// 异步定时器 /// &lt;/summary&gt; /// &lt;param name=&quot;delay&quot;&gt;延时 单位毫秒&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain OnceAsync(int delay, Action action) &#123; return new TimerChain(_timeWheel).OnceAsync(delay, action); &#125; /// &lt;summary&gt; /// 异步循环 第一次触发时间为 interval + delay /// &lt;/summary&gt; /// &lt;param name=&quot;interval&quot;&gt;循环间隔时间&lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt;行为&lt;/param&gt; /// &lt;param name=&quot;delay&quot;&gt;延时&lt;/param&gt; /// &lt;param name=&quot;loopTimes&quot;&gt;循环次数 默认为-1 无限循环&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static TimerChain LoopAsync(int interval, Action action, int delay = 0, int loopTimes = -1) &#123; return new TimerChain(_timeWheel).LoopAsync(interval, action, delay, loopTimes); &#125; public static TimerChain Clear(TimerChain chain) &#123; chain.Clear(); return chain; &#125; public static void AddAction(int id, Action action) &#123; _timerScript.AddAction(id, action); &#125;&#125; TimeWheel123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269using System;using System.Collections.Generic;using System.Linq;public class TimeWheel&#123; private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _month = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _day = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _hour = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _minute = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _second = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); private Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; _millisecond = new Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt;(); //private long _curTime = 0; private int _id = 0; private object _lock = new object(); public TimeWheel() &#123; ConsoleUtils.Log(DateTime.Now); for (int i = 0; i &lt; 13; i++) &#123; _month.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 31; i++) &#123; _day.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 24; i++) &#123; _hour.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 60; i++) &#123; _minute.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; for (int i = 0; i &lt; 60; i++) &#123; _second.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; //毫秒级粒度为50ms for (int i = 0; i &lt; 20; i++) &#123; _millisecond.Add(i, new LinkedList&lt;TimerTask&gt;()); &#125; &#125; public void Update() &#123; lock (_lock) &#123; DateTime now = DateTime.Now; LinkedList&lt;TimerTask&gt; month = _month[now.Month]; LinkedList&lt;TimerTask&gt; day = _day[now.Day]; LinkedList&lt;TimerTask&gt; hour = _hour[now.Hour]; LinkedList&lt;TimerTask&gt; minute = _minute[now.Minute]; LinkedList&lt;TimerTask&gt; second = _second[now.Second]; int milliSecondDelta = now.Millisecond / 50; LinkedList&lt;TimerTask&gt; millisecond = _millisecond[milliSecondDelta]; while (month.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = month.First; month.RemoveFirst(); //添加到日轮 _day[node.Value.dateTime.Day].AddLast(node); &#125; while (day.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = day.First; day.RemoveFirst(); //添加到小时轮 _hour[node.Value.dateTime.Hour].AddLast(node); &#125; while (hour.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = hour.First; hour.RemoveFirst(); //添加到分轮 _minute[node.Value.dateTime.Minute].AddLast(node); &#125; while (minute.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = minute.First; minute.RemoveFirst(); //添加到秒轮 _second[node.Value.dateTime.Second].AddLast(node); &#125; while (second.Count &gt; 0) &#123; LinkedListNode&lt;TimerTask&gt; node = second.First; second.RemoveFirst(); //添加到毫秒轮 _millisecond[node.Value.dateTime.Millisecond / 50].AddLast(node); &#125; while (millisecond.Count &gt; 0) &#123; //LinkedListNode&lt;TimerTask&gt; node = second.First; //second.RemoveFirst(); ////添加到毫秒轮 //_millisecond[node.Value.dateTime.Millisecond / 50].AddLast(node); foreach (var task in millisecond.ToList()) &#123; if (task != null &amp;&amp; DateTime.Now &gt;= task.dateTime) &#123; millisecond.Remove(task); //ConsoleUtils.Log(&quot;执行任务&quot;, task.id); //task.RunAsync(); task.Run(); if (task.CheckLoop()) &#123; AddTask(task); &#125; &#125; &#125; &#125; &#125; &#125; public TimerTask SetInterval(int id, int interval, Action action, int delay, int loopTimes, bool isRemove = false) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, interval, action, loopTimes, delay, TimerType.Sync); AddTask(task); return task; &#125; public TimerTask SetTimeout(int id, int delay, Action action) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, 0, action, 1, delay, TimerType.Sync); AddTask(task); return task; &#125; public TimerTask SetIntervalAsync(int id, int interval, Action action, int delay, int loopTimes) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, interval, action, loopTimes, delay, TimerType.Async); AddTask(task); return task; &#125; public TimerTask SetTimeoutAsync(int id, int delay, Action action) &#123; if (id == -1) &#123; id = GetId(); &#125; TimerTask task = new TimerTask(id, 0, action, 1, delay, TimerType.Async); AddTask(task); return task; &#125; public void ClearInterval(int id, bool isAll = false) &#123; if (isAll) &#123; RemoveTask(_month, id, isAll); RemoveTask(_day, id, isAll); RemoveTask(_hour, id, isAll); RemoveTask(_minute, id, isAll); RemoveTask(_second, id, isAll); RemoveTask(_millisecond, id, isAll); &#125; else &#123; if (RemoveTask(_month, id)) &#123; return; &#125; if (RemoveTask(_day, id)) &#123; return; &#125; if (RemoveTask(_hour, id)) &#123; return; &#125; if (RemoveTask(_minute, id)) &#123; return; &#125; if (RemoveTask(_second, id)) &#123; return; &#125; if (RemoveTask(_millisecond, id)) &#123; return; &#125; &#125; &#125; private void AddTask(TimerTask task) &#123; _month[task.dateTime.Month].AddLast(task); &#125; private bool RemoveTask(Dictionary&lt;int, LinkedList&lt;TimerTask&gt;&gt; wheel, int id, bool isAll = false) &#123; if (isAll) &#123; bool res = false; foreach (var item in wheel) &#123; LinkedList&lt;TimerTask&gt; tasks = item.Value; foreach (var task in tasks.ToList()) &#123; if (task.id == id) &#123; //ConsoleUtils.Log(&quot;清除任务&quot;, task.id, task.isRemove); tasks.Remove(task); res = true; &#125; &#125; &#125; return res; &#125; else &#123; foreach (var item in wheel) &#123; LinkedList&lt;TimerTask&gt; tasks = item.Value; foreach (var task in tasks) &#123; if (task.id == id) &#123; tasks.Remove(task); return true; &#125; &#125; &#125; return false; &#125; &#125; private int GetId() &#123; return _id++; &#125;&#125; TimerScript12345678910111213141516171819202122232425262728293031323334using System;using System.Collections.Generic;using UnityEngine;public class TimerScript : MonoBehaviour&#123; private Queue&lt;(int, Action)&gt; _actions = new Queue&lt;(int, Action)&gt;(); private Dictionary&lt;int, bool&gt; _register = new Dictionary&lt;int, bool&gt;(); void Update() &#123; while (_actions.Count &gt; 0) &#123; (int, Action) item = _actions.Dequeue(); Run(item.Item2); _register.Remove(item.Item1); &#125; &#125; public void AddAction(int id, Action action) &#123; if (!_register.ContainsKey(id)) &#123; _actions.Enqueue((id, action)); _register.Add(id, true); &#125; &#125; private void Run(Action action) &#123; action.Invoke(); &#125;&#125; 更新日志2023-12-20 修复bug 2023-12-20 更新基础版本。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"Unity编辑器拓展-自定义Mono脚本Inspector","slug":"Unity编辑器拓展-自定义Mono脚本Inspector","date":"2023-11-28T19:03:01.000Z","updated":"2023-11-28T19:57:05.624Z","comments":true,"path":"article/5b49262a8f1d/","link":"","permalink":"https://busyogg.github.io/article/5b49262a8f1d/","excerpt":"","text":"简介有时候我们需要在某个功能开启的情况下编辑一些参数，这时候就可以自定义Inspector面板的显示逻辑来实现这一需求。 原理Unity提供自定义编辑器的功能，通过使用属性标签[CustomEditor(typeof(CustomClass))]定义一个编辑器类来自定义我们需要的Inspector显示。如果需要多选编辑的话，只要再加一个属性标签[CanEditMultipleObjects]即可。 实现我们需要一个原始的MonoBehaviour类，以及一个派生Editor的类，即我们自定义修改某一MonoBehaviour类显示面板的类。 假设我们有一个MonoBehaviour类如下： MonoBehaviour类123456using UnityEngine;public class Test : MonoBehaviour&#123; public bool _isShow = false; public int _initNum = 0;&#125; 我们要实现如下需求：当_isShow为true的时候在面板上显示_initNum。 我们需要这样一个Editor类： 12345678910111213141516171819using UnityEditor;[CustomEditor(typeof(Test))][CanEditMultipleObjects]public class TestEditor : Editor&#123; public override void OnInspectorGUI() &#123; Test test = (Test)target; test._isShow = EditorGUILayout.Toggle(&quot;是否显示&quot;, test._isShow); if(test._isShow) &#123; EditorGUI.indentLevel++; test._initNum = EditorGUILayout.IntField(&quot;InitNum&quot;, test._initNum); EditorGUI.indentLevel--; &#125; &#125;&#125; Editor类的编写方式和普通的Editor拓展一样，需要注意的是没有写的属性也不会出现在Inspector中，这个类相当于完全接管原来的面板显示逻辑。 为了更好分辨面板属性层级，我们也可以用EditorGUI.indentLevel来缩进。或者使用EditorGUILayout.Space()，根据具体情况即可。 当然，显示属性的方法也可以和官方文档一样。具体直接看官方文档即可。","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"红点系统","slug":"红点系统","date":"2023-11-09T07:43:02.000Z","updated":"2023-11-09T08:58:38.804Z","comments":true,"path":"article/5daef1721d9d/","link":"","permalink":"https://busyogg.github.io/article/5daef1721d9d/","excerpt":"","text":"简介游戏中经常会需要红点来提醒玩家有新内容，每个部分单独控制红点显然不是个好办法，因此需要红点系统来统一管理红点。 原理所有红点根据层级关系组织成红点树，每次有数据变化就从红点树的叶子结点开始向上更新。 红点树属性红点数有_children来保存所有下属节点，有_parent来回溯上游节点，并且每个节点都有_path来记录红点在红点树中的路径。 _dotNum表示当前红点节点的数据，_isShow用来控制当前红点节点是否需要显示红点。 红点_type分为两类，一类是Eternal，只有红点数量归零的时候才不显示；一类是Once，一旦红点数量变少就不再显示。 当红点数量发生变化的时候会调用_onRedDotChangedCallback方法执行对应的操作。 1234567891011121314151617181920212223export enum RedDotType &#123; Eternal, Once&#125;export default class RedDot &#123; /** 父节点 */ private _parent:RedDot | null; /** 子节点 */ private _children; /** 红点节点路径 */ public _path: string; /** 红点数量 */ private _dotNum; /** 是否展示红点 */ private _isShow; /** 红点类型 */ private _type:RedDotType; private _onRedDotChangedCallback: Function | null; //----- function start -----&#125; 方法添加红点子节点先获取需要添加的红点节点的路径，判断是否已添加。未添加的情况下我们设置当前红点节点的子节点为需要添加的节点，设置需要添加节点的父节点为当前节点，并且走一遍红点变化的逻辑，防止出现bug。 12345678910111213141516171819/** * 添加红点子节点 * @param child */public addChild(child: RedDot) &#123; let path = child._path; if (!this._children[path]) &#123; this._children[path] = child; child._parent = this; //子节点有展示红点 则该节点必展示红点 if (child._isShow) &#123; this._isShow = true; &#125; //改变红点数量 this.changeDotNum(child.getDotNum()); &#125; else &#123; console.warn(&quot;红点节点重复添加：&quot;, path); &#125;&#125; 改变红点数量首先我们保存当前节点的红点数量，然后根据传入的变化数量对当前节点红点数量进行改变。 改变之后会发生两种情况： 红点数量小于等于0，这时候我们置红点为不显示。 红点数量大于0，如果传入的变化量大于0，则红点显示；否则根据红点类型判断，如果是Once，则红点数量归零，并且置为不显示。 处理完当前节点的红点数量后，我们回溯父节点，对父节点进行同样的操作。不过传入的变化量需要根据当前节点是否显示红点来判断，如果是不显示红点，则我们传入负的之前保存的节点红点数量；显示红点，则传入该方法传入的参数。 1234567891011121314151617181920212223242526/** * 改变红点数量 * @param num */public changeDotNum(num: number) &#123; let defDotNum = this._dotNum; this._dotNum += num; //判断是否展示红点 if (this._dotNum &lt;= 0) &#123; this._dotNum = 0; this._isShow = false; &#125; else &#123; if(num &gt; 0)&#123; this._isShow = true; &#125;else&#123; if(this._type == RedDotType.Once)&#123; this._dotNum = 0; this._isShow = false; &#125; &#125; &#125; //触发红点变化回调 this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow); //父节点改变红点数量 this._parent &amp;&amp; this._parent.changeDotNum(this._isShow ? num : -defDotNum);&#125; 其他基础功能，根据函数内容即可得知作用。 1234567891011121314151617181920212223242526272829303132333435/** * 获得所有子节点 * @returns */public getChildren()&#123; return this._children;&#125;/** * 是否展示红点 * @returns */public checkShow() &#123; this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow);&#125;/** * 获得红点数量 * @returns */public getDotNum() &#123; return this._dotNum;&#125;/** * 设置红点变化回调 * @param callback */public onRedDotChanged(callback) &#123; this._onRedDotChangedCallback = callback;&#125;/** * 移除红点变化回调 */public removeRedDotChange()&#123; this._onRedDotChangedCallback = null;&#125; 红点管理类管理类维护一个红点字典_redDotDic，用于快速查找对应路径的红点。 初始化初始化一个root红点，该红点是所有红点的根节点。 12345678/** * 初始化红点树 */public init() &#123; let root = new RedDot(null, RedDotType.Eternal); root._path = &quot;root&quot;; this._redDotDic[&quot;root&quot;] = root;&#125; 注册红点用于注册红点的方法。先判断红点是否已注册，未注册的情况下执行注册方法： 裁剪红点路径，根据”&#x2F;“分开。 根据红点路径长度循环判断是否注册过红点，未注册则新建红点并保存到红点字典，红点路径每次也会根据红点层级拼接。如果新建的红点是最终路径，则返回该红点。 123456789101112131415161718192021222324252627282930313233/** * 注册红点 * @param redDot */public register(path: string, type: RedDotType = RedDotType.Eternal): RedDot &#123; let leaf = this.getRedDot(path); if (!leaf) &#123; let redDotPath = path.split(&quot;/&quot;); let index = 0; let curDic = this._redDotDic[&quot;root&quot;] as RedDot; let subPath = &quot;&quot;; while (index &lt; redDotPath.length) &#123; let child = curDic.getChildren()[redDotPath[index]]; subPath += (index == 0 ? &quot;&quot; : &quot;/&quot;) + redDotPath[index]; if (!child) &#123; let newRedDot = new RedDot(null, type); newRedDot._path = subPath; curDic.addChild(newRedDot); if (index == redDotPath.length - 1) &#123; leaf = newRedDot; &#125; child = newRedDot; this._redDotDic[subPath] = child; &#125; curDic = child; index++; &#125; &#125; return leaf;&#125; 其他基础功能，根据函数内容即可得知作用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 改变红点数据 * @param path * @param num */public changeDotNum(path, num) &#123; let redDot = this.getRedDot(path); if (redDot) &#123; redDot.changeDotNum(num); &#125; else &#123; console.warn(&quot;不存在该红点&quot;, path); &#125;&#125;/** * 设置红点回调 * @param path * @param callback */public setRedDotCallback(path,callback)&#123; let redDot = this.getRedDot(path); if(redDot)&#123; redDot.onRedDotChanged(callback); &#125;&#125;/** * 移除红点回调 * @param path */public removeRedDotCallback(path)&#123; let redDot = this.getRedDot(path); if(redDot)&#123; redDot.removeRedDotChange(); &#125;&#125;/** * 获得红点 * @param path * @returns */private getRedDot(path: string): RedDot &#123; return this._redDotDic[path];&#125;public getRoot() &#123; return this._redDotDic[&quot;root&quot;];&#125; 代码RedDot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import &#123; RedDotType &#125; from &quot;./RedDotManager&quot;;export default class RedDot &#123; /** 父节点 */ private _parent:RedDot | null; /** 子节点 */ private _children; /** 红点节点路径 */ public _path: string; /** 红点数量 */ private _dotNum; /** 是否展示红点 */ private _isShow; /** 红点类型 */ private _type:RedDotType; private _onRedDotChangedCallback: Function | null; public constructor(parent = null,type = RedDotType.Eternal) &#123; this._parent = parent; this._children = &#123;&#125;; this._dotNum = 0; this._isShow = false; this._type = type; &#125; /** * 添加红点子节点 * @param child */ public addChild(child: RedDot) &#123; let path = child._path; if (!this._children[path]) &#123; this._children[path] = child; child._parent = this; //子节点有展示红点 则该节点必展示红点 if (child._isShow) &#123; this._isShow = true; &#125; //改变红点数量 this.changeDotNum(child.getDotNum()); &#125; else &#123; console.warn(&quot;红点节点重复添加：&quot;, path); &#125; &#125; /** * 获得所有子节点 * @returns */ public getChildren()&#123; return this._children; &#125; /** * 是否展示红点 * @returns */ public checkShow() &#123; this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow); &#125; /** * 改变红点数量 * @param num */ public changeDotNum(num: number) &#123; let defDotNum = this._dotNum; this._dotNum += num; //判断是否展示红点 if (this._dotNum &lt;= 0) &#123; this._dotNum = 0; this._isShow = false; &#125; else &#123; if(num &gt; 0)&#123; this._isShow = true; &#125;else&#123; if(this._type == RedDotType.Once)&#123; this._dotNum = 0; this._isShow = false; &#125; &#125; &#125; //触发红点变化回调 this._onRedDotChangedCallback &amp;&amp; this._onRedDotChangedCallback(this._isShow); //父节点改变红点数量 this._parent &amp;&amp; this._parent.changeDotNum(this._isShow ? num : -defDotNum); &#125; /** * 获得红点数量 * @returns */ public getDotNum() &#123; return this._dotNum; &#125; /** * 设置红点变化回调 * @param callback */ public onRedDotChanged(callback) &#123; this._onRedDotChangedCallback = callback; &#125; /** * 移除红点变化回调 */ public removeRedDotChange()&#123; this._onRedDotChangedCallback = null; &#125;&#125; RedDotManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import RedDot from &quot;./RedDot&quot;;export enum RedDotType &#123; Eternal, Once&#125;export default class RedDotManager &#123; private static _instance:RedDotManager | null = null; /** 红点字典 */ private _redDotDic = &#123;&#125;; public static getInst(): RedDotManager &#123; if (!this._instance) &#123; this._instance = new RedDotManager(); &#125; return this._instance; &#125; /** * 初始化红点树 */ public init() &#123; let root = new RedDot(null, RedDotType.Eternal); root._path = &quot;root&quot;; this._redDotDic[&quot;root&quot;] = root; &#125; /** * 注册红点 * @param redDot */ public register(path: string, type: RedDotType = RedDotType.Eternal): RedDot &#123; let leaf = this.getRedDot(path); if (!leaf) &#123; let redDotPath = path.split(&quot;/&quot;); let index = 0; let curDic = this._redDotDic[&quot;root&quot;] as RedDot; let subPath = &quot;&quot;; while (index &lt; redDotPath.length) &#123; let child = curDic.getChildren()[redDotPath[index]]; subPath += (index == 0 ? &quot;&quot; : &quot;/&quot;) + redDotPath[index]; if (!child) &#123; let newRedDot = new RedDot(null, type); newRedDot._path = subPath; curDic.addChild(newRedDot); if (index == redDotPath.length - 1) &#123; leaf = newRedDot; &#125; child = newRedDot; this._redDotDic[subPath] = child; &#125; curDic = child; index++; &#125; &#125; return leaf; &#125; /** * 改变红点数据 * @param path * @param num */ public changeDotNum(path, num) &#123; let redDot = this.getRedDot(path); if (redDot) &#123; redDot.changeDotNum(num); &#125; else &#123; console.warn(&quot;不存在该红点&quot;, path); &#125; &#125; /** * 设置红点回调 * @param path * @param callback */ public setRedDotCallback(path,callback)&#123; let redDot = this.getRedDot(path); if(redDot)&#123; redDot.onRedDotChanged(callback); &#125; &#125; /** * 移除红点回调 * @param path */ public removeRedDotCallback(path)&#123; let redDot = this.getRedDot(path); if(redDot)&#123; redDot.removeRedDotChange(); &#125; &#125; /** * 获得红点 * @param path * @returns */ private getRedDot(path: string): RedDot &#123; return this._redDotDic[path]; &#125; public getRoot() &#123; return this._redDotDic[&quot;root&quot;]; &#125;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"}]},{"title":"任务系统","slug":"任务系统","date":"2023-11-07T12:41:52.000Z","updated":"2024-01-23T18:44:11.954Z","comments":true,"path":"article/bcdc7baf0eb9/","link":"","permalink":"https://busyogg.github.io/article/bcdc7baf0eb9/","excerpt":"","text":"简介基于任务树的任务系统，支持普通任务、分支任务，一个系列任务以树的形式保存。任务支持多需求、多奖励。任务进度支持任务开启后统计和预统计。 后续会更新其他功能。 演示 原理任务管理类设置三个字典_lockedMission、_unlockedMission、_doneMission来保存未解锁任务，已解锁任务和已完成任务。 任务数据结构 任务树自身与之间的结构如图所示。 不同任务以树的形式链接，单个任务以链表的形式链接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using System.Collections.Generic;using UnityEngine;public class MissionTree&#123; /// &lt;summary&gt; /// 任务步骤id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务id /// &lt;/summary&gt; public int m_id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务标题 /// &lt;/summary&gt; public string title &#123; get; set; &#125; /// &lt;summary&gt; /// 任务描述 /// &lt;/summary&gt; public string describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类型 /// &lt;/summary&gt; public MissionType type &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类别 /// &lt;/summary&gt; public MissionFilter filter &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标 /// &lt;/summary&gt; public List&lt;int&gt; target &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标描述 /// &lt;/summary&gt; public List&lt;string&gt; target_describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; target_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务完成数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; complete_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励 /// &lt;/summary&gt; public List&lt;string&gt; award &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励数量 /// &lt;/summary&gt; public List&lt;float&gt; award_num &#123; get; set; &#125; /// &lt;summary&gt; /// 是否预统计 /// &lt;/summary&gt; public bool is_pre_count &#123; get; set; &#125; /// &lt;summary&gt; /// 下一任务 /// &lt;/summary&gt; public MissionTree next &#123; get; set; &#125; /// &lt;summary&gt; /// 任务解锁列表 /// &lt;/summary&gt; public List&lt;int&gt; unlock_mission &#123; get; set; &#125; /// &lt;summary&gt; /// 任务分支 /// &lt;/summary&gt; public List&lt;int&gt; branch &#123; get; set; &#125; /// &lt;summary&gt; /// 分支所属任务 /// &lt;/summary&gt; public int branch_belong &#123; get; set; &#125; /// &lt;summary&gt; /// 是否直接解锁 /// &lt;/summary&gt; public bool is_pre_unlock &#123; get; set; &#125; public MissionTree() &#123; target = new List&lt;int&gt;(); target_num = new Dictionary&lt;int, float&gt;(); complete_num = new Dictionary&lt;int, float&gt;(); award = new List&lt;string&gt;(); award_num = new List&lt;float&gt;(); unlock_mission = new List&lt;int&gt;(); target_describe = new List&lt;string&gt;(); branch = new List&lt;int&gt;(); &#125;&#125; 判断任务完成判断任务完成需要判断所有的任务目标完成数量是否都大于等于任务目标需求数量。这里我们遍历任务目标，只要有一个目标数量不达标就可以判断任务未完成。 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 检测任务是否完成/// &lt;/summary&gt;/// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool CheckComplete(MissionTree mission)&#123; for (int i = 0, len = mission.target.Count; i &lt; len; i++) &#123; int target = mission.target[i]; if (mission.is_pre_count) &#123; if (mission.target_num[target] &gt; _preCount[target]) &#123; return false; &#125; &#125; else &#123; if (mission.complete_num.Count == 0 || mission.target_num[target] &gt; mission.complete_num[target]) &#123; return false; &#125; &#125; &#125; return true;&#125; 增加任务目标数量任务目标数量的增加调用SetCompleteNum方法，默认是累加模式。预统计数量的增加则是通过RefreshPreCountNum方法保存数据到_preCount字典中，以供预统计类型任务使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/// &lt;summary&gt;/// 刷新预计数类型任务的完成数量/// &lt;/summary&gt;/// &lt;param name=&quot;targetId&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt;public void RefreshPreCountNum(int targetId, float num, bool isAdd = false)&#123; if (!_preCount.ContainsKey(targetId)) &#123; _preCount.Add(targetId, 0); &#125; if (isAdd) &#123; _preCount[targetId] += num; &#125; else &#123; _preCount[targetId] = num; &#125;&#125;/// &lt;summary&gt;/// 设置任务完成数量/// &lt;/summary&gt;/// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;completeNum&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;isAdd&quot;&gt;&lt;/param&gt;public void SetCompleteNum(int missionId, int targetId, float completeNum, bool isAdd = true)&#123; MissionTree mission; _unlockedMission.TryGetValue(missionId, out mission); if (mission != null) &#123; if (!mission.complete_num.ContainsKey(targetId)) &#123; mission.complete_num.Add(targetId, 0); &#125; if (isAdd) &#123; mission.complete_num[targetId] += completeNum; &#125; else &#123; mission.complete_num[targetId] = completeNum; &#125; //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, false); &#125;&#125; 下一任务任务完成的时候除了推进本任务链的任务以外，还要检测是否有可以解锁的任务，可以解锁则把其从_lockedMission转移到_unlockedMission，任务链完成则转移到_doneMission。在完成任务的时候，调用奖励方法来发放奖励。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void Next(MissionTree mission)&#123; //MissionTree mission = _unlockedMission[missionId]; int missionId = mission.m_id; MissionTree next = mission.next; if (next != null) &#123; if (mission.unlock_mission.Count &gt; 0) &#123; for (int i = 0, len = mission.unlock_mission.Count; i &lt; len; i++) &#123; int id = mission.unlock_mission[i]; MissionTree unlockMission = _lockedMission[id]; _unlockedMission.Add(unlockMission.m_id, unlockMission); _lockedMission.Remove(id); //保存数据 SaveMissionData(id, unlockMission.id, unlockMission.complete_num, false); &#125; &#125; //下一任务 _unlockedMission[missionId] = next; //保存数据 SaveMissionData(missionId, next.id, next.complete_num, false); &#125; else &#123; _unlockedMission.Remove(missionId); _doneMission.Add(missionId, mission); //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, true); &#125; //获得奖励 GetAward(mission); if (mission.filter == MissionFilter.Branch) &#123; bool missionDone = true; foreach (var id in mission.branch) &#123; MissionTree branch = GetUnlockedMissionById(id); if (mission != null) &#123; missionDone = false; break; &#125; &#125; if (!missionDone) &#123; Next(GetUnlockedMissionById(mission.branch_belong)); &#125; &#125;&#125; UI因为任务面板UI是简单拼凑，因此在此不做介绍。有关任务面板滚动列表的说明见滚动列表 代码MissionTree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System.Collections.Generic;using UnityEngine;public class MissionTree&#123; /// &lt;summary&gt; /// 任务步骤id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务id /// &lt;/summary&gt; public int m_id &#123; get; set; &#125; /// &lt;summary&gt; /// 任务标题 /// &lt;/summary&gt; public string title &#123; get; set; &#125; /// &lt;summary&gt; /// 任务描述 /// &lt;/summary&gt; public string describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类型 /// &lt;/summary&gt; public MissionType type &#123; get; set; &#125; /// &lt;summary&gt; /// 任务类别 /// &lt;/summary&gt; public MissionFilter filter &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标 /// &lt;/summary&gt; public List&lt;int&gt; target &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标描述 /// &lt;/summary&gt; public List&lt;string&gt; target_describe &#123; get; set; &#125; /// &lt;summary&gt; /// 任务目标数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; target_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务完成数量 /// &lt;/summary&gt; public Dictionary&lt;int, float&gt; complete_num &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励 /// &lt;/summary&gt; public List&lt;string&gt; award &#123; get; set; &#125; /// &lt;summary&gt; /// 任务奖励数量 /// &lt;/summary&gt; public List&lt;float&gt; award_num &#123; get; set; &#125; /// &lt;summary&gt; /// 是否预统计 /// &lt;/summary&gt; public bool is_pre_count &#123; get; set; &#125; /// &lt;summary&gt; /// 下一任务 /// &lt;/summary&gt; public MissionTree next &#123; get; set; &#125; /// &lt;summary&gt; /// 任务解锁列表 /// &lt;/summary&gt; public List&lt;int&gt; unlock_mission &#123; get; set; &#125; /// &lt;summary&gt; /// 任务分支 /// &lt;/summary&gt; public List&lt;int&gt; branch &#123; get; set; &#125; /// &lt;summary&gt; /// 分支所属任务 /// &lt;/summary&gt; public int branch_belong &#123; get; set; &#125; /// &lt;summary&gt; /// 是否直接解锁 /// &lt;/summary&gt; public bool is_pre_unlock &#123; get; set; &#125; public MissionTree() &#123; target = new List&lt;int&gt;(); target_num = new Dictionary&lt;int, float&gt;(); complete_num = new Dictionary&lt;int, float&gt;(); award = new List&lt;string&gt;(); award_num = new List&lt;float&gt;(); unlock_mission = new List&lt;int&gt;(); target_describe = new List&lt;string&gt;(); branch = new List&lt;int&gt;(); &#125;&#125; MissionManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423using System.Collections;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using UnityEngine;public enum MissionType&#123; Find, Collection, Kill&#125;public enum MissionFilter&#123; Main, Sub, Branch//这个类型一定放最后 因为该类型不参与计算，枚举数不能影响计算&#125;/// &lt;summary&gt;/// 任务管理器/// &lt;para&gt;请在预统计物品数量（即背包、杀人数等）加载之前加载本类，并且在预统计物品数量加载时执行RefreshPreCountNum方法&lt;/para&gt;/// &lt;/summary&gt;public class MissionManager&#123; private static MissionManager instance; private Dictionary&lt;int, MissionTree&gt; _lockedMission = new Dictionary&lt;int, MissionTree&gt;(); private Dictionary&lt;int, MissionTree&gt; _unlockedMission = new Dictionary&lt;int, MissionTree&gt;(); private Dictionary&lt;int, MissionTree&gt; _doneMission = new Dictionary&lt;int, MissionTree&gt;(); private Dictionary&lt;int, MissionSaveData&gt; _missionSaveData = new Dictionary&lt;int, MissionSaveData&gt;(); private Dictionary&lt;int, float&gt; _preCount = new Dictionary&lt;int, float&gt;(); private MissionTree _curMission; public static MissionManager Instance() &#123; if (instance == null) &#123; instance = new MissionManager(); &#125; return instance; &#125; private MissionManager() &#123; &#125; /// &lt;summary&gt; /// 加载存档 /// &lt;/summary&gt; /// &lt;param name=&quot;save&quot;&gt;&lt;/param&gt; public void LoadSaveData(MissionSaveDataSO save) &#123; for (int i = 0, len = save._missionSaveDatas.Count; i &lt; len; i++) &#123; MissionSaveData missionSaveData = save._missionSaveDatas[i]; _missionSaveData.Add(missionSaveData.m_id, missionSaveData); &#125; &#125; public void Init() &#123; //硬编码数据 List&lt;MissionTree&gt; missions = new List&lt;MissionTree&gt;(); MissionTree m1 = new MissionTree(); m1.id = 0; m1.m_id = 0; m1.title = &quot;任务1-1&quot;; m1.describe = &quot;任务1-1的任务描述\\n测试换行&quot;; m1.type = MissionType.Collection; m1.filter = MissionFilter.Main; m1.is_pre_count = true; m1.target.Add(0); m1.target_describe.Add(&quot;收集id=0的物品&quot;); m1.target_num.Add(0, 2); m1.award.Add(&quot;奖励1&quot;); m1.award_num.Add(1); m1.is_pre_unlock = true; MissionTree m2 = new MissionTree(); m2.id = 1; m2.m_id = 0; m2.title = &quot;任务1-2&quot;; m2.describe = &quot;任务1-2的任务描述&quot;; m2.type = MissionType.Collection; m2.filter = MissionFilter.Main; m2.is_pre_count = false; m2.target.Add(0); m2.target_describe.Add(&quot;收集id=0的物品&quot;); m2.target_num.Add(0, 2); //m2.award.Add(&quot;奖励1&quot;); //m2.award_num.Add(1); m1.next = m2; MissionTree m3 = new MissionTree(); m3.id = 0; m3.m_id = 1; m3.title = &quot;任务2-1&quot;; m3.describe = &quot;任务2-1的任务描述&quot;; m3.type = MissionType.Collection; m3.filter = MissionFilter.Sub; m3.is_pre_count = false; m3.target.Add(0); m3.target_describe.Add(&quot;收集id=0的物品&quot;); m3.target_num.Add(0, 2); m3.award.Add(&quot;奖励1&quot;); m3.award_num.Add(1); //m3.is_pre_unlock = true; MissionTree m4 = new MissionTree(); m4.id = 0; m4.m_id = 2; m4.title = &quot;任务3-1&quot;; m4.describe = &quot;任务3-1的任务描述&quot;; m4.type = MissionType.Collection; m4.filter = MissionFilter.Branch; m4.is_pre_count = false; m4.target.Add(0); m4.target_describe.Add(&quot;收集id=0的物品&quot;); m4.target_num.Add(0, 2); m4.award.Add(&quot;奖励1&quot;); m4.award_num.Add(1); m4.is_pre_unlock = true; m4.branch_belong = 0; MissionTree m5 = new MissionTree(); m5.id = 0; m5.m_id = 3; m5.title = &quot;任务4-1&quot;; m5.describe = &quot;任务4-1的任务描述&quot;; m5.type = MissionType.Collection; m5.filter = MissionFilter.Branch; m5.is_pre_count = false; m5.target.Add(0); m5.target_describe.Add(&quot;收集id=0的物品&quot;); m5.target_num.Add(0, 2); m5.award.Add(&quot;奖励1&quot;); m5.award_num.Add(1); m5.is_pre_unlock = true; m5.branch_belong = 0; m1.unlock_mission.Add(1); m2.branch.Add(2); m2.branch.Add(3); missions.Add(m1); missions.Add(m3); missions.Add(m4); missions.Add(m5); //初始化 for (int i = 0, len = missions.Count; i &lt; len; i++) &#123; MissionTree mission = missions[i]; MissionSaveData missionSaveData; _missionSaveData.TryGetValue(mission.m_id, out missionSaveData); if (missionSaveData != null) &#123; if (missionSaveData.isDone) &#123; _doneMission.Add(mission.m_id, mission); &#125; else &#123; while (mission.id != missionSaveData.id) &#123; mission = mission.next; &#125; _unlockedMission.Add(mission.m_id, mission); mission.complete_num = missionSaveData.complete_num; &#125; &#125; else &#123; if (mission.is_pre_unlock) &#123; _unlockedMission.Add(mission.m_id, mission); &#125; else &#123; _lockedMission.Add(mission.m_id, mission); &#125; &#125; &#125; &#125; public MissionTree GetCurMission() &#123; return _curMission; &#125; public Dictionary&lt;int, MissionTree&gt; GetUnlockedMission() &#123; return _unlockedMission; &#125; public Dictionary&lt;int, MissionTree&gt; GetDoneMission() &#123; return _doneMission; &#125; public MissionTree GetUnlockedMissionById(int id) &#123; MissionTree missionTree; _unlockedMission.TryGetValue(id, out missionTree); return missionTree; &#125; /// &lt;summary&gt; /// 获得任务筛选类型文字描述 /// &lt;/summary&gt; /// &lt;param name=&quot;type&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetMissionFilterString(MissionFilter type) &#123; switch (type) &#123; case MissionFilter.Main: default: return &quot;主线&quot;; case MissionFilter.Sub: return &quot;支线&quot;; &#125; &#125; /// &lt;summary&gt; /// 获得任务筛选类型 /// &lt;/summary&gt; /// &lt;param name=&quot;filter&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public MissionFilter GetMissionFileter(string filter) &#123; switch (filter) &#123; case &quot;主线&quot;: default: return MissionFilter.Main; case &quot;支线&quot;: return MissionFilter.Sub; &#125; &#125; /// &lt;summary&gt; /// 刷新预统计类型任务的完成数量 /// &lt;/summary&gt; /// &lt;param name=&quot;targetId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;num&quot;&gt;&lt;/param&gt; public void RefreshPreCountNum(int targetId, float num, bool isAdd = false) &#123; if (!_preCount.ContainsKey(targetId)) &#123; _preCount.Add(targetId, 0); &#125; if (isAdd) &#123; _preCount[targetId] += num; &#125; else &#123; _preCount[targetId] = num; &#125; &#125; /// &lt;summary&gt; /// 获得预统计数量 /// &lt;/summary&gt; /// &lt;param name=&quot;targetId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public float GetPreCountNum(int targetId) &#123; return _preCount[targetId]; &#125; /// &lt;summary&gt; /// 设置任务完成数量 /// &lt;/summary&gt; /// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;completeNum&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;isAdd&quot;&gt;&lt;/param&gt; public void SetCompleteNum(int missionId, int targetId, float completeNum, bool isAdd = true) &#123; MissionTree mission; _unlockedMission.TryGetValue(missionId, out mission); if (mission != null) &#123; if (!mission.complete_num.ContainsKey(targetId)) &#123; mission.complete_num.Add(targetId, 0); &#125; if (isAdd) &#123; mission.complete_num[targetId] += completeNum; &#125; else &#123; mission.complete_num[targetId] = completeNum; &#125; //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, false); &#125; &#125; /// &lt;summary&gt; /// 检测任务是否完成 /// &lt;/summary&gt; /// &lt;param name=&quot;missionId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool CheckComplete(MissionTree mission) &#123; for (int i = 0, len = mission.target.Count; i &lt; len; i++) &#123; int target = mission.target[i]; if (mission.is_pre_count) &#123; if (mission.target_num[target] &gt; _preCount[target]) &#123; return false; &#125; &#125; else &#123; if (mission.complete_num.Count == 0 || mission.target_num[target] &gt; mission.complete_num[target]) &#123; return false; &#125; &#125; &#125; return true; &#125; public void Next(MissionTree mission) &#123; //MissionTree mission = _unlockedMission[missionId]; int missionId = mission.m_id; MissionTree next = mission.next; if (next != null) &#123; if (mission.unlock_mission.Count &gt; 0) &#123; for (int i = 0, len = mission.unlock_mission.Count; i &lt; len; i++) &#123; int id = mission.unlock_mission[i]; MissionTree unlockMission = _lockedMission[id]; _unlockedMission.Add(unlockMission.m_id, unlockMission); _lockedMission.Remove(id); //保存数据 SaveMissionData(id, unlockMission.id, unlockMission.complete_num, false); &#125; &#125; //下一任务 _unlockedMission[missionId] = next; //保存数据 SaveMissionData(missionId, next.id, next.complete_num, false); &#125; else &#123; _unlockedMission.Remove(missionId); _doneMission.Add(missionId, mission); //保存数据 SaveMissionData(missionId, mission.id, mission.complete_num, true); &#125; //获得奖励 GetAward(mission); if (mission.filter == MissionFilter.Branch) &#123; MissionTree branchMissionRoot = GetUnlockedMissionById(mission.branch_belong); bool missionDone = true; foreach (var id in branchMissionRoot.branch) &#123; MissionTree branch = GetUnlockedMissionById(id); if (branch != null) &#123; missionDone = false; break; &#125; &#125; if (missionDone) &#123; Next(branchMissionRoot); &#125; &#125; &#125; private void GetAward(MissionTree mission) &#123; string award = &quot;&quot;; for (int i = 0, len = mission.award.Count; i &lt; len; i++) &#123; award += mission.award[i] + &quot; 数量:&quot; + mission.award_num[i]; &#125; Debug.Log(&quot;获得任务奖励 ===&gt; &quot; + award); &#125; private void SaveMissionData(int missionId, int stepId, Dictionary&lt;int, float&gt; completeNum, bool isDone) &#123; //保存数据 MissionSaveData missionSaveData; _missionSaveData.TryGetValue(missionId, out missionSaveData); if (missionSaveData == null) &#123; missionSaveData = new MissionSaveData(); missionSaveData.m_id = missionId; _missionSaveData.Add(missionId, missionSaveData); &#125; missionSaveData.id = stepId; missionSaveData.complete_num = completeNum; missionSaveData.isDone = isDone; &#125;&#125; 更新日志2023-12-12 修复分支任务判定bug。 2023-11-7 1.更新基础版本","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"UGUI循环列表","slug":"UGUI循环列表","date":"2023-11-07T07:56:56.000Z","updated":"2024-01-23T18:44:12.004Z","comments":true,"path":"article/9d7f93194d78/","link":"","permalink":"https://busyogg.github.io/article/9d7f93194d78/","excerpt":"","text":"简介UGUI实现滚动列表，支持非固定大小的Item以及多种不同的数据，可自定义单元格偏移量、单元格间隔、单元格重复数量限制，可以根据单元格重复数量自动调整滚动方向。 演示单类型单元格 复数类型单元格 使用方法UI 在Canvas上挂载Scroll View预制体，选中Content对象，挂载管理脚本。预制体中默认挂载了一个TestScrollView脚本。 PrefabItem列表用于挂载不同的Item预制体，需要多少种就挂载多少个。 Stack用于获取对象池节点，即上图的Stack节点。 Scroll用于获取Scroll View节点。 FitSize开启后列表将渲染所有单元格，并且面板大小自动调整为适合的大小，并禁止滚动。 SpaceX，单元格X方向间隔。 SpaceY，单元格Y方向间隔。 OffsetX，列表X方向偏移。 OffsetY，列表Y方向偏移。 RepeatX，列表X方向单元格最大数量。0为无限制。 RepeatY，列表Y方向单元格最大数量。0为无限制。当RepeatX设置后，该项失效（可能会出bug，不建议同时设置）。 代码Content对象挂载的脚本需要继承ScrollViewScript。如TestScrollView： TestScrollView123456789101112131415161718192021222324252627282930313233343536373839404142434445using System.Collections.Generic;using TMPro;public class TestScrollView : ScrollViewScript&lt;int&gt;&#123; private List&lt;int&gt; _subData = new List&lt;int&gt;(); void Awake() &#123; for (int i = 0; i &lt; 10; i++) &#123; _subData.Add(i); &#125; actions.Add(UpdateItem); actions.Add(UpdateItem); &#125; protected override void InitItemType() &#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); int i = 0; int j = 0; while (i &lt; data.Count || j &lt; _subData.Count) &#123; if (i &lt; data.Count) &#123; type.Add(new int[] &#123; 0, i++ &#125;); &#125; if (j &lt; _subData.Count) &#123; type.Add(new int[] &#123; 1, j++ &#125;); &#125; &#125; itemType = type; &#125; private void UpdateItem(ItemTransformData cell, int index) &#123; cell.item.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;单元格 &quot; + data[index]; &#125;&#125; 泛型代表了列表默认数据data的数据类型。对data赋值即可刷新列表。 列表单元格渲染函数需要在Start函数之前定义并存入渲染函数数组actions中。本例中在Awake进行初始化。有多少Item类型就要初始化多少渲染函数，并且顺序要一一对应。不过如果Item数量大于渲染函数数量，程序也不会出问题，如果是中间Item类型的渲染函数不存在，那就会出现渲染函数和Item不匹配。因此最好是一一对应。 如果需要额外的数据，那就需要重写InitItemType方法。 1234567891011121314/// &lt;summary&gt;/// 初始化单元格类型/// &lt;/summary&gt;/// &lt;param name=&quot;itemType&quot;&gt;int[2] 0为button类型 1为对应类型的数据索引&lt;/param&gt;protected virtual void InitItemType()&#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); for (int i = 0, len = _data.Count; i &lt; len; i++) &#123; type.Add(new int[] &#123; 0, i &#125;); &#125; itemType = type;&#125; 该方法负责管理虚拟列表中Item对应索引的Item类型和其在对应数据列表中的索引。 例如： 1234567891011121314151617181920protected override void InitItemType() &#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); int i = 0; int j = 0; while (i &lt; data.Count || j &lt; _subData.Count) &#123; if (i &lt; data.Count) &#123; type.Add(new int[] &#123; 0, i++ &#125;); &#125; if (j &lt; _subData.Count) &#123; type.Add(new int[] &#123; 1, j++ &#125;); &#125; &#125; itemType = type; &#125; _subData为任务滚动列表类自定义的属性，本例根据一个Item0和一个Item1交替填充到itemType中，即管理虚拟列表中Item对应索引的Item类型和其在对应数据列表中的索引的列表中。 注意，如果列表不是单列或单行，建议不要使用多种大小不同的Item混搭，本项目尚未对该情况进行适配，很有可能会出现Item覆盖的情况。 原理概述Item固定大小的循环列表会在滚动面板视野外额外生成一个Item，在上下滚动的时候通过改变额外Item的坐标并且重新渲染该Item来实现列表的滚动效果。 本项目因为需要支持非固定大小的Item，因此使用对象池的方式来模拟。通过判断上下滚动时的头尾节点相较于滚动面板的位置来判断是要回收Item还是创建Item。 单元格根据类型调用对应的渲染函数，在data数据发生变化的时候会刷新列表；在单元格大小发生变化时会刷新单元格坐标。 单元格数据类所有单元格都遵循该类的设置。滚动列表单元格之间按照逻辑顺序使用next和parent形成双向链表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123using UnityEngine;using UnityEngine.UI;public class ItemTransformData&#123; /// &lt;summary&gt; /// 坐标 /// &lt;/summary&gt; public Vector2 pos &#123; get &#123; return _pos; &#125; set &#123; _pos = value; item.transform.localPosition = pos; &#125; &#125; /// &lt;summary&gt; /// 高度 /// &lt;/summary&gt; public float height &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.height; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽度 /// &lt;/summary&gt; public float width &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.width; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽高 /// &lt;/summary&gt; public Vector2 size &#123; set &#123; _item_rect.sizeDelta = value; &#125; &#125; /// &lt;summary&gt; /// 虚拟列表索引 /// &lt;/summary&gt; public int cell_index &#123; get; set; &#125; /// &lt;summary&gt; /// 数据列表索引 /// &lt;/summary&gt; public int item_index &#123; get; set; &#125; /// &lt;summary&gt; /// 单元格对象 /// &lt;/summary&gt; public Button item &#123; get &#123; return _item; &#125; set &#123; _item = value; _item_rect = _item.GetComponent&lt;RectTransform&gt;(); &#125; &#125; /// &lt;summary&gt; /// 单元格类型 /// &lt;/summary&gt; public int item_type &#123; get; set; &#125; /// &lt;summary&gt; /// 下一单元格 /// &lt;/summary&gt; public ItemTransformData next &#123; get; set; &#125; /// &lt;summary&gt; /// 上一单元格 /// &lt;/summary&gt; public ItemTransformData parent &#123; get; set; &#125; private Button _item; private RectTransform _item_rect; private Vector2 _pos; public void CloneTo(ItemTransformData itd) &#123; itd.pos = pos; itd.cell_index = cell_index; itd.item_index = item_index; itd.item = item; itd.item_type = item_type; &#125; public ItemTransformData Clone() &#123; ItemTransformData itd = new ItemTransformData(); CloneTo(itd); return itd; &#125;&#125; 初始化 生成单元格对象池 首先初始化列表的视口大小。 然后遍历Item预制体类型，根据视口大小循环创建Item对象并存入对象池（也可以在运行时创建，根据需求即可）。 根据面板配置设置对应的控制条件。 监听滚动。 根据数据生成单元格 回收所有显示的单元格。 初始化虚拟列表 while循环生成单元格，非FitSize情况下当单元格超出视界后不生成，只获取并计算位置和大小信息。 列表滚动刷新前提条件：Y轴向下为负值，向下滚动为滚动面板Y值增加，X方向相反 滚动列表刷新按照滚动方向分为两类： 向下\\右滚动 对于头单元格，当其Y方向最低点加上滚动距离大于0时，或者其X方向最右点加上滚动距离小于0时，回收头单元格，然后置头单元格为下一单元格（next）。 Y：_head.pos.y - _head.height + rect &gt; 0 X：_head.pos.x + _head.width + rect &lt; 0 对于尾单元格，当其Y方向最高点加上滚动距离大于负的滚动面板高度时，或者其X方向最左点加上滚动距离小于滚动面板宽度时，生成新单元格，并置尾单元格为该单元格。 Y：_tail.pos.y + rect &gt; -_viewHeight X：_tail.pos.x + rect &lt; _viewWidth 向上\\左滚动 对于头单元格，当其Y方向最低点加上滚动距离小于0时，或者其X方向最右点加上滚动距离大于0时，生成新单元格，并置头单元格为该单元格。 Y：_head.pos.y - _head.height + rect &lt; 0 X：_head.pos.x + _head.width + rect &gt; 0 对于尾单元格，当其Y方向最高点加上滚动距离小于负的滚动面板高度时，或者其X方向最左点加上滚动距离大于滚动面板宽度时，回收尾单元格，然后置尾单元格为上一单元格（parent）。 Y：_tail.pos.y + rect &lt; -_viewHeight X：_tail.pos.x + rect &gt; _viewWidth 改变单元格大小调用SetCellSize方法设置单元格大小，并且默认刷新单元格位置。 代码ItemTransformData123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123using UnityEngine;using UnityEngine.UI;public class ItemTransformData&#123; /// &lt;summary&gt; /// 坐标 /// &lt;/summary&gt; public Vector2 pos &#123; get &#123; return _pos; &#125; set &#123; _pos = value; item.transform.localPosition = pos; &#125; &#125; /// &lt;summary&gt; /// 高度 /// &lt;/summary&gt; public float height &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.height; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽度 /// &lt;/summary&gt; public float width &#123; get &#123; if (_item_rect) &#123; return _item_rect.rect.width; &#125; else &#123; return 0f; &#125; &#125; &#125; /// &lt;summary&gt; /// 宽高 /// &lt;/summary&gt; public Vector2 size &#123; set &#123; _item_rect.sizeDelta = value; &#125; &#125; /// &lt;summary&gt; /// 虚拟列表索引 /// &lt;/summary&gt; public int cell_index &#123; get; set; &#125; /// &lt;summary&gt; /// 数据列表索引 /// &lt;/summary&gt; public int item_index &#123; get; set; &#125; /// &lt;summary&gt; /// 单元格对象 /// &lt;/summary&gt; public Button item &#123; get &#123; return _item; &#125; set &#123; _item = value; _item_rect = _item.GetComponent&lt;RectTransform&gt;(); &#125; &#125; /// &lt;summary&gt; /// 单元格类型 /// &lt;/summary&gt; public int item_type &#123; get; set; &#125; /// &lt;summary&gt; /// 下一单元格 /// &lt;/summary&gt; public ItemTransformData next &#123; get; set; &#125; /// &lt;summary&gt; /// 上一单元格 /// &lt;/summary&gt; public ItemTransformData parent &#123; get; set; &#125; private Button _item; private RectTransform _item_rect; private Vector2 _pos; public void CloneTo(ItemTransformData itd) &#123; itd.pos = pos; itd.cell_index = cell_index; itd.item_index = item_index; itd.item = item; itd.item_type = item_type; &#125; public ItemTransformData Clone() &#123; ItemTransformData itd = new ItemTransformData(); CloneTo(itd); return itd; &#125;&#125; ScrollViewScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642using System;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class ScrollViewScript&lt;T&gt; : MonoBehaviour&#123; /// &lt;summary&gt; /// 单元格预制体 /// &lt;/summary&gt; public List&lt;Button&gt; PrefabItem; /// &lt;summary&gt; /// 单元格回收节点 /// &lt;/summary&gt; public GameObject Stack; /// &lt;summary&gt; /// 滚动节点 /// &lt;/summary&gt; public ScrollRect Scroll; /// &lt;summary&gt; /// 自适应大小 /// &lt;/summary&gt; public bool FitSize; /// &lt;summary&gt; /// X方向单元格间隔 /// &lt;/summary&gt; public float SpaceX; /// &lt;summary&gt; /// Y方向单元格间隔 /// &lt;/summary&gt; public float SpaceY; /// &lt;summary&gt; /// X方向偏移 /// &lt;/summary&gt; public float OffsetX; /// &lt;summary&gt; /// Y方向偏移 /// &lt;/summary&gt; public float OffsetY; /// &lt;summary&gt; /// X方向重复单元格个数 /// &lt;/summary&gt; public int RepeatX; /// &lt;summary&gt; /// Y方向重复单元格个数 /// &lt;/summary&gt; public int RepeatY; /// &lt;summary&gt; /// 默认列表数据 /// &lt;/summary&gt; public List&lt;T&gt; data &#123; get &#123; return _data; &#125; set &#123; RefreshList(value); &#125; &#125; /// &lt;summary&gt; /// 列表单元格类型 /// &lt;/summary&gt; protected List&lt;int[]&gt; itemType &#123; get &#123; return _itemType; &#125; set &#123; _itemType = value; &#125; &#125; protected List&lt;Action&lt;ItemTransformData, int&gt;&gt; actions &#123; get &#123; return _actions; &#125; &#125; private bool _inited = false; private List&lt;int[]&gt; _itemType = new List&lt;int[]&gt;(); /// &lt;summary&gt; /// 默认列表数据 /// &lt;/summary&gt; private List&lt;T&gt; _data; /// &lt;summary&gt; /// 单元格虚拟数量最大值 /// &lt;/summary&gt; private int _length; /// &lt;summary&gt; /// 显示的单元格列表 /// &lt;/summary&gt; private List&lt;ItemTransformData&gt; _items = new List&lt;ItemTransformData&gt;(); /// &lt;summary&gt; /// 回收的单元格列表 /// &lt;/summary&gt; private List&lt;Stack&lt;ItemTransformData&gt;&gt; _itemStack = new List&lt;Stack&lt;ItemTransformData&gt;&gt;(); /// &lt;summary&gt; /// content面板transform /// &lt;/summary&gt; private RectTransform _rectTransform; /// &lt;summary&gt; /// content视图高度 /// &lt;/summary&gt; private float _viewHeight; /// &lt;summary&gt; /// content视图宽度 /// &lt;/summary&gt; private float _viewWidth; //private int _repeatX; private ItemTransformData _head; private ItemTransformData _tail; private Vector2 _lastScrollPos = new Vector2(); private List&lt;Vector2&gt; _itemPos = new List&lt;Vector2&gt;(); private Dictionary&lt;int, Dictionary&lt;int, Vector2&gt;&gt; _itemSize = new Dictionary&lt;int, Dictionary&lt;int, Vector2&gt;&gt;(); private int _scrollDirection = 0; private List&lt;Action&lt;ItemTransformData, int&gt;&gt; _actions = new List&lt;Action&lt;ItemTransformData, int&gt;&gt;(); public void Start() &#123; _rectTransform = GetComponent&lt;RectTransform&gt;(); _viewWidth = transform.parent.GetComponent&lt;RectTransform&gt;().rect.width; _viewHeight = transform.parent.GetComponent&lt;RectTransform&gt;().rect.height; for (int i = 0, len = PrefabItem.Count; i &lt; len; i++) &#123; //创建回收栈节点对应类型的回收节点 GameObject obj = new GameObject(); obj.name = &quot;ItemType_&quot; + i; obj.transform.SetParent(Stack.transform); Button item = Instantiate(PrefabItem[i]); item.transform.SetParent(obj.transform); RectTransform itemRect = item.GetComponent&lt;RectTransform&gt;(); ItemTransformData itd = new ItemTransformData(); itd.item = item; itd.pos = new Vector2(); itd.item_type = i; if (_itemStack.Count &lt;= i) &#123; _itemStack.Add(new Stack&lt;ItemTransformData&gt;()); &#125; _itemStack[i].Push(itd); for (int j = 0, len2 = (int)Mathf.Ceil(_viewHeight / itd.height) * (int)Mathf.Ceil(_viewWidth / itd.width); j &lt; len2; j++) &#123; Button item2 = Instantiate(PrefabItem[i]); item2.transform.SetParent(obj.transform); RectTransform itemRect2 = item.GetComponent&lt;RectTransform&gt;(); ItemTransformData itd2 = new ItemTransformData(); itd2.item = item2; itd2.pos = new Vector2(); itd2.item_type = i; _itemStack[i].Push(itd2); &#125; &#125; if (FitSize) &#123; Scroll.vertical = false; Scroll.horizontal = false; &#125; else &#123; if (RepeatY != 0) &#123; Scroll.vertical = false; &#125; else &#123; Scroll.horizontal = false; &#125; &#125; Scroll.onValueChanged.AddListener(OnScroll); _inited = true; if (data != null &amp;&amp; data.Count &gt; 0) &#123; data = data; &#125; &#125; private void OnScroll(Vector2 v) &#123; ////Debug.Log(v); if (_head == null || _tail == null) return; float rect; float diff; if (RepeatY != 0) &#123; rect = _rectTransform.localPosition.x; diff = _lastScrollPos.x - rect; &#125; else &#123; rect = _rectTransform.localPosition.y; diff = rect - _lastScrollPos.y; &#125; if (diff &gt; 0) &#123; _scrollDirection = 1; &#125; else if (diff &lt; 0) &#123; _scrollDirection = -1; &#125; else &#123; _scrollDirection = 0; &#125; if (_scrollDirection == 1) &#123; bool checkRecycleHead; if (RepeatY != 0) &#123; checkRecycleHead = _head.pos.x + _head.width + rect &lt; 0; &#125; else &#123; checkRecycleHead = _head.pos.y - _head.height + rect &gt; 0; &#125; if (checkRecycleHead) &#123; if (_head.next != null) &#123; //Debug.Log(&quot;回收头&quot; + _head.cell_index + &quot; == &quot; + _head.next.cell_index); RecycleCell(_head.item_type, _head); _head = _head.next; &#125; &#125; bool checkRecycleTail; if (RepeatY != 0) &#123; checkRecycleTail = _tail.pos.x + rect &lt; _viewWidth; &#125; else &#123; checkRecycleTail = _tail.pos.y + rect &gt; -_viewHeight; &#125; //Debug.Log(_tail.pos.y + rectY + &quot; : &quot; + _viewHeight); if (checkRecycleTail) &#123; int index = _tail.cell_index + 1; if (index &lt; _itemType.Count) &#123; int[] itemType = _itemType[index]; ItemTransformData item = CreateItem(itemType[0]); Vector2 pos = _itemPos[index]; item.cell_index = index; item.item_index = itemType[1]; item.parent = _tail; _tail.next = item; item.pos = pos; item.item.transform.localPosition = pos; item.item.name = index + &quot;&quot;; _tail = item; //Debug.Log(&quot;创建尾&quot; + _tail.cell_index + &quot; &quot; + pos + &quot; &quot; + index); if (itemType[0] &lt; _actions.Count) &#123; _actions[itemType[0]](item, item.item_index); &#125; &#125; &#125; &#125; else if (_scrollDirection == -1) &#123; bool checkRecycleHead; if (RepeatY != 0) &#123; checkRecycleHead = _head.pos.x + _head.width + rect &gt; 0; &#125; else &#123; checkRecycleHead = _head.pos.y - _head.height + rect &lt; 0; &#125; //Debug.Log(_head.pos.y - _head.height + rectY); if (checkRecycleHead) &#123; int index = _head.cell_index - 1; if (index &gt;= 0) &#123; int[] itemType = _itemType[index]; ItemTransformData item = CreateItem(itemType[0]); Vector2 pos = _itemPos[index]; item.cell_index = index; item.item_index = itemType[1]; item.next = _head; _head.parent = item; item.pos = pos; item.item.transform.localPosition = pos; item.item.name = index + &quot;&quot;; _head = item; //Debug.Log(&quot;创建头&quot; + _head.cell_index + &quot; &quot; + pos + &quot; &quot; + index); if (itemType[0] &lt; _actions.Count) &#123; _actions[itemType[0]](item, item.item_index); &#125; &#125; &#125; bool checkRecycleTail; if (RepeatY != 0) &#123; checkRecycleTail = _tail.pos.x + rect &gt; _viewWidth; &#125; else &#123; checkRecycleTail = _tail.pos.y + rect &lt; -_viewHeight; &#125; //Debug.Log(_tail.pos.y + rectY + &quot; : &quot; + -_viewHeight); if (checkRecycleTail) &#123; if (_tail.parent != null) &#123; //Debug.Log(&quot;回收尾&quot; + _tail.cell_index); RecycleCell(_tail.item_type, _tail); _tail = _tail.parent; &#125; &#125; &#125; _lastScrollPos.x = _rectTransform.localPosition.x; _lastScrollPos.y = _rectTransform.localPosition.y; &#125; /// &lt;summary&gt; /// 创建ItemTransformData /// &lt;/summary&gt; /// &lt;param name=&quot;itemType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private ItemTransformData CreateItem(int itemType, bool init = true) &#123; ItemTransformData item; //Debug.Log(itemType + &quot; &quot; + _itemStack.Count); if (_itemStack[itemType].Count &gt; 0) &#123; item = _itemStack[itemType].Pop(); &#125; else &#123; Button button = Instantiate(PrefabItem[itemType]); item = new ItemTransformData(); item.item = button; &#125; if (init) &#123; item.item.transform.SetParent(transform); _items.Add(item); &#125; else &#123; _itemStack[itemType].Push(item); &#125; return item; &#125; /// &lt;summary&gt; /// 回收所有单元格 /// &lt;/summary&gt; private void RecycleAllCells() &#123; for (int i = 0, len = _items.Count; i &lt; len; i++) &#123; ItemTransformData item = _items[i]; item.item.transform.SetParent(Stack.transform.GetChild(item.item_type)); _itemStack[item.item_type].Push(item); &#125; _items.Clear(); _itemPos.Clear(); &#125; /// &lt;summary&gt; /// 回收一个单元格 /// &lt;/summary&gt; /// &lt;param name=&quot;itemType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;itd&quot;&gt;&lt;/param&gt; private void RecycleCell(int itemType, ItemTransformData itd) &#123; itd.item.transform.SetParent(Stack.transform.GetChild(itemType)); //itd.next = null; //itd.parent = null; _items.Remove(itd); _itemStack[itemType].Push(itd); &#125; private Vector2 CalculatePosition(ItemTransformData last, ItemTransformData current) &#123; float bonusX = 0; float bonusY = 0; if (RepeatX != 0) &#123; if (current.cell_index == 0) &#123; bonusX = OffsetX; bonusY = OffsetY; &#125; else if (current.cell_index % RepeatX == 0) &#123; //换行 bonusX = -last.pos.x + OffsetX; bonusY = last.height + SpaceY; &#125; else &#123; bonusX = last.width + SpaceX; &#125; &#125; else if (RepeatY != 0) &#123; if (current.cell_index == 0) &#123; bonusY = OffsetY; bonusX = OffsetX; &#125; else if (current.cell_index % RepeatY == 0) &#123; //换行 bonusX = last.width + SpaceX; bonusY = last.pos.y + OffsetY; &#125; else &#123; bonusY = last.height + SpaceY; &#125; Debug.Log(bonusY); &#125; else &#123; if (current.cell_index == 0) &#123; bonusX = OffsetX; bonusY = OffsetY; &#125; else if (last.pos.x + last.width + SpaceX + current.width &gt; _viewWidth) &#123; //换行 bonusX = -last.pos.x + OffsetX; bonusY = last.height + SpaceY; &#125; else &#123; bonusX = last.width + SpaceX; &#125; &#125; //_tempVec2.x = last.pos.x + bonusX; //_tempVec2.y = last.pos.y - bonusY; Vector2 pos = new Vector2(last.pos.x + bonusX, last.pos.y - bonusY); return pos; &#125; protected void RefreshList(List&lt;T&gt; data) &#123; //Debug.Log(&quot;设置数据&quot;); _data = data; if (_inited) &#123; RecycleAllCells(); InitItemType(); ResetCells(); &#125; &#125; private void ResetCells() &#123; if (FitSize) &#123; _viewWidth = transform.parent.GetComponent&lt;RectTransform&gt;().rect.width; _viewHeight = transform.parent.GetComponent&lt;RectTransform&gt;().rect.height; &#125; ItemTransformData last = new ItemTransformData(); int i = 0; float maxY = 0; float maxX = 0; float maxHeight = 0; float maxWidth = 0; while (i &lt; itemType.Count) &#123; int type = itemType[i][0]; bool isInit = true; if (!FitSize) &#123; if (RepeatY != 0) &#123; isInit = maxX &lt; _viewHeight; &#125; else &#123; isInit = maxY &gt; -_viewHeight; &#125; &#125; ItemTransformData itd = CreateItem(type, isInit); itd.cell_index = i; itd.item_index = itemType[i][1]; itd.item.name = i + &quot;&quot;; if (isInit) &#123; if (type &lt; _actions.Count) &#123; _actions[type](itd, itd.item_index); &#125; &#125; Vector2 pos = CalculatePosition(last, itd); _itemPos.Add(pos); //第一次设置数据的时候初始化单元格大小 之后设置单元格大小 Dictionary&lt;int, Vector2&gt; sizeDic; _itemSize.TryGetValue(type, out sizeDic); if (sizeDic == null) &#123; sizeDic = new Dictionary&lt;int, Vector2&gt;(); _itemSize.Add(type, sizeDic); &#125; if (!sizeDic.ContainsKey(itd.item_index)) &#123; sizeDic.Add(itd.item_index, new Vector2(itd.width, itd.height)); &#125; else &#123; itd.size = sizeDic[itd.item_index]; &#125; itd.pos = pos; last.next = itd; if (i != 0) &#123; itd.parent = last; &#125; last = itd; maxY = pos.y; maxX = pos.x; float maxH = pos.y - itd.height; float maxW = pos.x + itd.width; if (maxH &lt; maxHeight) &#123; maxHeight = maxH; &#125; if (maxW &gt; maxWidth) &#123; maxWidth = maxW; &#125; i++; //Debug.Log(&quot;设置item &quot; + (i - 1) + &quot; &quot; + maxHeight + &quot; &quot; + pos.y + &quot; &quot; + itd.height); &#125; if (_items.Count &gt; 0) &#123; _head = _items[0]; _tail = _items[_items.Count - 1]; &#125; else &#123; _head = null; _tail = null; &#125; //更新UI大小 _rectTransform.sizeDelta = new Vector2(maxWidth, -maxHeight); if (FitSize) &#123; float contentHeight = _rectTransform.rect.height; _viewHeight = contentHeight; float contentWidth = _rectTransform.rect.width; _viewWidth = contentWidth; //if (contentHeight &lt; _viewHeight) //&#123; // _viewHeight = contentHeight; //&#125; RectTransform scrollRect = Scroll.GetComponent&lt;RectTransform&gt;(); scrollRect.sizeDelta = new Vector2(maxWidth, -maxHeight); &#125; &#125; private void Resize() &#123; RecycleAllCells(); ResetCells(); &#125; /// &lt;summary&gt; /// 初始化单元格类型 /// &lt;/summary&gt; /// &lt;param name=&quot;itemType&quot;&gt;int[2] 0为button类型 1为对应类型的数据索引&lt;/param&gt; protected virtual void InitItemType() &#123; List&lt;int[]&gt; type = new List&lt;int[]&gt;(); for (int i = 0, len = _data.Count; i &lt; len; i++) &#123; type.Add(new int[] &#123; 0, i &#125;); &#125; itemType = type; &#125; /// &lt;summary&gt; /// 设置单元格大小 /// &lt;/summary&gt; /// &lt;param name=&quot;itd&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; protected void SetCellSize(ItemTransformData itd, Vector2 size, bool resize = true) &#123; _itemSize[itd.item_type][itd.item_index] = size; if (resize) &#123; Resize(); &#125; &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"UI","slug":"UI","permalink":"https://busyogg.github.io/tags/UI/"}]},{"title":"对话系统","slug":"对话系统","date":"2023-11-02T11:27:14.000Z","updated":"2024-01-23T18:43:33.533Z","comments":true,"path":"article/71fc63e69064/","link":"","permalink":"https://busyogg.github.io/article/71fc63e69064/","excerpt":"","text":"简介通过对话树构造对话系统，支持选项分支、自动对话和对话历史。 演示 原理通过树结构保存对话节点，没有选项的时候进入索引为0的下一节点，有选项的时候根据选项的索引进入对应的下一节点。 DialogueTree1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Collections.Generic;public class DialogueTree&#123; /// &lt;summary&gt; /// id，用来判断对话顺序 /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话id，用来判断所属对话树 /// &lt;/summary&gt; public int d_id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话人 /// &lt;/summary&gt; public string target &#123; get; set; &#125; /// &lt;summary&gt; /// 内容 /// &lt;/summary&gt; public string content &#123; get; set; &#125; /// &lt;summary&gt; /// 选项 /// &lt;/summary&gt; public List&lt;string&gt; selection &#123; get; set; &#125; /// &lt;summary&gt; /// 下一对话 /// &lt;/summary&gt; public List&lt;DialogueTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 特效 暂无用处 /// &lt;/summary&gt; public string effect &#123; get; set; &#125; /// &lt;summary&gt; /// 自动播放速度 /// &lt;/summary&gt; public float autoSpeed &#123; get; set; &#125; public DialogueTree() &#123; next = new List&lt;DialogueTree&gt;(); selection = new List&lt;string&gt;(); &#125;&#125; 自动对话利用协程进行，在遇到选项的时候停止，在选项选择后重新开启自动对话协程；在手动点击下一个对话的情况下停止协程并重新开启一个自动对话的协程。 对话历史则是把每一条对话和选择的选项记录到一个对话列表中，展示的时候只要遍历即可。 UI逻辑UI展示UI展示封装为ShowDialogue，每次调用更新对话人，对话内容，如果有选项则根据选项数量显示选项按钮。同时，在该方法内调用DialogueManager.Instance().RecordDialogue(_content.text);记录对话内容用于回放。 123456789101112131415161718192021/// &lt;summary&gt;/// UI展示/// &lt;/summary&gt;private void ShowDialogue()&#123; _content.text = DialogueManager.Instance().GetContent(); DialogueManager.Instance().RecordDialogue(_content.text); _target.text = DialogueManager.Instance().GetTarget(); List&lt;string&gt; selections = DialogueManager.Instance().GetSelection(); if (selections.Count &gt; 0) &#123; for (int i = 0, len = selections.Count; i &lt; len; i++) &#123; string selection = selections[i]; Button button = _buttons[i]; button.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = selection; button.gameObject.SetActive(true); &#125; &#125;&#125; 开始对话调用DialogueManager.Instance().StartDialogue();方法开始对话，该方法接受一个对话id参数。 开始对话之后，立刻调用ShowDialogue展示对话内容，并且判断是否自动对话，是的情况调用自动对话协程 12345678910111213141516/// &lt;summary&gt;/// 开始对话点击事件/// &lt;/summary&gt;private void OnStartClick()&#123; _start.gameObject.SetActive(false); _dialoguePanel.SetActive(true); DialogueManager.Instance().StartDialogue(0); ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125;&#125; 自动对话利用协程根据每一段对话的速度来决定自动进入下一对话的时间。 点击按钮开启自动对话，再次点击关闭。 自动对话协程等待时间到了之后，先判断是否有下一对话。 是的情况判断下一对话是否有选项，没有选项的情况下进入下一对话，有的话就停止协程。 否的情况，结束对话。 123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// 自动对话点击事件/// &lt;/summary&gt;private void OnAutoClick()&#123; _isAuto = !_isAuto; if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto On&quot;; &#125; else &#123; StopCoroutine(_dialogCo); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto&quot;; &#125;&#125;/// &lt;summary&gt;/// 自动对话协程/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;IEnumerator AutoDialogue()&#123; float speed = DialogueManager.Instance().GetAutoSpeed(); yield return new WaitForSeconds(speed); bool next = DialogueManager.Instance().Next(); if (next) &#123; bool nextSelection = DialogueManager.Instance().GetSelection().Count == 0; if (nextSelection) &#123; StartCoroutine(AutoDialogue()); &#125; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125;&#125; 下一对话首先判断选项按钮是否显示，显示的情况下禁止进入下一对话。否则调用DialogueManager.Instance().Next()进入下一对话，并且调用ShowDialogue()更新UI。如果没有下一对话就结束对话。 在开启自动对话的情况下，先停止上一个自动对话的协程防止冲突，然后另起一个自动对话协程。 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 下一对话点击事件/// &lt;/summary&gt;private void OnNextClick()&#123; if (!_buttons[0].gameObject.activeInHierarchy) &#123; bool next = DialogueManager.Instance().Next(); if (next) &#123; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125; if (_isAuto) &#123; StopCoroutine(_dialogCo); _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125;&#125; 选项点击选项的时候调用DialogueManager.Instance().SetSelect(index)设置当前选项，调用DialogueManager.Instance().RecordDialogue(DialogueManager.Instance().GetSelection()[index])保存已选选项的内容到对话历史中。然后就是和点击下一对话的逻辑一样。另外在完成选择后隐藏所有选项。 1234567891011121314151617181920/// &lt;summary&gt;/// 选项点击事件/// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;private void OnSelectClick(int index)&#123; DialogueManager.Instance().SetSelect(index); DialogueManager.Instance().RecordDialogue(DialogueManager.Instance().GetSelection()[index]); DialogueManager.Instance().Next(); for (int i = 0; i &lt; _buttons.Count; i++) &#123; Button button = _buttons[i]; button.gameObject.SetActive(false); &#125; ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125;&#125; 对话历史对话历史只要调用DialogueManager.Instance().GetRecordedDialogue()获得历史对话列表，然后根据需要输出即可。 1234567891011/// &lt;summary&gt;/// 对话回放点击事件/// &lt;/summary&gt;private void OnRecordClick() &#123; List&lt;string&gt; record = DialogueManager.Instance().GetRecordedDialogue(); for(int i = 0,len = record.Count; i &lt; len; i++) &#123; string rec = record[i]; Debug.Log(rec); &#125;&#125; 对话管理器对话管理器负责简单的数据存储和获取功能。最复杂的部分就在于选择下一对话。 下一对话先判断是否有选项 有选项的情况，下一对话直接根据当前选择的索引去_curDialogue.next中取对应索引的节点。 没有选项的情况，如果_curDialogue.next的计数大于0，即有下一对话，则置当前对话节点_curDialogue为_curDialogue.next[0]（保存的下一对话只有一个，索引为0）。否则置下一对话为null。 下一对话选择完成后，返回成功或失败的结果，用于UI展示。 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 下一对话/// &lt;/summary&gt;public bool Next()&#123; if (_curDialogue.selection.Count == 0) &#123; if (_curDialogue.next.Count &gt; 0) &#123; _curDialogue = _curDialogue.next[0]; return true; &#125; else &#123; _curDialogue = null; return false; &#125; &#125; else &#123; _curDialogue = _curDialogue.next[_select]; return true; &#125;&#125; 代码对话树1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Collections.Generic;public class DialogueTree&#123; /// &lt;summary&gt; /// id，用来判断对话顺序 /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话id，用来判断所属对话树 /// &lt;/summary&gt; public int d_id &#123; get; set; &#125; /// &lt;summary&gt; /// 对话人 /// &lt;/summary&gt; public string target &#123; get; set; &#125; /// &lt;summary&gt; /// 内容 /// &lt;/summary&gt; public string content &#123; get; set; &#125; /// &lt;summary&gt; /// 选项 /// &lt;/summary&gt; public List&lt;string&gt; selection &#123; get; set; &#125; /// &lt;summary&gt; /// 下一对话 /// &lt;/summary&gt; public List&lt;DialogueTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 特效 暂无用处 /// &lt;/summary&gt; public string effect &#123; get; set; &#125; /// &lt;summary&gt; /// 自动播放速度 /// &lt;/summary&gt; public float autoSpeed &#123; get; set; &#125; public DialogueTree() &#123; next = new List&lt;DialogueTree&gt;(); selection = new List&lt;string&gt;(); &#125;&#125; UI脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190using System.Collections;using System.Collections.Generic;using TMPro;using UnityEngine;using UnityEngine.UI;public class RootScript : MonoBehaviour&#123; //UI控件 -----start public TextMeshProUGUI _content; public List&lt;Button&gt; _buttons; public Button _auto; public Button _start; public Button _panel; public Button _record; public TextMeshProUGUI _target; public GameObject _dialoguePanel; //UI控件 -----end /// &lt;summary&gt; /// 是否自动对话 /// &lt;/summary&gt; private bool _isAuto = false; /// &lt;summary&gt; /// 自动对话协程 /// &lt;/summary&gt; private Coroutine _dialogCo; void Start() &#123; DialogueManager.Instance().Init(); _auto.onClick.AddListener(OnAutoClick); _start.onClick.AddListener(OnStartClick); _panel.onClick.AddListener(OnNextClick); _record.onClick.AddListener(OnRecordClick); for (int i = 0, len = _buttons.Count; i &lt; len; i++) &#123; Button button = _buttons[i]; int index = i; button.onClick.AddListener(() =&gt; &#123; OnSelectClick(index); &#125;); &#125; &#125; /// &lt;summary&gt; /// UI展示 /// &lt;/summary&gt; private void ShowDialogue() &#123; _content.text = DialogueManager.Instance().GetContent(); DialogueManager.Instance().RecordDialogue(_content.text); _target.text = DialogueManager.Instance().GetTarget(); List&lt;string&gt; selections = DialogueManager.Instance().GetSelection(); if (selections.Count &gt; 0) &#123; for (int i = 0, len = selections.Count; i &lt; len; i++) &#123; string selection = selections[i]; Button button = _buttons[i]; button.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = selection; button.gameObject.SetActive(true); &#125; &#125; &#125; /// &lt;summary&gt; /// 开始对话点击事件 /// &lt;/summary&gt; private void OnStartClick() &#123; _start.gameObject.SetActive(false); _dialoguePanel.SetActive(true); DialogueManager.Instance().StartDialogue(0); ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125; /// &lt;summary&gt; /// 自动对话点击事件 /// &lt;/summary&gt; private void OnAutoClick() &#123; _isAuto = !_isAuto; if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto On&quot;; &#125; else &#123; StopCoroutine(_dialogCo); _auto.gameObject.transform.GetChild(0).GetComponent&lt;TextMeshProUGUI&gt;().text = &quot;Auto&quot;; &#125; &#125; /// &lt;summary&gt; /// 下一对话点击事件 /// &lt;/summary&gt; private void OnNextClick() &#123; if (!_buttons[0].gameObject.activeInHierarchy) &#123; bool next = DialogueManager.Instance().Next(); if (next) &#123; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125; if (_isAuto) &#123; StopCoroutine(_dialogCo); _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125; &#125; /// &lt;summary&gt; /// 选项点击事件 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; private void OnSelectClick(int index) &#123; DialogueManager.Instance().SetSelect(index); DialogueManager.Instance().RecordDialogue(DialogueManager.Instance().GetSelection()[index]); DialogueManager.Instance().Next(); for (int i = 0; i &lt; _buttons.Count; i++) &#123; Button button = _buttons[i]; button.gameObject.SetActive(false); &#125; ShowDialogue(); if (_isAuto) &#123; _dialogCo = StartCoroutine(AutoDialogue()); &#125; &#125; /// &lt;summary&gt; /// 对话回放点击事件 /// &lt;/summary&gt; private void OnRecordClick() &#123; List&lt;string&gt; record = DialogueManager.Instance().GetRecordedDialogue(); for(int i = 0,len = record.Count; i &lt; len; i++) &#123; string rec = record[i]; Debug.Log(rec); &#125; &#125; /// &lt;summary&gt; /// 自动对话协程 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; IEnumerator AutoDialogue() &#123; float speed = DialogueManager.Instance().GetAutoSpeed(); yield return new WaitForSeconds(speed); bool next = DialogueManager.Instance().Next(); if (next) &#123; bool nextSelection = DialogueManager.Instance().GetSelection().Count == 0; if (nextSelection) &#123; StartCoroutine(AutoDialogue()); &#125; ShowDialogue(); &#125; else &#123; _start.gameObject.SetActive(true); _dialoguePanel.SetActive(false); &#125; &#125;&#125; 对话管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168using System.Collections.Generic;public class DialogueManager&#123; private static DialogueManager _instance = null; private List&lt;DialogueTree&gt; _dialogues = new List&lt;DialogueTree&gt;(); private DialogueTree _curDialogue = null; private int _select; private List&lt;string&gt; _record = new List&lt;string&gt;(); public static DialogueManager Instance() &#123; if (_instance == null) &#123; _instance = new DialogueManager(); &#125; return _instance; &#125; private DialogueManager() &#123; &#125; public void Init() &#123; DialogueTree d1 = new DialogueTree(); d1.id = 0; d1.d_id = 0; d1.content = &quot;第一条对话&quot;; d1.target = &quot;NPC&quot;; d1.autoSpeed = 2; DialogueTree d2 = new DialogueTree(); d2.id = 1; d2.d_id = 0; d2.content = &quot;第二条对话&quot;; d2.target = &quot;NPC&quot;; d2.autoSpeed = 2; d2.selection.Add(&quot;选项1&quot;); d2.selection.Add(&quot;选项2&quot;); DialogueTree d3 = new DialogueTree(); d3.id = 2; d3.d_id = 0; d3.content = &quot;第三条对话&quot;; d3.target = &quot;NPC&quot;; d3.autoSpeed = 2; DialogueTree d4 = new DialogueTree(); d4.id = 3; d4.d_id = 0; d4.content = &quot;第四条对话&quot;; d4.target = &quot;Player&quot;; d4.autoSpeed = 2; d1.next.Add(d2); d2.next.Add(d3); d2.next.Add(d4); _dialogues.Add(d1); &#125; /// &lt;summary&gt; /// 开始对话 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt; public void StartDialogue(int id) &#123; _curDialogue = _dialogues[id]; &#125; /// &lt;summary&gt; /// 获取对话内容 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetContent() &#123; return _curDialogue?.content; &#125; /// &lt;summary&gt; /// 获取对话人 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string GetTarget() &#123; return _curDialogue?.target; &#125; /// &lt;summary&gt; /// 获得选项 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;string&gt; GetSelection() &#123; return _curDialogue?.selection; &#125; /// &lt;summary&gt; /// 获得自动对话速度 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public float GetAutoSpeed() &#123; return _curDialogue.autoSpeed; &#125; /// &lt;summary&gt; /// 设置选项 /// &lt;/summary&gt; /// &lt;param name=&quot;select&quot;&gt;&lt;/param&gt; public void SetSelect(int select) &#123; _select = select; &#125; /// &lt;summary&gt; /// 下一对话 /// &lt;/summary&gt; public bool Next() &#123; if (_curDialogue.selection.Count == 0) &#123; if (_curDialogue.next.Count &gt; 0) &#123; _curDialogue = _curDialogue.next[0]; return true; &#125; else &#123; _curDialogue = null; return false; &#125; &#125; else &#123; _curDialogue = _curDialogue.next[_select]; return true; &#125; &#125; /// &lt;summary&gt; /// 记录对话 /// &lt;/summary&gt; /// &lt;param name=&quot;content&quot;&gt;&lt;/param&gt; public void RecordDialogue(string content) &#123; _record.Add(content); &#125; /// &lt;summary&gt; /// 获得对话记录 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public List&lt;string&gt; GetRecordedDialogue() &#123; return _record; &#125; /// &lt;summary&gt; /// 清除对话记录 /// &lt;/summary&gt; public void ClearRecordedDialogue() &#123; _record.Clear(); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"连招系统","slug":"连招系统","date":"2023-10-31T17:11:49.000Z","updated":"2024-01-23T18:44:11.953Z","comments":true,"path":"article/69e4e16ef4ee/","link":"","permalink":"https://busyogg.github.io/article/69e4e16ef4ee/","excerpt":"","text":"简介使用有限状态机构造的连招系统，支持技能连招、分支技能、打断、变招、长按技能、蓄力技能。 演示 原理在Update中持续判断状态切换，并根据当前状态执行对应的操作。 状态机分为五个状态，Idle、Running、Holding、Charging以及Waiting。其中Running为非长按技能释放状态；Holding为长按技能；Charging为蓄力技能。 技能树本系统维护一个技能列表，技能列表中保存自定义的技能树。 SkillTree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Collections.Generic;using UnityEngine;public class SkillTree&#123; /// &lt;summary&gt; /// 技能名称 /// &lt;/summary&gt; public string name &#123; get; set; &#125; /// &lt;summary&gt; /// 技能id 一系列技能使用同一id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 键位需求 /// &lt;/summary&gt; public KeyCode key &#123; get; set; &#125; /// &lt;summary&gt; /// 下一连招列表 /// &lt;/summary&gt; public List&lt;SkillTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 技能持续时间 /// &lt;/summary&gt; public float skillTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否正在释放技能 /// &lt;/summary&gt; public bool isRunSkill &#123; get; set; &#125; /// &lt;summary&gt; /// 连招超时时间 /// &lt;/summary&gt; public float outOfTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否可以强制打断技能 /// &lt;/summary&gt; public bool isCanForceStop &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断次数 /// &lt;/summary&gt; public int forceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 默认强制打断次数 /// &lt;/summary&gt; public int defaultForceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断重置时间 /// &lt;/summary&gt; public float forceResetTime &#123; get; set; &#125; /// &lt;summary&gt; /// 技能类型 /// &lt;/summary&gt; public SkillType skillType &#123; get; set; &#125; /// &lt;summary&gt; /// 长按/蓄力时间 /// &lt;/summary&gt; public float holdingTime &#123; get; set; &#125; /// &lt;summary&gt; /// 进度条颜色 /// &lt;/summary&gt; public Color progressColor &#123; get; set; &#125; public SkillTree() &#123; skillType = SkillType.Click; progressColor = Color.white; next = new List&lt;SkillTree&gt;(); &#125;&#125; 本系统还维护当前使用的技能、输入间隔时间、技能持续时间、蓄力&#x2F;长按时间。这些数据是连招判定的相关数据。 连招判定方法我们在技能树中保存了需要按下的按键，只要判断输入事件是否和所需要的键位相同即可。 连招判定分为两个部分，一个是从根技能（即起手式）的情况，一个是判定连招的情况。 根技能的情况下有两种判断，一个是技能打断的判断，一个是开始放技能的判断。我们只要检测最近有无放过技能就能分辨是什么情况的判断。 连招的情况下也有两种情况，一种是连招成功，那么我们就保存当前的技能为连招的技能；另一种是连招失败，即下一个键位不是连招的键位，那么我们就返回一个错误连招的状态。 判定连招键位的时候我们遍历键位列表，即可做出分支攻击。 技能打断限制次数，每次打断都会减少次数，并且开启一个协程等待恢复技能打断次数。本系统的逻辑为第一次打断开始计时，时间到了就恢复次数，不论重置前使用多少次，也不会向后推延倒计时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/// &lt;summary&gt;/// 检测连招是否成功/// &lt;/summary&gt;/// &lt;param name=&quot;isRoot&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private ComboState CheckSkillKey(bool isRoot)&#123; if (Input.anyKeyDown) &#123; if (isRoot) &#123; if (_curSkill != null) &#123; //存在最近技能，并且从技能起手式开始检测 该情况为打断检测 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (skill.isCanForceStop &amp;&amp; skill.forceTimes &gt; 0 &amp;&amp; Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;打断并强制开始连招&quot; + skill.key); StopCoroutine(_skillCo); if (skill.name != _curSkill.name) &#123; _curSkill.isRunSkill = false; //_curSkill.forceTimes = _curSkill.defaultForceTimes; &#125; _curSkill = skill; --_curSkill.forceTimes; bool reset; _forceReset.TryGetValue(_curSkill.id, out reset); if (!reset) &#123; StartCoroutine(WaitForForceTimesReset(_curSkill)); &#125; return ComboState.Success; &#125; &#125; &#125; else &#123; //查找连招起手式 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;开始连招&quot; + skill.key); _curSkill = skill; return ComboState.Success; &#125; &#125; &#125; &#125; else &#123; //检测连招分支 for (int i = 0, len = _curSkill.next.Count; i &lt; len; i++) &#123; SkillTree skill = _curSkill.next[i]; if (Input.GetKeyDown(skill.key)) &#123; //连招成功 _curSkill = _curSkill.next[i]; return ComboState.Success; &#125; &#125; //连错招 重置 Debug.Log(&quot;连招重置&quot;); return ComboState.Wrong; &#125; &#125; return ComboState.Fail;&#125; 状态切换Idle待机状态，这个状态为初始状态，负责接收技能的起手式按键。如果玩家按下的按键是某一技能的起手式，那么当前状态就置为Running、Holding和Charging中的一种（根据技能树设置）。 Running技能执行状态，这个状态负责执行技能等待协程和技能打断判定。 该状态会开启一次技能等待协程，重置技能时间。该状态下会持续增加技能等待时间。技能等待协程执行完毕会自动切换为Waiting状态并且重置技能的执行状态。 如果技能打断成功，则我们就重置输入间隔时间。由于这个时候技能变为了新的，因此会重新执行一次上述行为。 Holding长按技能状态，按住按键技能就一直释放，按键放下就结束并转为Waiting状态。 该状态持续增加长按时间，一旦键位不再持续输入或者超过最大持续时间，就会置状态为Waiting。考虑到按键一松开就会结束长按状态，因此这个状态没有判断技能打断。 Charging蓄力状态，按住按键技能开始蓄力，按键放下就结束并转为Idle状态。 该状态持续增加蓄力时间，一旦键位停止输入，则打断蓄力。由于蓄力未完成，连招中断，因此进入Idle状态。考虑到按键一松开就会结束蓄力状态，所以这个状态没有判断技能打断。 当蓄力时间超过技能所需时间，则转换为Running状态，执行Running状态的技能释放，这时候和普通点按技能释放的效果一样。 总的来说，蓄力技能就是在技能释放状态之前，增加了一个蓄力过程，其他和点按技能一致。 Waiting等待状态，负责技能连招之间的等待输入。该状态下每帧都会增加输入间隔时间，如果输入间隔时间小于技能最大的连招等待时间，并且玩家有输入操作的情况下，就开始判定连招。 连招正确的情况下，重置输入间隔时间，改变连招状态为Running；连招错误的情况下，判断是否有对应按键的起手式，有就立刻转为新的连招并改变状态为Running，否则就置为Idle。 超时的情况下，重置输入间隔时间，并置Idle。 状态执行根据各个状态执行对应的功能即可。该部分只负责实现，不参与控制。 代码技能树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System.Collections.Generic;using UnityEngine;public class SkillTree&#123; /// &lt;summary&gt; /// 技能名称 /// &lt;/summary&gt; public string name &#123; get; set; &#125; /// &lt;summary&gt; /// 技能id 一系列技能使用同一id /// &lt;/summary&gt; public int id &#123; get; set; &#125; /// &lt;summary&gt; /// 键位需求 /// &lt;/summary&gt; public KeyCode key &#123; get; set; &#125; /// &lt;summary&gt; /// 下一连招列表 /// &lt;/summary&gt; public List&lt;SkillTree&gt; next &#123; get; set; &#125; /// &lt;summary&gt; /// 技能持续时间 /// &lt;/summary&gt; public float skillTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否正在释放技能 /// &lt;/summary&gt; public bool isRunSkill &#123; get; set; &#125; /// &lt;summary&gt; /// 连招超时时间 /// &lt;/summary&gt; public float outOfTime &#123; get; set; &#125; /// &lt;summary&gt; /// 是否可以强制打断技能 /// &lt;/summary&gt; public bool isCanForceStop &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断次数 /// &lt;/summary&gt; public int forceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 默认强制打断次数 /// &lt;/summary&gt; public int defaultForceTimes &#123; get; set; &#125; /// &lt;summary&gt; /// 强制打断重置时间 /// &lt;/summary&gt; public float forceResetTime &#123; get; set; &#125; /// &lt;summary&gt; /// 技能类型 /// &lt;/summary&gt; public SkillType skillType &#123; get; set; &#125; /// &lt;summary&gt; /// 长按/蓄力时间 /// &lt;/summary&gt; public float holdingTime &#123; get; set; &#125; /// &lt;summary&gt; /// 进度条颜色 /// &lt;/summary&gt; public Color progressColor &#123; get; set; &#125; public SkillTree() &#123; skillType = SkillType.Click; progressColor = Color.white; next = new List&lt;SkillTree&gt;(); &#125;&#125; 连招控制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469using System;using System.Collections;using System.Collections.Generic;using UnityEditor.Experimental.GraphView;using UnityEngine;using UnityEngine.UI;public class ComboScript : MonoBehaviour&#123; /// &lt;summary&gt; /// 连招状态 /// &lt;/summary&gt; private State _state; /// &lt;summary&gt; /// 技能列表 /// &lt;/summary&gt; private List&lt;SkillTree&gt; _skills = new List&lt;SkillTree&gt;(); /// &lt;summary&gt; /// 当前技能 /// &lt;/summary&gt; private SkillTree _curSkill; /// &lt;summary&gt; /// 输入间隔 /// &lt;/summary&gt; private float _inputDelta = 0; /// &lt;summary&gt; /// 输入间隔进度条控件 /// &lt;/summary&gt; private RectTransform _skillProgress = null; /// &lt;summary&gt; /// 输入间隔进度条图像 /// &lt;/summary&gt; private Image _skillImage; /// &lt;summary&gt; /// 技能进度条控件 /// &lt;/summary&gt; private RectTransform _runProgress = null; /// &lt;summary&gt; /// 技能进度条图像 /// &lt;/summary&gt; private Image _runImage; /// &lt;summary&gt; /// 技能执行时间 /// &lt;/summary&gt; private float _skillTime = 0; /// &lt;summary&gt; /// 长按时间 /// &lt;/summary&gt; private float _holdingTime = 0; private Dictionary&lt;int, bool&gt; _forceReset = new Dictionary&lt;int, bool&gt;(); private Coroutine _skillCo; private Action _onIdle; private Action _onRunning; private Action _onHolding; private Action _onCharging; private Action _onWaiting; void Start() &#123; //获取UI _skillProgress = GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent&lt;RectTransform&gt;(); _skillProgress.sizeDelta = new Vector2(0, 30); _skillImage = GameObject.FindGameObjectWithTag(&quot;Player&quot;).GetComponent&lt;Image&gt;(); _runProgress = GameObject.FindGameObjectWithTag(&quot;Finish&quot;).GetComponent&lt;RectTransform&gt;(); _runProgress.sizeDelta = new Vector2(0, 30); _runImage = GameObject.FindGameObjectWithTag(&quot;Finish&quot;).GetComponent&lt;Image&gt;(); DoChangeState(State.Idle); &#125; // Update is called once per frame void Update() &#123; ChangeState(); &#125; private void OnGUI() &#123; if (_curSkill != null) &#123; if (_inputDelta == 0) &#123; if (_skillProgress.sizeDelta.x != 0) &#123; _skillProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; else &#123; float ratio = (_curSkill.outOfTime - _inputDelta) / _curSkill.outOfTime; if (ratio &lt; 0) &#123; ratio = 0; &#125; _skillProgress.sizeDelta = new Vector2(ratio * 100, 30); _skillImage.color = _curSkill.progressColor; &#125; if (_skillTime == 0) &#123; if (_runProgress.sizeDelta.x != 0) &#123; _runProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; else &#123; float total = _curSkill.skillTime; if (_curSkill.skillType == SkillType.Charge &amp;&amp; _state == State.Charging) &#123; total = _curSkill.holdingTime; &#125; if (total - _skillTime &gt;= 0) &#123; float skillRatio = (total - _skillTime) / total; _runProgress.sizeDelta = new Vector2(skillRatio * 100, 30); _runImage.color = _curSkill.progressColor; &#125; else &#123; _runProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; &#125; else &#123; if (_skillProgress.sizeDelta.x != 0) &#123; _skillProgress.sizeDelta = new Vector2(0, 30); &#125; if (_runProgress.sizeDelta.x != 0) &#123; _runProgress.sizeDelta = new Vector2(0, 30); &#125; &#125; &#125; /// &lt;summary&gt; /// 改变状态 /// &lt;/summary&gt; private void ChangeState() &#123; switch (_state) &#123; case State.Idle: _curSkill = null; //起始技能检测 if (CheckSkillKey(true) == ComboState.Success) &#123; DoChangeState(CheckSkillType(_curSkill.skillType)); &#125; break; case State.Running: //等待技能执行 if (!_curSkill.isRunSkill) &#123; Debug.Log(&quot;执行技能 === &quot; + _curSkill.name + &quot;:&quot; + _curSkill.skillTime); _curSkill.isRunSkill = true; _skillCo = StartCoroutine(WaitForSkill()); &#125; _skillTime += Time.deltaTime; //检测强制打断 if (CheckSkillKey(true) == ComboState.Success) &#123; //_inputDelta = 0; DoChangeState(State.Running); &#125; break; case State.Holding: _holdingTime += Time.deltaTime; _skillTime += Time.deltaTime; if (_holdingTime &gt; _curSkill.holdingTime || !Input.anyKey) &#123; Debug.Log(&quot;超时或没有长按&quot;); DoChangeState(State.Waiting); &#125; else &#123; Debug.Log(&quot;执行长按技能 === &quot; + _curSkill.name); &#125; break; case State.Charging: _holdingTime += Time.deltaTime; _skillTime += Time.deltaTime; if (Input.anyKey) &#123; if (_holdingTime &gt; _curSkill.holdingTime) &#123; Debug.Log(&quot;蓄力完成&quot;); DoChangeState(State.Running); &#125; else &#123; Debug.Log(&quot;蓄力 === &quot; + _curSkill.name); &#125; &#125; else &#123; Debug.Log(&quot;停止蓄力&quot;); DoChangeState(State.Idle); &#125; break; case State.Waiting: //等待中增加间隔时间 _inputDelta += Time.deltaTime; //连击时间小于技能最大间隔时间 if (_inputDelta &lt;= _curSkill.outOfTime) &#123; //连击时间内检测 ComboState res = CheckSkillKey(false); if (res == ComboState.Success) &#123; //连招成功 DoChangeState(CheckSkillType(_curSkill.skillType)); Debug.Log(&quot;连招成功&quot;); &#125; else if (res == ComboState.Wrong) &#123; //连招错误 此处选择立即执行当前连招指令 也可以不执行，放下一帧再判断 if (CheckSkillKey(true) == ComboState.Success) &#123; //如果有招，直接转为别的连招 DoChangeState(CheckSkillType(_curSkill.skillType)); Debug.Log(&quot;转换连招&quot;); &#125; else &#123; //没有别的连招 状态重置 DoChangeState(State.Idle); Debug.Log(&quot;没有新连招&quot;); &#125; &#125; &#125; else &#123; //超时重置 DoChangeState(State.Idle); &#125; break; &#125; &#125; private State CheckSkillType(SkillType type) &#123; switch (type) &#123; case SkillType.Click: return State.Running; case SkillType.Hold: return State.Holding; case SkillType.Charge: return State.Charging; &#125; return State.Running; &#125; /// &lt;summary&gt; /// 执行状态 /// &lt;/summary&gt; private void DoStatus() &#123; switch (_state) &#123; case State.Idle: //RunIdle if (_onIdle != null) &#123; _onIdle(); &#125; break; case State.Running: //RunSkill if (_onRunning != null) &#123; _onRunning(); &#125; break; case State.Holding: //HoldingSkill if (_onHolding != null) &#123; _onHolding(); &#125; break; case State.Charging: //HoldingSkill if (_onCharging != null) &#123; _onCharging(); &#125; break; case State.Waiting: //RunWaiting if (_onWaiting != null) &#123; _onWaiting(); &#125; break; &#125; &#125; private void DoChangeState(State state) &#123; _state = state; _inputDelta = 0; _skillTime = 0; _holdingTime = 0; DoStatus(); Debug.Log(&quot;重置计数器&quot;); &#125; /// &lt;summary&gt; /// 检测连招是否成功 /// &lt;/summary&gt; /// &lt;param name=&quot;isRoot&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private ComboState CheckSkillKey(bool isRoot) &#123; if (Input.anyKeyDown) &#123; if (isRoot) &#123; if (_curSkill != null) &#123; //存在最近技能，并且从技能起手式开始检测 该情况为打断检测 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (skill.isCanForceStop &amp;&amp; skill.forceTimes &gt; 0 &amp;&amp; Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;打断并强制开始连招&quot; + skill.key); StopCoroutine(_skillCo); if (skill.name != _curSkill.name) &#123; _curSkill.isRunSkill = false; //_curSkill.forceTimes = _curSkill.defaultForceTimes; &#125; _curSkill = skill; --_curSkill.forceTimes; bool reset; _forceReset.TryGetValue(_curSkill.id, out reset); if (!reset) &#123; StartCoroutine(WaitForForceTimesReset(_curSkill)); &#125; return ComboState.Success; &#125; &#125; &#125; else &#123; //查找连招起手式 for (int i = 0, len = _skills.Count; i &lt; len; i++) &#123; SkillTree skill = _skills[i]; if (Input.GetKeyDown(skill.key)) &#123; Debug.Log(&quot;开始连招&quot; + skill.key); _curSkill = skill; return ComboState.Success; &#125; &#125; &#125; &#125; else &#123; //检测连招分支 for (int i = 0, len = _curSkill.next.Count; i &lt; len; i++) &#123; SkillTree skill = _curSkill.next[i]; if (Input.GetKeyDown(skill.key)) &#123; //连招成功 _curSkill = _curSkill.next[i]; return ComboState.Success; &#125; &#125; //连错招 重置 Debug.Log(&quot;连招重置&quot;); return ComboState.Wrong; &#125; &#125; return ComboState.Fail; &#125; /// &lt;summary&gt; /// 模拟技能执行时间 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private IEnumerator WaitForSkill() &#123; yield return new WaitForSeconds(_curSkill.skillTime); if (_curSkill != null) &#123; DoChangeState(State.Waiting); _curSkill.isRunSkill = false; &#125; &#125; private IEnumerator WaitForForceTimesReset(SkillTree obj) &#123; Debug.Log(&quot;开始重置强制打断次数 ：&quot; + obj.forceResetTime); yield return new WaitForSeconds(obj.forceResetTime); obj.forceTimes = obj.defaultForceTimes; _forceReset[obj.id] = false; Debug.Log(&quot;重置强制打断次数&quot;); &#125; /// &lt;summary&gt; /// 添加技能 /// &lt;/summary&gt; /// &lt;param name=&quot;skill&quot;&gt;&lt;/param&gt; public void AddSkill(SkillTree skill) &#123; _skills.Add(skill); &#125; /// &lt;summary&gt; /// 获取当前技能 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public SkillTree GetCurSkill() &#123; return _curSkill; &#125; public void OnIdle(Action callback) &#123; _onIdle = callback; &#125; public void OnRunning(Action callback) &#123; _onRunning = callback; &#125; public void OnHolding(Action callback) &#123; _onHolding = callback; &#125; public void OnCharging(Action callback) &#123; _onCharging = callback; &#125; public void OnWaiting(Action callback) &#123; _onWaiting = callback; &#125;&#125; 连招管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 连招状态枚举 空闲|执行中|等待/// &lt;/summary&gt;public enum State&#123; Idle, Running, Holding, Charging, Waiting&#125;/// &lt;summary&gt;/// 连招检测状态枚举 成功|失败|错误/// &lt;/summary&gt;public enum ComboState&#123; Success, Fail, Wrong&#125;public enum SkillType &#123; Click, Hold, Charge&#125;public class ComboManager&#123; private static ComboManager _instance = null; private ComboScript _comboScript; public static ComboManager Instance() &#123; if(_instance == null) &#123; _instance = new ComboManager(); &#125; return _instance; &#125; private ComboManager() &#123; &#125; public void Init() &#123; GameObject root = new GameObject(); root.name = &quot;ComboSystem&quot;; _comboScript = root.AddComponent&lt;ComboScript&gt;(); //初始化技能 此处暂时用代码写死 //实例化技能链 //技能A SkillTree skillA1 = new SkillTree(); skillA1.key = KeyCode.A; skillA1.name = &quot;连招A1&quot;; skillA1.id = 1; skillA1.outOfTime = 0.5f; skillA1.skillTime = 0.5f; skillA1.progressColor = Color.red; SkillTree skillA2 = new SkillTree(); skillA2.key = KeyCode.A; skillA2.name = &quot;连招A2&quot;; skillA2.id = 1; skillA2.outOfTime = 0.5f; skillA2.skillTime = 2f; skillA2.progressColor = new Color(0.8f, 0, 0, 1); skillA2.skillType = SkillType.Hold; skillA2.holdingTime = 2; SkillTree skillA3 = new SkillTree(); skillA3.key = KeyCode.A; skillA3.name = &quot;连招A3-1&quot;; skillA3.id = 1; skillA3.outOfTime = 0.5f; skillA3.skillTime = 0.5f; skillA3.progressColor = new Color(0.6f, 0, 0, 1); SkillTree skillA4 = new SkillTree(); skillA4.key = KeyCode.S; skillA4.name = &quot;连招A3-2&quot;; skillA4.id = 1; skillA4.outOfTime = 0.5f; skillA4.skillTime = 0.5f; skillA4.progressColor = new Color(0.4f, 0, 0, 1); skillA4.skillType = SkillType.Charge; skillA4.holdingTime = 2; skillA1.next.Add(skillA2); skillA2.next.Add(skillA3); skillA2.next.Add(skillA4); _comboScript.AddSkill(skillA1); //技能B SkillTree skillB1 = new SkillTree(); skillB1.key = KeyCode.B; skillB1.name = &quot;连招B1&quot;; skillB1.id = 2; skillB1.outOfTime = 0.5f; skillB1.skillTime = 0.5f; skillB1.isCanForceStop = true; skillB1.forceTimes = 1; skillB1.defaultForceTimes = 1; skillB1.forceResetTime = 5; skillB1.progressColor = Color.green; SkillTree skillB2 = new SkillTree(); skillB2.key = KeyCode.B; skillB2.name = &quot;连招B2&quot;; skillB2.id = 2; skillB2.outOfTime = 0.5f; skillB2.skillTime = 10f; skillB2.progressColor = new Color(0, 0.8f, 0, 1); skillB1.next.Add(skillB2); _comboScript.AddSkill(skillB1); Debug.Log(&quot;初始化完成&quot;); &#125; /// &lt;summary&gt; /// 获得当前技能 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public SkillTree GetCurSkill() &#123; return _comboScript.GetCurSkill(); &#125; /// &lt;summary&gt; /// Idle函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnIdle(Action callback) &#123; _comboScript.OnIdle(callback); &#125; /// &lt;summary&gt; /// Running函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnRunning(Action callback) &#123; _comboScript.OnRunning(callback); &#125; /// &lt;summary&gt; /// Holding函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnHolding(Action callback) &#123; _comboScript.OnHolding(callback); &#125; /// &lt;summary&gt; /// Charging函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnCharging(Action callback) &#123; _comboScript.OnCharging(callback); &#125; /// &lt;summary&gt; /// Waiting函数 /// &lt;/summary&gt; /// &lt;param name=&quot;callback&quot;&gt;&lt;/param&gt; public void OnWaiting(Action callback) &#123; _comboScript.OnWaiting(callback); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"IK算法之Fabrik","slug":"IK算法之Fabrik","date":"2023-10-30T14:29:55.000Z","updated":"2024-01-23T19:06:15.831Z","comments":true,"path":"article/5795c3870390/","link":"","permalink":"https://busyogg.github.io/article/5795c3870390/","excerpt":"","text":"简介IK（反向运动，Inverse Kinematics）是计算运动关节末端(如机械臂臂爪或人物骨架手臂末端的手掌)相对于关节的起始位置和方向到达所需位置的关节参数的数学过程。 –百度百科 Fabrik算法通过计算骨骼节点的空间坐标关系来实现IK的效果。 原理概括Fabrik算法一次迭代执行两个方向的遍历，首先从后往前计算到达目标点情况下所有骨骼的空间位置变化（不包括根节点），然后从前往后计算从根节点出发到达目标节点的骨骼节点位置。 从后往前 首先我们把最后一个骨骼节点置于目标位置，然后从后向前遍历骨骼节点，前一个节点的位置由后一个节点指向前一个节点的方向向量的单位向量乘以骨骼长度加上后一个节点当前的位置得到，即 $\\vec{dir}*length+P_{back}$ $\\vec{dir}&#x3D;normalized(P_{forward}-P_{back})$ 经过一轮遍历之后我们就可以得到除了根节点外的所有节点到达目标点的位置。 从前往后 然后我们从根节点开始从前向后遍历骨骼节点，后一个节点的位置由前一个节点指向后一个节点的方向向量的单位向量乘以骨骼长度加上前一个节点当前的位置得到，即 $\\vec{dir}*length+P_{forward}$ $\\vec{dir}&#x3D;normalized(P_{back}-P_{forward})$ 和从后往前的算法相反。 经过一轮迭代后，我们就可以得到一个相对正确的位置了。 约束因为Fabrik是基于骨骼节点位置的，因此会出现关节往奇怪方向弯曲的问题。所以为了解决这个问题就要对关节进行约束。 我使用向量叉乘来判断当前关节前后两个骨骼的方向是否符合约定的左右关系，不符合的话就旋转方向向量到我们需要的方向。 因为我初次接触IK算法，因此约束相关的内容还没有好的方案，这部分内容就请自行调整。 代码IKData12345678910using System.Collections;using System.Collections.Generic;using UnityEngine;public class IKData&#123; public Vector3 Pos &#123; get; set; &#125; public float Length &#123; get; set; &#125; public Transform Node &#123; get; set; &#125;&#125; IKRootScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152using System;using System.Collections.Generic;using UnityEngine;public class IKRootScript : MonoBehaviour&#123; public List&lt;IKData&gt; _ikList = new List&lt;IKData&gt;(); public Transform _leaf; public Vector3 _lastPos; public List&lt;GameObject&gt; _boneLine = new List&lt;GameObject&gt;(); void Start() &#123; InitBone(transform); InitLength(); _leaf = GameObject.Find(&quot;CtrlPoint&quot;).transform; _lastPos = _leaf.position; Debug.Log(&quot;骨骼数量&quot; + _ikList.Count); CreateBoneLine(); &#125; void LateUpdate() &#123; //控制点发生变化的时候计算IK if (_lastPos != _leaf.position) &#123; //IK迭代 for (int i = 0; i &lt; 3; i++) &#123; IKBack(_leaf.position); IKForward(); &#125; _lastPos = _leaf.position; UpdateBone(); &#125; &#125; /// &lt;summary&gt; /// 初始化骨骼节点 /// &lt;/summary&gt; /// &lt;param name=&quot;trans&quot;&gt;&lt;/param&gt; private void InitBone(Transform trans) &#123; IKData bone = new IKData(); bone.Pos = trans.position; bone.Node = trans; _ikList.Add(bone); if (trans.childCount &gt; 0) &#123; Transform child = trans.GetChild(0); InitBone(child); &#125; &#125; /// &lt;summary&gt; /// 初始化骨骼长度 /// &lt;/summary&gt; private void InitLength() &#123; for (int i = 0, len = _ikList.Count - 1; i &lt; len; i++) &#123; IKData first = _ikList[i]; IKData second = _ikList[i + 1]; first.Length = Math.Abs((second.Pos - first.Pos).magnitude); &#125; &#125; /// &lt;summary&gt; /// 创建骨架 /// &lt;/summary&gt; private void CreateBoneLine() &#123; for (int i = 0, len = _ikList.Count - 1; i &lt; len; i++) &#123; IKData parent = _ikList[i]; IKData child = _ikList[i + 1]; Vector3 center = (parent.Pos + child.Pos) * 0.5f; GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); cube.transform.position = center; cube.transform.localScale = new Vector3(0.2f, 0.2f, parent.Length); cube.transform.LookAt(child.Pos); _boneLine.Add(cube); &#125; &#125; /// &lt;summary&gt; /// 更新骨骼位置 /// &lt;/summary&gt; private void UpdateBone() &#123; for (int i = 0, len = _ikList.Count; i &lt; len; i++) &#123; //更新关节位置 IKData parent = _ikList[i]; parent.Node.position = parent.Pos; //更新骨架位置 if (i &lt; len - 1) &#123; IKData child = _ikList[i + 1]; GameObject cube = _boneLine[i]; Vector3 center = (parent.Pos + child.Pos) * 0.5f; cube.transform.position = center; cube.transform.LookAt(child.Pos); &#125; &#125; &#125; /// &lt;summary&gt; /// 反向迭代 /// &lt;/summary&gt; /// &lt;param name=&quot;target&quot;&gt;&lt;/param&gt; private void IKBack(Vector3 target) &#123; //末节点位置置为target _ikList[_ikList.Count - 1].Pos = target; //遍历迭代 for (int i = _ikList.Count - 1; i &gt; 1; i--) &#123; IKData parent = _ikList[i - 1]; IKData child = _ikList[i]; Vector3 nextBone = (parent.Pos - child.Pos).normalized; Vector3 lastBone = (parent.Pos - _ikList[i - 2].Pos).normalized; Vector3 side = Vector3.Cross(nextBone, lastBone); Debug.Log(i + &quot;:&quot; + side); Vector3 normal = (parent.Pos - child.Pos).normalized; if (side.x &lt;= 0 || side.y &lt;= 0 || side.z &lt;= 0) &#123; //按照权重和旋转方向调整方向向量 normal = Quaternion.Euler(new Vector3(2f, 0, 0)) * normal; &#125; parent.Pos = child.Pos + normal * parent.Length; Debug.Log(i + &quot;:&quot; + normal); &#125; &#125; /// &lt;summary&gt; /// 正向迭代 /// &lt;/summary&gt; private void IKForward() &#123; //遍历迭代 for (int i = 0, len = _ikList.Count - 1; i &lt; len; i++) &#123; IKData parent = _ikList[i]; IKData child = _ikList[i + 1]; Vector3 normal = (child.Pos - parent.Pos).normalized; child.Pos = parent.Pos + normal * parent.Length; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"逆向运动学","slug":"算法/逆向运动学","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"IK","slug":"IK","permalink":"https://busyogg.github.io/tags/IK/"},{"name":"Fabrik","slug":"Fabrik","permalink":"https://busyogg.github.io/tags/Fabrik/"}]},{"title":"碰撞检测之射线与AABB和OBB","slug":"碰撞检测之射线与AABB和OBB","date":"2023-10-15T12:29:10.000Z","updated":"2023-10-26T11:46:58.118Z","comments":true,"path":"article/e2b04b62f691/","link":"","permalink":"https://busyogg.github.io/article/e2b04b62f691/","excerpt":"","text":"简介射线检测可以用于拾取物体、判断前方是否有障碍物、判断是否碰撞等场景，本文介绍射线与AABB以及射线与OBB的检测原理。射线与AABB检测的原理是由射线与OBB检测简化而来，因此放在一起介绍。 原理当我们判断一条射线是否与一个矩形相交的时候，我们可以判断射线和矩形四条边的延长线的交点之间的关系。（slab碰撞检测） 如图所示，我们有一条绿色射线与黑色矩形相交，得到四个点P1、P2、P3、P4。其中在y轴方向的交点为P1、P2，在x轴方向的交点为P3、P4；我们有一条紫色射线与黑色矩形相交，得到四个点P1’、P2’、P3’、P4’。其中在x轴方向的交点为P1’、P2’，在y轴方向的交点为P3’、P4’。 观察图像我们可以发现，当射线与圆相交的时候，P1P2与P3P4在射线上存在相交的部分，当射线与圆不相交的时候，P1’P2’与P3’P4’在射线上不存在相交的部分。 因此我们可以得到一个结论：当矩形两个方向轴上的四条边的延长线与射线相交的时候，所有轴向上的最小交点比最大交点要小，并且所有最小交点的最大值比所有最大交点的最小值都要小，这时候射线与矩形相交。 即：每个轴两条边的两个交点中的近点P1、P3中的最大值，要比远点P2、P4中的最小值还小，这样射线就与矩形相交。 所以对于射线与矩形，我们有$max(P1,P3)&lt;min(P2,P4)$，化为通式的话就是$max(Pmin_x,Pmin_y)&lt;min(Pmax_x,Pmax_y)$ 拓展到三维空间也是一样，二维空间是比较两个轴，三维空间就是比较三个轴，也要满足$max(Pmin_x,Pmin_y,Pmin_z)&lt;min(Pmax_x,Pmax_y,Pmax_z)$的关系。 在OBB中我们设射线R的起点为C1，长度为t，方向为Dir；平面S的法线为n，平面中一点为D，平面到原点的距离为d，平面与射线的交点为P，我们可以得到 射线的方程为： $P&#x3D;C1+t*Dir$ 平面的方程为： $Dot(P,n)&#x3D;d$ 当射线与平面相交的时候，两个方程的值相等，我们可以得到如下关系： $Dot(C1+t*Dir,n)&#x3D;d$ 由于点乘符合分配律，所以方程化为： $Dot(C1,n)+Dot(t*Dir,n)&#x3D;d$ 我们想要求出射线的长度t，因此方程改造一下变成： $Dot(t*Dir,n)&#x3D;d-Dot(C1,n)$ 由于点乘符合结合律，所以方程化为： $t*Dot(Dir,n)&#x3D;d-Dot(C1,n)$ 化简得到： $t&#x3D;(d-Dot(C1,n))&#x2F;Dot(Dir,n)$ 因为我们不知道，根据平面方程，我们可以得到： $t&#x3D;(Dot(P,n)-Dot(C1,n))&#x2F;Dot(Dir,n)$ 由分配律，我们最终得到： $t&#x3D;(Dot(P-C1,n))&#x2F;Dot(Dir,n)$ 在OBB包围盒中，最大点和最小点分别横跨三个最大面和最小面，因此满足方程： $Dot(P_{min},n)&#x3D;d$ $Dot(P_{max},n)&#x3D;d$ 所以，三个最小面的最小距离为： $t&#x3D;(Dot(P_{min}-C1,n))&#x2F;Dot(Dir,n)$ 三个最大面的最大距离为： $t&#x3D;(Dot(P_{max}-C1,n))&#x2F;Dot(Dir,n)$ 最后，我们只需要判断$max(t_{min_x},t_{min_y},t_{min_z})&lt;min(t_{max_x},t_{max_y},t_{max_z})$就能知道是否相交。 交点只要带入射线方程即可得到。 需要注意的是，我们都是以射线和包围盒方向轴同向为正方向，因此当方向相反的时候（$Dot(Dir,n)&lt;0$），我们要交换$t_{min}$和$t_{max}$的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//包围盒数据结构public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f; public Vector3 direction = Vector3.zero; public Vector3[] vertexts = new Vector3[8]; public Vector3[] axes = new Vector3[3];&#125;---------------------------------------------/// &lt;summary&gt;/// 射线和OBB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionRay2OBB(CollisionData data1,CollisionData data2)&#123; //判断不在OBB内 Vector3 centerDis = data1.center - data2.center; float ray2ObbX = Vector3.Dot(centerDis, data2.axes[0]); float ray2ObbY = Vector3.Dot(centerDis, data2.axes[1]); float ray2ObbZ = Vector3.Dot(centerDis, data2.axes[2]); bool checkNotInside = ray2ObbX &lt; -data2.extents[0] || ray2ObbX &gt; data2.extents[0] || ray2ObbY &lt; -data2.extents[1] || ray2ObbY &gt; data2.extents[1] || ray2ObbZ &lt; -data2.extents[2] || ray2ObbZ &gt; data2.extents[2]; //判断反向情况 bool checkFoward = Vector3.Dot(data2.center - data1.center, data1.direction) &lt; 0; if (checkNotInside &amp;&amp; checkFoward) &#123; return false; &#125; //判断是否相交 Vector3 min = Vector3.zero; Vector3 minP = data2.vertexts[4] - data1.center; min.x = Vector3.Dot(minP, data2.axes[0]); min.y = Vector3.Dot(minP, data2.axes[1]); min.z = Vector3.Dot(minP, data2.axes[2]); Vector3 max = Vector3.zero; Vector3 maxP = data2.vertexts[2] - data1.center; max.x = Vector3.Dot(maxP, data2.axes[0]); max.y = Vector3.Dot(maxP, data2.axes[1]); max.z = Vector3.Dot(maxP, data2.axes[2]); Vector3 projection = Vector3.zero; projection.x = 1 / Vector3.Dot(data1.direction, data2.axes[0]); projection.y = 1 / Vector3.Dot(data1.direction, data2.axes[1]); projection.z = 1 / Vector3.Dot(data1.direction, data2.axes[2]); Vector3 pMin = Vector3.Scale(min, projection); Vector3 pMax = Vector3.Scale(max, projection); if (projection.x &lt; 0) Swap(ref pMin.x, ref pMax.x); if (projection.y &lt; 0) Swap(ref pMin.y, ref pMax.y); if (projection.z &lt; 0) Swap(ref pMin.z, ref pMax.z); float n = Mathf.Max(pMin.x, pMin.y, pMin.z); float f = Mathf.Min(pMax.x, pMax.y, pMax.z); Debug.Log(n + &quot; &quot; + f); Debug.Log(pMin + &quot; &quot; + pMax); Debug.Log(projection); bool res = false; if (!checkNotInside) &#123; res = true; Vector3 point = data1.center + data1.direction * f; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125; else &#123; if (n &lt; f &amp;&amp; data1.radius &gt;= n) &#123; res = true; &#125; else &#123; return false; &#125; Vector3 point = data1.center + data1.direction * n; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125; return res;&#125; 在AABB中由于AABB包围盒的方向轴与坐标轴一致，所以我们可以简化方程。 在X轴上，我们有$t_{yz}&#x3D;(Dot(P-C1,n_{yz}))&#x2F;Dot(Dir,n_{yz})$ 又因为$n_{yz}&#x3D;(1,0,0)$，只有x上有值 所以$t_{yz}&#x3D;(P.x-C1.x)&#x2F;Dir.x$ 同理可得其他面也是这样，因此最后我们可以得到如下方程： $t&#x3D;(P-C1)&#x2F;Dir$ 其他部分就和射线与OBB的算法一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//包围盒数据结构public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f; public Vector3 direction = Vector3.zero; public Vector3 max = Vector3.zero; public Vector3 min = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// 射线和AABB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private void CollisionRay2AABB(CollisionData data1,CollisionData data2)&#123; //判断是否不在AABB内 bool checkNotInside = data1.center.x &gt; data2.max.x || data1.center.x &lt; data2.min.x || data1.center.y &gt; data2.max.y || data1.center.y &lt; data2.min.y || data1.center.z &gt; data2.max.z || data1.center.z &lt; data2.min.z; //判断反向情况 bool checkForawd = Vector3.Dot(data2.center - data1.center, data1.direction) &lt; 0; if (checkNotInside &amp;&amp; checkForawd) &#123; line1.Collided(false); line2.Collided(false); return; &#125; //判断是否相交 Vector3 min = data2.min - data1.center; Vector3 max = data2.max - data1.center; Vector3 projection = new Vector3(1 / data1.direction.x, 1 / data1.direction.y, 1 / data1.direction.z); Vector3 pMin = Vector3.Scale(min, projection); Vector3 pMax = Vector3.Scale(max, projection); if (data1.direction.x &lt; 0) Swap(ref pMin.x, ref pMax.x); if (data1.direction.y &lt; 0) Swap(ref pMin.y, ref pMax.y); if (data1.direction.z &lt; 0) Swap(ref pMin.z, ref pMax.z); float n = Mathf.Max(pMin.x, pMin.y, pMin.z); float f = Mathf.Min(pMax.x, pMax.y, pMax.z); if (!checkNotInside) &#123; line1.Collided(true); line2.Collided(true); Vector3 point = data1.center + data1.direction * f; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125; else &#123; if (n &lt; f &amp;&amp; data1.radius &gt;= n) &#123; line1.Collided(true); line2.Collided(true); &#125; else &#123; line1.Collided(false); line2.Collided(false); return; &#125; Vector3 point = data1.center + data1.direction * n; ConsoleUtils.Log(&quot;碰撞点&quot;, point); &#125;&#125; 其他情况和射线与圆相交检测一样，当射线在包围盒内的时候一定相交；当射线与包围盒相反的时候一定不相交。 对于AABB来说，只要判断射线起点和AABB包围盒的最大最小点的关系就可以判断是否在包围盒内，对于OBB来说要把射线起点映射到OBB坐标系中，然后按照AABB的方式来判断。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"射线","slug":"射线","permalink":"https://busyogg.github.io/tags/%E5%B0%84%E7%BA%BF/"}]},{"title":"碰撞检测之射线与圆","slug":"碰撞检测之射线与圆","date":"2023-10-08T11:20:39.000Z","updated":"2023-10-26T11:47:19.964Z","comments":true,"path":"article/d898103b68b3/","link":"","permalink":"https://busyogg.github.io/article/d898103b68b3/","excerpt":"","text":"简介射线检测可以用于拾取物体、判断前方是否有障碍物、判断是否碰撞等场景，本文介绍射线与圆的检测原理。 原理射线与圆的检测，有以下几点判断： 射线方向是否与射线起点与圆的方向相反，是则不相交； 射线是否过短，是则不相交； 如图所示，射线R在射线原点与圆心方向的投影加上圆C的半径长度之和小于射线原点与圆心的距离RC，射线过短。（黑线表示距离和，蓝线表示RC） 射线是否在园内，是则必定相交； 当射线与圆相交的时候，如下图所示： 我们投影射线原点与圆心的距离d到射线R上，记为p，并通过圆心作一条垂直于射线R的垂线g，我们可以得到如下关系： f1 : $p^2+g^2&#x3D;d^2$ 我们把交点到射线原点的距离记为t，到垂线g的距离记为s，线段s满足以下关系：f2 : $s^2+g^2&#x3D;r^2$ 我们合并两个三角形方程f1、f2，得到方程 $p^2+g^2-s^2+g^2&#x3D;d^2-r^2$，化简得到：f3 : $s^2&#x3D;p^2-d^2+r^2$ 由此可知，如果射线与圆相交，则以上等式恒成立，即如果以上等式不成立的情况下，射线与圆不相交。因此我们判断方程f3的情况是否成立，开根号得到： f4 : $s&#x3D;\\pm\\sqrt[]{p^2-d^2+r^2}$，那么我们只要判断$p^2-d^2+r^2&gt;&#x3D;0$就知道射线与圆是否相交，p、d、r均为已知数。 当我们要求交点的时候，我们只要带入上文已求的p和s，得到近点距离为：$t&#x3D;p-s$；远点距离为：$t&#x3D;p+s$，然后以射线原点出发，加上方向向量的单位向量乘以距离，即可求出交点。 对于三维空间来说，我们求的也是射线与球的一个面，即圆的关系。因此算法和二维空间一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243//包围盒数据结构public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f; public Vector3 direction = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// 射线和球检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionRay2Circle(CollisionData data1,CollisionData data2)&#123; Vector3 centerDis = data2.center - data1.center; Vector3 direction = data1.direction; float projection = Vector3.Dot(centerDis, direction); float r2 = Mathf.Pow(data2.radius, 2); float f = Mathf.Pow(projection, 2) + r2 - centerDis.sqrMagnitude; //方向相反 bool checkDirection = projection &lt; 0; //射线过短 bool checkDistance = centerDis.sqrMagnitude &gt; Mathf.Pow(data1.radius + data2.radius, 2); //射线起点在球内部 bool checkNotInside = centerDis.sqrMagnitude &gt; r2; //不相交 bool checkNotCollide = f &lt; 0; if (checkNotInside &amp;&amp; (checkDirection || checkDistance || checkNotCollide)) &#123; return false; &#125; float dis = projection - Mathf.Sqrt(f) * (checkNotInside ? 1 : -1); Vector3 point = data1.center + data1.direction * dis; ConsoleUtils.Log(&quot;碰撞点&quot;, point); return true;&#125; 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"},{"name":"射线","slug":"射线","permalink":"https://busyogg.github.io/tags/%E5%B0%84%E7%BA%BF/"}]},{"title":"碰撞检测之圆与OBB","slug":"碰撞检测之圆与OBB","date":"2023-09-28T08:43:29.000Z","updated":"2023-10-26T11:44:49.520Z","comments":true,"path":"article/2d2709a1efcf/","link":"","permalink":"https://busyogg.github.io/article/2d2709a1efcf/","excerpt":"","text":"简介圆与OBB进行碰撞检测，和圆与AABB进行碰撞检测类似，实质可以化为一个点与OBB进行检测，然后根据检测结果与圆的半径进行比较。 原理和圆与AABB碰撞检测类似，圆与OBB碰撞检测也是化为点与OBB检测。因此，我们需要把点的坐标化为OBB坐标系的坐标。这里我们利用投影，把点的坐标投影到OBB坐标系中，然后再使用点与AABB检测的思路进行检测，最后把得到的交点转换回原来的坐标系中。 如图所示，我们连接两个物体的中心点C1和C2，得到一个距离向量DIR（矩形中心到圆心）。然后我们把dir投影到矩形的坐标轴上，得到X方向的投影X’和Y方向的投影Y’，由此可以得出C1点在矩形坐标系中的位置。 然后我们利用圆与AABB检测的方法得到OBB上距离C1点的最近点，并且还原这个坐标到原始坐标轴中。具体方法是令最近点Pnear初始值为C2坐标，然后在求交点在每个轴坐标的时候让P的每个轴的值加上坐标值distance * 坐标轴向量的分量，即 Pnear.x += distance * axis[i].x ,以此类推。 得到最近点之后，我们就可以用和圆与AABB检测一样的方法来判断是否相交了。 三维空间和二维空间的求法一样，只不过多一个轴。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public Vector3 extents = Vector3.zero; public Vector3[] axes = new Vector3[3]; public float radius = 1.0f;&#125;---------------------------------------------/// &lt;summary&gt;/// 球与OBB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionCircle2OBB(CollisionData data1,CollisionData data2)&#123; //求最近点 Vector3 nearP = GetClosestPointOBB(data1,data2); //与AABB检测原理相同 float distance = (nearP - data1.center).sqrMagnitude; float radius = Mathf.Pow(data1.radius, 2); if (distance &lt;= radius) &#123; return true; &#125; else &#123; return false; &#125;&#125;/// &lt;summary&gt;/// 获取一点到OBB的最近点/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private Vector3 GetClosestPointOBB(CollisionData data1,CollisionData data2)&#123; Vector3 nearP = data2.center; //求球心与OBB中心的距离向量 从OBB中心指向球心 Vector3 center1 = data1.center; Vector3 center2 = data2.center; Vector3 dist = center1 - center2; float[] extents = new float[3] &#123; data2.extents.x, data2.extents.y, data2.extents.z &#125;; Vector3[] axes = data2.axes; for (int i = 0; i &lt; 3; i++) &#123; //计算距离向量到OBB坐标轴的投影长度 即距离向量在OBB坐标系中的对应坐标轴的长度 float distance = Vector3.Dot(dist, axes[i]); distance = Mathf.Clamp(distance, -extents[i], extents[i]); //还原到世界坐标 nearP.x += distance * axes[i].x; nearP.y += distance * axes[i].y; nearP.z += distance * axes[i].z; &#125; return nearP;&#125; 其他和圆与圆的检测一样，圆与OBB检测求两点距离的时候也使用平方来计算，减少开方的性能消耗。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"}]},{"title":"碰撞检测之圆与AABB","slug":"碰撞检测之圆与AABB","date":"2023-09-26T16:11:11.000Z","updated":"2023-10-26T11:45:03.501Z","comments":true,"path":"article/09bda077a263/","link":"","permalink":"https://busyogg.github.io/article/09bda077a263/","excerpt":"","text":"简介圆与AABB进行碰撞检测，实质可以化为一个点与AABB进行检测，然后根据检测结果与圆的半径进行比较。 原理二维 首先我们把圆与AABB的问题化为点与AABB的问题。 从一个点到一条直线的最短距离，就是从这个点做一条垂线，这样我们就得到了一个点P。 如图所示，在Y轴上，这个点的Y坐标在矩形Y坐标的最大值和最小值之间。这时我们观察图像可知，P点的Y坐标就是圆心的Y坐标。 在X轴上，这个点的X坐标在矩形X坐标的最大值和最小值之外。由于P点是矩形上一点，因此P的X坐标一定限制在矩形的X坐标之内。所以，此时P点的X坐标为矩形的X坐标最小值。 通过这两条我们不难看出，一个点在AABB的最近点坐标一定在AABB最大最小坐标之内，如果超出的话就设置为AABB的最大或最小坐标。 当我们得到P点坐标之后，就可以通过圆心和P点求出这两个点之间的距离。然后我们只需要比较这个距离和圆半径的关系就可以知道这两个物体是否相交。 三维在三维空间中，两个对象碰撞检测的原理和二维空间一样，只不过多加了一个Z轴。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 max = Vector3.zero; public Vector3 min = Vector3.zero; public Vector3 center = Vector3.zero; public float radius = 1.0f;&#125;---------------------------------------------/// &lt;summary&gt;/// 球与AABB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionCircle2AABB(CollisionData data1,CollisionData data2)&#123; //求出最近点 Vector3 center = data1.center; Vector3 nearP = GetClosestPointAABB(data1,data2); //求出最近点与球心的距离 float distance = (nearP - center).sqrMagnitude; float radius = Mathf.Pow(data1.radius, 2); //距离小于半径则碰撞 if (distance &lt;= radius) &#123; return true; &#125; return false;&#125;/// &lt;summary&gt;/// 获得一点到AABB最近点/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private Vector3 GetClosestPointAABB(CollisionData data1,CollisionData data2)&#123; Vector3 center = data1.center; Vector3 nearP = Vector3.zero; nearP.x = Mathf.Clamp(center.x, data2.min.x, data2.max.x); nearP.y = Mathf.Clamp(center.y, data2.min.y, data2.max.y); nearP.z = Mathf.Clamp(center.z, data2.min.z, data2.max.z); return nearP;&#125; 其他和圆与圆的检测一样，圆与AABB检测求两点距离的时候也使用平方来计算，减少开方的性能消耗。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"}]},{"title":"碰撞检测之圆与圆","slug":"碰撞检测之圆与圆","date":"2023-09-26T15:46:22.000Z","updated":"2023-10-26T11:45:10.876Z","comments":true,"path":"article/2bef1c973f07/","link":"","permalink":"https://busyogg.github.io/article/2bef1c973f07/","excerpt":"","text":"简介用圆或球来包裹物体，检测两个物体是否有碰撞。 原理 判断两个圆是否相交，只需要判断两个圆心的距离小于等于（也可以只是小于，看需求）两个圆的半径之和，若小于，则相交。 二维空间和三维空间的原理相同，也是判断两个球心的距离小于等于两个球的半径之和。 物体的包围球可能会存在较大的空隙，因此包围球检测的精度较低。 我们在求距离的时候，可以使用平方来计算，因为平方的开销比开方小，这样可以优化性能。 1234567891011121314151617181920212223242526272829//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 center = Vector3.zero; public float radius = 1.0f;&#125;---------------------------------------------/// &lt;summary&gt;/// 球与球检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionCircle(CollisionData data1,CollisionData data2)&#123; //求两个球半径和的平方 float totalRadius = Mathf.Pow(data1.radius + data2.radius, 2); //球两个球心之间的距离平方 float distance = (data1.center - data2.center).sqrMagnitude; //距离小于等于半径和则碰撞 if (distance &lt;= totalRadius) &#123; return true; &#125; return false;&#125; 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"}]},{"title":"碰撞检测之OBB","slug":"碰撞检测之OBB","date":"2023-09-25T15:27:33.000Z","updated":"2023-09-26T16:31:33.775Z","comments":true,"path":"article/3c9cb66ca768/","link":"","permalink":"https://busyogg.github.io/article/3c9cb66ca768/","excerpt":"","text":"简介OBB检测，即有向包围盒（Oriented Bounding Box）检测，是一种检测两个物体有没有相交的算法。物体根据包围盒中心、包围盒大小以及包围盒旋转轴构造有向包围盒，该包围盒比AABB包围盒更贴合旋转物体。OBB检测利用SAT（Separating AxisTheorem）分离轴算法进行相交检测，比AABB检测具有更好的检测精度。 原理 对于两个凸多边形来说，若存在一条直线把两个凸多边形分开，那么垂直于这条直线的轴则称为分离轴。若两个物体在分离轴上的投影不相交，则两个物体不相交，并且一旦在某个轴上存在不相交的情况，则两个物体一定不相交，退出检测。 在实际运用中，我们常以凸多边形的边的垂线作为分离轴，依次检测物体在分离轴上的投影。 二维 在2D图形中，分离轴的数量为两个凸多边形物体的边数之和，如上图所示，4条黑色的轴为分离轴。在分离轴1上，我们观察到物体A的投影和物体B的投影相交了，因此在分离轴1上，两个物体相交；在分离轴2上，我们观察到两个物体的投影没有相交，因此两个物体在分离轴2上没有相交。 由此，我们可以得出A、B两个物体没有相交。通过观察图像我们也知道这个结果没错。 三维在3D中，我们以一个有向的长方体来包围物体，即OBB。 由于长方体的坐标轴两两垂直，因此坐标轴即是分离轴。由于两个长方体之间还存在特殊的摆放。 在这种情况下，两个包围盒的坐标轴分离轴投影均相交，但是这两个物体并没有相交，两个物体之间还是存在一个面能够把两个物体分开，这个面就是向量A和向量B构成的平面。 利用向量叉乘的性质，我们可以求出一个垂直于这个面的向量，我们以这个向量为新的分离轴。两个物体每两条边构成的面都需要求垂直向量，因此两个OBB包围盒之间有 3 * 3 = 9 条新的分离轴。加上原来两个向量的 3 + 3 = 6 条分离轴，在3D中一共要检测15条分离轴。 对于其中一条分离轴，我们遍历顶点作为向量，投影到分离轴上，筛选出最大和最小值。对两个物体进行同样的操作后，我们比较两个物体的投影最值有无相交。每条分离轴以此方法操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3[] vertexts = new Vector3[8]; public Vector3[] axes = new Vector3[3]; public Vector3 center = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// SAT分离轴碰撞检测之OBB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;private bool CollisionOBB(CollisionData data1,CollisionData data2)&#123; //求与两个OBB包围盒之间两两坐标轴垂直的法线轴 共9个 int len1 = data1.axes.Length; int len2 = data2.axes.Length; Vector3[] axes = new Vector3[len1 + len2 + len1 * len2]; int k = 0; int initJ = len2; for (int i = 0; i &lt; len1; i++) &#123; axes[k++] = data1.axes[i]; for (int j = 0; j &lt; len2; j++) &#123; if (initJ &gt; 0) &#123; initJ--; axes[k++] = data2.axes[j]; &#125; axes[k++] = Vector3.Cross(data1.axes[i], data2.axes[j]); &#125; &#125; for (int i = 0, len = axes.Length; i &lt; len; i++) &#123; if (NotInteractiveOBB(data1.vertexts, data2.vertexts, axes[i])) &#123; //有一个不相交就退出 return false; &#125; &#125; return true;&#125;/// &lt;summary&gt;/// 计算投影是否不相交/// &lt;/summary&gt;/// &lt;param name=&quot;vertexs1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;vertexs2&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;axis&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private bool NotInteractiveOBB(Vector3[] vertexs1, Vector3[] vertexs2, Vector3 axis)&#123; //计算OBB包围盒在分离轴上的投影极限值 float[] limit1 = GetProjectionLimit(vertexs1, axis); float[] limit2 = GetProjectionLimit(vertexs2, axis); //两个包围盒极限值不相交，则不碰撞 return limit1[0] &gt; limit2[1] || limit2[0] &gt; limit1[1];&#125;/// &lt;summary&gt;/// 计算顶点投影极限值/// &lt;/summary&gt;/// &lt;param name=&quot;vertexts&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;axis&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private float[] GetProjectionLimit(Vector3[] vertexts, Vector3 axis)&#123; float[] result = new float[2] &#123; float.MaxValue, float.MinValue &#125;; for (int i = 0, len = vertexts.Length; i &lt; len; i++) &#123; Vector3 vertext = vertexts[i]; float dot = Vector3.Dot(vertext, axis); result[0] = Mathf.Min(dot, result[0]); result[1] = Mathf.Max(dot, result[1]); &#125; return result;&#125; 其他OBB检测只能是凸多边形，不适用于凹多边形的情况。凹多边形可以分割为凸多边形进行检测。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"SAT分离轴","slug":"SAT分离轴","permalink":"https://busyogg.github.io/tags/SAT%E5%88%86%E7%A6%BB%E8%BD%B4/"}]},{"title":"碰撞检测之AABB","slug":"碰撞检测之AABB","date":"2023-09-25T14:35:26.000Z","updated":"2023-09-26T14:30:28.331Z","comments":true,"path":"article/1f60a8286c97/","link":"","permalink":"https://busyogg.github.io/article/1f60a8286c97/","excerpt":"","text":"简介AABB检测，即轴对齐包围盒（Axis-Aligned Bounding Boxes）检测，是一种检测两个物体有没有相交的算法。物体根据坐标轴形成包围盒，通过检测顶点关系来判断是否相交。 原理一维 如上图所示，在一维坐标轴中，存在一个物体AB，一个物体CD以及一个物体EF。 当我们要检测物体AB和CD是否相交的时候，我们不难看出，只要物体CD的最大坐标和最小坐标都不在物体AB的坐标之间，那我们就认为这两个物体没有相交。 当我们检测物体AB和物体EF是否相交的时候，我们观察到物体AB和物体EF的坐标相交了，因此这两个物体相交。 由此我们可以得出，当一个物体的最大坐标和最小坐标都不在另一个物体的最大坐标和最小坐标之间，则两个物体没有相交。 二维这个原理拓展到二维坐标中，即2D平面中也成立。 同样的，我们在平面中也存在A、B、C、D四个物体。 对于物体A和物体D，在X轴中，我们需要判断D的X最大值和D的X最小值都不在A的X最大值和X最小值中，我们就能判断连个物体不相交。 对于物体A和物体C，在X轴中，我们需要判断C的Y最大值和C的Y最小值都不在A的Y最大值和Y最小值中，我们就能判断连个物体不相交。 因此，对于平面来说，我们只是拓展了一个轴的检测，并且这两个轴的检测只要有一个成立，就表示两个物体不相交。 我们在做平面AABB检测的时候会出现三种情况，即B、C、D三个物体和A物体之间的关系。这三种情况只要出现一种成立即可。所以，我们判断物体关系的时候就判断不成立的情况，用或来连接，可以减少计算量。并且当我们判断的时候可以直接用一个物体的最大值去比另一个物体的最小值，用最小值去比最大值，进一步减少计算。 三维在三维空间中进行AABB检测与在二维空间中检测并无不同，只是要检测的轴再增加一个Z轴。三个轴之间的关系也是或的关系。 1234567891011121314151617181920212223242526272829//包围盒数据结构using System.Collections;using System.Collections.Generic;using UnityEngine;public class CollisionData : MonoBehaviour&#123; public Vector3 max = Vector3.zero; public Vector3 min = Vector3.zero;&#125;---------------------------------------------/// &lt;summary&gt;/// AABB检测/// &lt;param name=&quot;data1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;data2&quot;&gt;&lt;/param&gt;/// &lt;/summary&gt;//AABB检测private bool CollisionAABB(CollisionData data1,CollisionData data2)&#123; //包围盒1的最小值比包围盒2的最大值还大 或 包围盒1的最大值比包围盒2的最小值还小 则不碰撞 if (data1.max.x &lt; data2.min.x || data1.max.y &lt; data2.min.y || data1.max.z &lt; data2.min.z || data1.min.x &gt; data2.max.x || data1.min.y &gt; data2.max.y || data1.min.z &gt; data2.max.z) &#123; return false; &#125; else &#123; return true; &#125;&#125; 其他AABB检测在物体有旋转的情况下会造成包围盒过大，因此检测的精度不是很高。具体情况如下图所示。 碰撞检测示例工程","categories":[{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"TS实现ECS架构","slug":"TS实现ECS架构","date":"2023-09-14T17:40:51.000Z","updated":"2023-09-18T13:22:19.643Z","comments":true,"path":"article/be8112f144cf/","link":"","permalink":"https://busyogg.github.io/article/be8112f144cf/","excerpt":"","text":"简介ECS架构是 实体（Entity）-组件（Component）-系统（System） 组成的架构，主要目的是对数据和逻辑进行解耦以便更好的维护系统。其运行的原理也能提高CPU的缓存命中，即可以提高游戏运行的性能。 原理概述ECS架构简单来说就是用实体来组合组件，用组件来保存数据，用系统来进行运算。单一的实体没有任何意义，只有在组合组件之后这个实体才有意义。组件只能用于保存数据，不能自己进行任何的运算。系统只负责运算，不会持久化保存任何数据。这样就把数据和逻辑分离开来，通过组合的方式实现特定的功能，实现数据和逻辑的解耦，以及逻辑与逻辑之间的解耦。 大致示意图如下 组件组件是ECS架构的基础，实体需要组件，系统也根据组件处理逻辑。组件的设计很简单，我们只需要以下基础属性和方法： 组件id，每个组件都拥有一个属于自己的id，这个id是全局唯一的。 组件名，每个组件都拥有一个属于自己的名字，这个名字是全局唯一的。 实体，保存组件所属的具体实体。 是否可以被回收，有些组件在实体移除后需要回收，有些则不从实体回收。 重置方法，用于回收组件之后进行组件的重置。 因此我们可以定义一个组件接口，接口不关心组件的具体信息，只关心组件是否可以回收、组件的所属以及重置方法。 IComp1234567import Entity from &quot;../Entity&quot;;export default interface IComp &#123; canRecycle: boolean; entity: Entity; reset(): void;&#125; 然后我们定义一个抽象组件基类。 Comp12345678910import Entity from &quot;./Entity&quot;;import IComp from &quot;./Interface/IComp&quot;;export abstract class Comp implements IComp &#123; static tid = -1; static compName: string; public canRecycle: boolean = true; public entity: Entity | null; abstract reset(): void;&#125; 然后我们就可以定义实际的Comp类来保存我们需要的数据。 组件还有一种形式是标签，标签不继承抽象组件基类，但是在注册的时候也是和组件共享一套id自增规则。注意，标签类中的属性要任意赋一个值，这样才能在注册的时候获取到这个属性。 实体实体是组件的合集，虽然实体的概念很简单，但是实体的实现却比较复杂。实体需要实现组件的添加和移除，也要在添加移除组件的时候通知对应系统进行处理，同时实体也要提供组件的查询功能。当然，实体自身也要提供移除的方法。 掩码工具由于实体需要查询组件，系统也需要查询组件，因此我们需要先设计对应的功能。此处我们选择用二进制数来制作掩码系统保存组件信息。 这里我们使用一个二进制数组来保存，用数组的目的是如果组件数超过二进制数大小，就在数组增加一个二进制数来保存。在32位二进制数中，由于与（&amp;）操作符最大只能操作30位数（一位符号位，一位进位），因此一个数只保存30个组件。 由于组件的数量在游戏的最开始就初始化完成，因此Mask实例的组件总数是固定的。 当我们进行掩码运算时，传入的组件id转为二进制数和当前的掩码进行比较，例如我们设置组件时，假设当前掩码为 0000 0000 0000 0000 ，传入的组件id为3，则我们把组件id化为 1 &lt;&lt; (3 % 31)，即1左移3位，得到 1000 ，0000 0000 0000 0000 &amp; 1000 = 0000 0000 0000 1000，最终的组件就保存下来了。 也就是说32位掩码就是插槽，组件的id就是往哪个插槽插入组件，这样就能表示保存的组件了。 Mask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import ECSManager from &quot;./ECSManager&quot;;export default class Mask &#123; /** 32位二进制数组 由于&amp;操作符最大只能30位操作 故每个三十二位二进制保存30个组件 */ private mask: Uint32Array; private size: number = 0; constructor() &#123; //计算32位掩码数量 (总组件数/31) let length = Math.ceil(ECSManager.getInst().getCompTid() / 31); this.mask = new Uint32Array(length); this.size = length; &#125; /** * 设置掩码 或 * @param num */ set(num: number) &#123; /// &gt;&gt;&gt; 无符号位移 高位补0 this.mask[((num / 31) &gt;&gt;&gt; 0)] |= (1 &lt;&lt; (num % 31)); &#125; /** * 移除掩码 与 取反 * @param num */ delete(num: number) &#123; this.mask[((num / 31) &gt;&gt;&gt; 0)] &amp;= ~(1 &lt;&lt; (num % 31)); &#125; /** * 查找 与 * @param num * @returns */ has(num: number) &#123; // !!取布尔值 0或1 return !!(this.mask[((num / 31) &gt;&gt;&gt; 0)] &amp; (1 &lt;&lt; (num % 31))); &#125; or(other: Mask) &#123; for (let i = 0; i &lt; this.size; i++) &#123; // &amp;操作符最大也只能对2^30进行操作，如果对2^31&amp;2^31会得到负数。当然可以(2^31&amp;2^31) &gt;&gt;&gt; 0，这样多了一步右移操作。 if (this.mask[i] &amp; other.mask[i]) &#123; return true; &#125; &#125; return false; &#125; and(other: Mask) &#123; for (let i = 0; i &lt; this.size; i++) &#123; if ((this.mask[i] &amp; other.mask[i]) != this.mask[i]) &#123; return false; &#125; &#125; return true; &#125; clear() &#123; for (let i = 0; i &lt; this.size; i++) &#123; this.mask[i] = 0; &#125; &#125;&#125; 筛选工具因为系统以实体进行遍历的，所以有了掩码之后，我们就可以对实体进行筛选了，通过比较实体的组件掩码和筛选工具的组件掩码，我们就可以筛选出系统需要的实体。 首先我们定义一个匹配规则抽象基类，基类的构造函数根据传入的组件设置掩码，并且按顺序保存组件id。 然后我们定义各个匹配规则的类，判断是否匹配只需要调用掩码定义的规则即可。 所有规则类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import &#123; CompTypeUnion &#125; from &quot;./ECSManager&quot;;import Entity from &quot;./Entity&quot;;import &#123; CompType &#125; from &quot;./Interface/CompType&quot;;import IComp from &quot;./Interface/IComp&quot;;import Mask from &quot;./Mask&quot;;export abstract class BaseOf &#123; protected mask = new Mask(); public indices: number[] = []; constructor(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; let componentTypeId = -1; let len = args.length; for (let i = 0; i &lt; len; i++) &#123; if (typeof (args[i]) === &quot;number&quot;) &#123; componentTypeId = args[i] as number; &#125; else &#123; componentTypeId = (args[i] as CompType&lt;IComp&gt;).tid; &#125; if (componentTypeId == -1) &#123; console.error(&#x27;存在没有注册的组件！&#x27;); &#125; this.mask.set(componentTypeId); if (this.indices.indexOf(componentTypeId) &lt; 0) &#123; // 去重 this.indices.push(componentTypeId); &#125; &#125; if (len &gt; 1) &#123; // 对组件类型id进行排序，这样关注相同组件的系统就能共用同一个group this.indices.sort((a, b) =&gt; &#123; return a - b; &#125;); &#125; &#125; public toString(): string &#123; return this.indices.join(&#x27;-&#x27;); // 生成group的key &#125; public abstract getKey(): string; public abstract isMatch(entity: Entity): boolean;&#125;/** * 用于描述包含任意一个这些组件的实体 */export class AnyOf extends BaseOf &#123; public isMatch(entity: Entity): boolean &#123; // @ts-ignore return this.mask.or(entity.mask); &#125; getKey(): string &#123; return &#x27;anyOf:&#x27; + this.toString(); &#125;&#125;/** * 用于描述包含了“这些”组件的实体，这个实体除了包含这些组件还可以包含其他组件 */export class AllOf extends BaseOf &#123; public isMatch(entity: Entity): boolean &#123; // @ts-ignore return this.mask.and(entity.mask); &#125; getKey(): string &#123; return &#x27;allOf:&#x27; + this.toString(); &#125;&#125;/** * 不包含指定的任意一个组件 */export class ExcludeOf extends BaseOf &#123; public getKey(): string &#123; return &#x27;excludeOf:&#x27; + this.toString(); &#125; public isMatch(entity: Entity): boolean &#123; // @ts-ignore return !this.mask.or(entity.mask); &#125;&#125; 然后我们定义匹配器，匹配器可以包含复数规则，即匹配器是规则的集合，是所有匹配的实际执行类。匹配器也需要一个全局唯一的id，给后面的Group使用。 IMatcher12345678import Entity from &quot;../Entity&quot;;export interface IMatcher &#123; mid: number; indices: number[]; key: string; isMatch(entity: Entity): boolean;&#125; Matcher123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import ECSManager, &#123; CompTypeUnion &#125; from &quot;./ECSManager&quot;;import Entity from &quot;./Entity&quot;;import &#123; AllOf, AnyOf, BaseOf, ExcludeOf &#125; from &quot;./FilterRule&quot;;import IComp from &quot;./Interface/IComp&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;/** * 筛选规则间是“与”的关系 * 比如：ecs.Macher.allOf(...).excludeOf(...)表达的是allOf &amp;&amp; excludeOf，即实体有“这些组件” 并且 “没有这些组件” */export class Matcher implements IMatcher &#123; protected rules: BaseOf[] = []; protected _indices: number[] | null = null; public mid: number = -1; private _key: string | null = null; public get key(): string &#123; if (!this._key) &#123; let s = &#x27;&#x27;; for (let i = 0; i &lt; this.rules.length; i++) &#123; s += this.rules[i].getKey() if (i &lt; this.rules.length - 1) &#123; s += &#x27; &amp;&amp; &#x27; &#125; &#125; this._key = s; &#125; return this._key; &#125; constructor() &#123; this.mid = ECSManager.getInst().getMatherId(); &#125; /** * 匹配器关注的组件索引。在创建Group时，Context根据组件id去给Group关联组件的添加和移除事件。 */ public get indices() &#123; if (this._indices === null) &#123; this._indices = []; //合并数组 this.rules.forEach((rule) =&gt; &#123; Array.prototype.push.apply(this._indices, rule.indices); &#125;); &#125; return this._indices; &#125; /** * 组件间是或的关系，表示关注拥有任意一个这些组件的实体。 * @param args 组件索引 */ public anyOf(...args: CompTypeUnion&lt;IComp&gt;[]): Matcher &#123; this.rules.push(new AnyOf(...args)); return this; &#125; /** * 组件间是与的关系，表示关注拥有所有这些组件的实体。 * @param args 组件索引 */ public allOf(...args: CompTypeUnion&lt;IComp&gt;[]): Matcher &#123; this.rules.push(new AllOf(...args)); return this; &#125; /** * 表示关注只拥有这些组件的实体 * * 注意： * 不是特殊情况不建议使用onlyOf。因为onlyOf会监听所有组件的添加和删除事件。 * @param args 组件索引 */ public onlyOf(...args: CompTypeUnion&lt;IComp&gt;[]): Matcher &#123; this.rules.push(new AllOf(...args)); let otherTids: CompTypeUnion&lt;IComp&gt;[] = []; for (let comp of ECSManager.getInst().getComps()) &#123; if (args.indexOf(comp) &lt; 0) &#123; otherTids.push(comp); &#125; &#125; this.rules.push(new ExcludeOf(...otherTids)); return this; &#125; /** * 不包含指定的任意一个组件 * @param args */ public excludeOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; this.rules.push(new ExcludeOf(...args)); return this; &#125; public isMatch(entity: Entity): boolean &#123; for (let rule of this.rules) &#123; if (!rule.isMatch(entity)) &#123; return false; &#125; &#125; return true; &#125; public clone(): Matcher &#123; let newMatcher = new Matcher(); newMatcher.mid = ECSManager.getInst().getMatherId(); this.rules.forEach(rule =&gt; newMatcher.rules.push(rule)); return newMatcher; &#125;&#125; 大致的关系如下图所示 实体类现在我们可以实现实体类了。 大概的思路如图所示 首先是组件的增加。 我们设置一个Map（下文都叫字典）_compInEntity 来保存当前实体的组件，设置一个字典 _compRemoved 用来保存已经移除但没有回收的组件。 添加组件的时候先判断是组件还是标签。 标签的情况，判断标签是否已经注册，已注册的情况下把标签添加到实体掩码，并且添加到已保存的组件字典中即可。 组件的情况，判断组件是否已注册，已注册并且已存在的情况下判断是否需要重新添加，需要的话就移除当前的组件，然后把组件添加到实体掩码，并且添加到已保存的组件字典中。 添加完成之后，我们还需要广播增删事件给系统。 然后是组件的移除。 组件的移除和添加类似，也需要分为标签和组件两个部分。 标签的情况，判断标签是否存在，是的话标记存在，到最后统一处理。 组件的情况，判断组件是否存在，是的话标记存在，取出当前组件的实例，设置实例的实体为null，判断是否需要回收，需要回收的话执行组件初始化操作并回收，不需要的话就把组件放到移除列表中。 最后我们执行掩码的移除和组件存在列表的移除，并且广播通知系统执行对应操作。 在组件的添加和移除中，我们都可以设置实体类的对应名称属性为组件实例，以便更方便地访问组件。 接着是组件的查找。 组件的查找很简单，可以用掩码也可以用字典，根据自己的需要即可。组件的获取同理，可以用字典也可以用属性，自己决定即可。 最后是实体的移除。 实体移除的时候要移除所有组件，包括存在的和移除的列表。然后实体可以放入对象池。 Entity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190import ECSManager, &#123; CompTypeUnion &#125; from &quot;./ECSManager&quot;;import &#123; CompType &#125; from &quot;./Interface/CompType&quot;;import IComp from &quot;./Interface/IComp&quot;;import Mask from &quot;./Mask&quot;;export default class Entity &#123; public eid: number = -1; private mask = new Mask(); /** * 当前实体上的组件 */ private _compInEntity: Map&lt;number, CompTypeUnion&lt;IComp&gt;&gt; = new Map(); /** * 保存在实体上的已移除的组件 */ private _compRemoved: Map&lt;number, CompTypeUnion&lt;IComp&gt;&gt; = new Map(); constructor() &#123; &#125; /** * 添加组件 * @param comp * @param isReAdded * @returns */ public add&lt;T extends IComp&gt;(comp: CompTypeUnion&lt;T&gt;, isReAdded = false): T | null&#123; let compId; if (typeof (comp) == &quot;number&quot;) &#123; compId = comp; if (ECSManager.getInst().hasTag(comp)) &#123; this.mask.set(comp); this._compInEntity.set(comp, comp); let tagName = ECSManager.getInst().getTag(comp)!; // @ts-ignore this[tagName] = comp; ECSManager.getInst().broadcastCompAddOrRemove(this, comp); &#125; else &#123; console.error(&#x27;不存在的tag！&#x27;); &#125; return null; &#125; else &#123; compId = comp.tid; if (compId == -1) &#123; console.error(&quot;组件未注册&quot;); return null; &#125; if (this._compInEntity.has(compId)) &#123; if (isReAdded) &#123; this.remove(comp); &#125; else &#123; console.log(&quot;组件&quot; + comp.compName + &quot;已存在&quot;); return this[comp.compName]; &#125; &#125; this.mask.set(compId); let compInstance: T; if (this._compRemoved.has(compId)) &#123; compInstance = this._compRemoved.get(compId) as unknown as T; this._compRemoved.delete(compId); &#125; else &#123; compInstance = ECSManager.getInst().createComp(comp); &#125; this[comp.compName] = compInstance; this._compInEntity.set(compId, comp); compInstance.entity = this; //TODO 广播添加组件消息 ECSManager.getInst().broadcastCompAddOrRemove(this, compId); return compInstance as T; &#125; &#125; /** * 添加组件 * @param comps * @returns */ public addComps(reAdded = false,...comps) &#123; for (let comp of comps) &#123; this.add(comp,reAdded); &#125; return this; &#125; /** * 获得组件 * @param comp * @returns */ public get&lt;T&gt;(comp: CompTypeUnion&lt;T&gt;) &#123; let compName; if (typeof (comp) == &quot;number&quot;) &#123; compName = ECSManager.getInst().getTag(comp); &#125; else &#123; compName = comp.compName; &#125; return this[compName] as T; &#125; /** * 判断组件是否存在 * @param comp * @returns */ public has&lt;T&gt;(comp: CompTypeUnion&lt;T&gt;) &#123; if (typeof (comp) == &quot;number&quot;) &#123; return this.mask.has(comp); &#125; else &#123; return this._compInEntity.has(comp.tid); &#125; &#125; private _remove(comp: CompTypeUnion&lt;IComp&gt;) &#123; //TODO git上为false 此处测试true this.remove(comp, true); &#125; /** * 移除组件 * @param comp 组件 * @param isRecycle 是否回收 */ public remove(comp: CompTypeUnion&lt;IComp&gt;, isRecycle: boolean = true) &#123; let compName: string; let id = -1; let hasComp = false; if (typeof (comp) == &quot;number&quot;) &#123; id = comp; if (this.mask.has(id)) &#123; hasComp = true; compName = ECSManager.getInst().getTag(id); &#125; else &#123; console.warn(&quot;试图移除不存在的tag&quot;); return; &#125; &#125; else &#123; id = comp.tid; compName = comp.compName; if (this.mask.has(id)) &#123; hasComp = true; let compInstance = this[compName] as CompType&lt;IComp&gt;; compInstance.entity = null; if (isRecycle) &#123; compInstance.reset(); if (compInstance.canRecycle) &#123; ECSManager.getInst().recycle(id, compInstance); &#125; &#125; else &#123; this._compRemoved.set(id, compInstance); &#125; &#125; else &#123; console.warn(&quot;试图移除不存在的组件&quot;,compName); &#125; &#125; if (hasComp) &#123; this[compName] = null; this.mask.delete(id); this._compInEntity.delete(id); ECSManager.getInst().broadcastCompAddOrRemove(this, id); // console.log(&quot;广播移除组件&quot;, compName); &#125; &#125; /** * 移除组件 * @param isRecycle * @param args */ public removeComps(isRecycle = true, ...args:CompTypeUnion&lt;IComp&gt;[]) &#123; for (let c of args) &#123; this.remove(c, isRecycle); &#125; &#125; /** * 移除实体 */ public removeSelf() &#123; this._compInEntity.forEach(this._remove, this); this._compRemoved.forEach(this._remove, this); ECSManager.getInst().removeEntity(this.eid, this); &#125;&#125; 系统系统根据所需要的组件来筛选实体，有时候不同系统需要的组件相同，因此我们使用组Group来管理系统。 系统的结构如下图所示 群组群组包含一个匹配器，如前文所说，匹配器的id也是群组的id。群组只关心组件匹配的实体，操作的对象也都是实体。 我们保存一个匹配实体字典，以实体id为key，以及一个缓存实体数组。缓存实体数组是系统运行时遍历的，每次组件广播后删除，下次重新缓存。 另外，我们保存一个进入实体列表和一个移除实体列表，这两个列表保存的是系统中对应列表的引用，在群组里专门负责监控组件变化时实体的进入和移除情况。 Group123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import Entity from &quot;./Entity&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;export default class Group&lt;E extends Entity = Entity&gt;&#123; /** * 实体筛选规则 */ private matcher: IMatcher; private _matchEntities: Map&lt;number, E&gt; = new Map(); private _entitiesCache: E[] | null = null; /** * 符合规则的实体 */ public get matchEntities() &#123; if (this._entitiesCache === null) &#123; this._entitiesCache = Array.from(this._matchEntities.values()); &#125; return this._entitiesCache; &#125; /** * 当前group中实体的数量。 * * 不要手动修改这个属性值。 */ public count = 0; // 其实可以通过this._matchEntities.size获得实体数量，但是需要封装get方法。为了减少一次方法的调用所以才直接创建一个count属性 /** * 获取matchEntities中第一个实体 */ get entity(): E &#123; return this.matchEntities[0]; &#125; private _enteredEntities: Map&lt;number, E&gt; | null = null; private _removedEntities: Map&lt;number, E&gt; | null = null; constructor(matcher: IMatcher) &#123; this.matcher = matcher; &#125; /** * 组件变化监听 * @param entity 实体 */ public onComponentAddOrRemove(entity: E) &#123; if (this.matcher.isMatch(entity)) &#123; // Group只关心指定组件在实体身上的添加和删除动作。 this._matchEntities.set(entity.eid, entity); this._entitiesCache = null; this.count++; if (this._enteredEntities) &#123; this._enteredEntities.set(entity.eid, entity); &#125; if(this._removedEntities)&#123; this._removedEntities.delete(entity.eid); &#125; &#125; else if (this._matchEntities.has(entity.eid)) &#123; // 如果Group中有这个实体，但是这个实体已经不满足匹配规则，则从Group中移除该实体 this._matchEntities.delete(entity.eid); this._entitiesCache = null; this.count--; if (this._enteredEntities) &#123; this._enteredEntities.delete(entity.eid); &#125; if(this._removedEntities)&#123; this._removedEntities.set(entity.eid, entity); &#125; &#125; &#125; /** * 监控进入/移除数组 * @param enteredEntities * @param removedEntities */ public watchEntityEnterAndRemove(enteredEntities: Map&lt;number, E&gt;, removedEntities: Map&lt;number, E&gt;) &#123; this._enteredEntities = enteredEntities; this._removedEntities = removedEntities; &#125; clear() &#123; this._matchEntities.clear(); this._entitiesCache = null; this.count = 0; this._enteredEntities?.clear(); this._removedEntities?.clear(); &#125;&#125; 系统实现系统实现分为两个部分，一个部分是系统的具体实现，还有一个部分是根系统。 系统的具体实现核心目标是实现实体进入时的逻辑处理，每帧逻辑处理和实体移除时的逻辑处理。因此我们定义如下接口 ISystem12345678910111213141516171819202122232425import Entity from &quot;../Entity&quot;;/** * 如果需要监听实体首次进入System的情况，实现这个接口。 * * entityEnter会在update方法之前执行，实体进入后，不会再次进入entityEnter方法中。 * 当实体从当前System移除，下次再次符合条件进入System也会执行上述流程。 */export interface IEntityEnterSystem&lt;E extends Entity = Entity&gt; &#123; entityEnter(entities: E[]): void;&#125;/** * 如果需要监听实体从当前System移除，需要实现这个接口。 */export interface IEntityRemoveSystem&lt;E extends Entity = Entity&gt; &#123; entityRemove(entities: E[]): void;&#125;/** * 第一次执行update */export interface ISystemFirstUpdate&lt;E extends Entity = Entity&gt; &#123; firstUpdate(entities: E[]): void;&#125; 我们在系统实现类的构造函数中判断是否有我们需要实现的方法，分为以下两种情况： 有首次进入&#x2F;移除的逻辑函数execute1。这时候我们要初始化实体进入&#x2F;移除的数组，并且在组里监听这两个数组的实体变化。之后设置执行函数为execute1。 没有上述逻辑，直接设置执行函数为每帧更新的逻辑函数execute0。 如果有第一次执行update的函数updateOnce的话，就保存当前设置的执行函数，并且设执行函数为updateOnce。 在execute1、execute0、updateOnce执行之后，我们都要置实体进入&#x2F;移除的数组为空，防止下次执行时重复对已执行实体再次执行对应逻辑。 如果还有其他需求，也可以自行定义对应的接口和具体的处理逻辑。 ComblockSystem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import ECSManager from &quot;./ECSManager&quot;;import Entity from &quot;./Entity&quot;;import Group from &quot;./Group&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;import &#123; IEntityEnterSystem, ISystemFirstUpdate, IEntityRemoveSystem &#125; from &quot;./Interface/ISystem&quot;;export abstract class ComblockSystem&lt;E extends Entity = Entity&gt; &#123; protected _group: Group&lt;E&gt;; protected _dt: number = 0; private _enteredEntities: Map&lt;number, E&gt; | null = null; private _removedEntities: Map&lt;number, E&gt; | null = null; private _hasEntityEnter: boolean = false; private _hasEntityRemove: boolean = false; private _tmpExecute: ((dt: number) =&gt; void) | null = null; private execute!: (dt: number) =&gt; void; constructor() &#123; let hasOwnProperty = Object.hasOwnProperty; let prototype = Object.getPrototypeOf(this); let hasEntityEnter = hasOwnProperty.call(prototype, &#x27;entityEnter&#x27;); let hasEntityRemove = hasOwnProperty.call(prototype, &#x27;entityRemove&#x27;); let hasFirstUpdate = hasOwnProperty.call(prototype, &#x27;firstUpdate&#x27;); this._hasEntityEnter = hasEntityEnter; this._hasEntityRemove = hasEntityRemove; if (hasEntityEnter || hasEntityRemove) &#123; this._enteredEntities = new Map&lt;number, E&gt;(); this._removedEntities = new Map&lt;number, E&gt;(); this.execute = this.execute1; this._group = ECSManager.getInst().createGroup(this.filter()); this._group.watchEntityEnterAndRemove(this._enteredEntities, this._removedEntities); &#125; else &#123; this.execute = this.execute0; this._group = ECSManager.getInst().createGroup(this.filter()); &#125; if (hasFirstUpdate) &#123; this._tmpExecute = this.execute; this.execute = this.updateOnce; &#125; &#125; init(): void &#123; &#125; onDestroy(): void &#123; &#125; hasEntity(): boolean &#123; return this._group.count &gt; 0; &#125; private updateOnce(dt: number) &#123; if (this._group.count === 0) &#123; return; &#125; this._dt = dt; // 处理刚进来的实体 if (this._enteredEntities &amp;&amp; this._enteredEntities.size &gt; 0) &#123; (this as unknown as IEntityEnterSystem).entityEnter(Array.from(this._enteredEntities.values()) as E[]); this._enteredEntities.clear(); &#125; (this as unknown as ISystemFirstUpdate).firstUpdate(this._group.matchEntities); this.execute = this._tmpExecute!; this.execute(dt); this._tmpExecute = null; &#125; /** * 只执行update * @param dt * @returns */ private execute0(dt: number): void &#123; if (this._group.count === 0) &#123; return; &#125; this._dt = dt; this.update(this._group.matchEntities); &#125; /** * 先执行entityRemove，再执行entityEnter，最后执行update。 * @param dt * @returns */ private execute1(dt: number): void &#123; if (this._removedEntities &amp;&amp; this._removedEntities.size &gt; 0) &#123; if (this._hasEntityRemove) &#123; (this as unknown as IEntityRemoveSystem).entityRemove(Array.from(this._removedEntities.values()) as E[]); &#125; this._removedEntities.clear(); &#125; if (this._group.count === 0) &#123; return; &#125; this._dt = dt; // 处理刚进来的实体 if (this._enteredEntities &amp;&amp; this._enteredEntities.size &gt; 0) &#123; if (this._hasEntityEnter) &#123; (this as unknown as IEntityEnterSystem).entityEnter(Array.from(this._enteredEntities.values()) as E[]); &#125; this._enteredEntities.clear(); &#125; this.update(this._group.matchEntities as E[]); &#125; /** * 实体过滤规则 * * 根据提供的组件过滤实体。 */ abstract filter(): IMatcher; abstract update(entities: E[]): void;&#125; 当然，同类型的系统我们也可以用系统组合器来组合使用。 System12345678910111213141516171819202122import &#123; ComblockSystem &#125; from &quot;./ComBlockSystem&quot;;/** * 系统组合器，用于将多个相同功能模块的系统逻辑上放在一起。System也可以嵌套System。 */export class System &#123; private _comblockSystems: ComblockSystem[] = []; get comblockSystems() &#123; return this._comblockSystems; &#125; add(system: System | ComblockSystem) &#123; if (system instanceof System) &#123; Array.prototype.push.apply(this._comblockSystems, system._comblockSystems); system._comblockSystems.length = 0; &#125; else &#123; this._comblockSystems.push(system as ComblockSystem); &#125; return this; &#125;&#125; 所有的系统实现，最后我们都要用根系统来使用。 根系统生命周期提供一个init方法，来遍历所有系统并且调用对应系统的初始化；提供一个execute方法来遍历所有系统，执行每帧更新的内容；提供一个clear方法来遍历所有系统，调用系统销毁时的onDestroy方法。 然后就是add方法，传入系统组合器时我们会平铺其的所有系统并加入数组；传入系统时直接加入数组。 所有的方法在我们自定义根系统的时候都不需要修改，只需要在构造函数中add新的系统即可。 RootSystem123456789101112131415161718192021222324252627282930313233343536373839import &#123; ComblockSystem &#125; from &quot;./ComBlockSystem&quot;;import &#123; System &#125; from &quot;./System&quot;;/** * System的root，对游戏中的System遍历从这里开始。 * * 一个System组合中只能有一个RootSystem，可以有多个并行的RootSystem。 */export class RootSystem &#123; private executeSystemFlows: ComblockSystem[] = []; private systemCnt: number = 0; add(system: System | ComblockSystem) &#123; if (system instanceof System) &#123; // 将嵌套的System都“摊平”，放在根System中进行遍历，减少execute的频繁进入退出。 Array.prototype.push.apply(this.executeSystemFlows, system.comblockSystems); &#125; else &#123; this.executeSystemFlows.push(system as ComblockSystem); &#125; this.systemCnt = this.executeSystemFlows.length; return this; &#125; init() &#123; this.executeSystemFlows.forEach(sys =&gt; sys.init()); &#125; execute(dt: number) &#123; for (let i = 0; i &lt; this.systemCnt; i++) &#123; // @ts-ignore this.executeSystemFlows[i].execute(dt); &#125; &#125; clear() &#123; this.executeSystemFlows.forEach(sys =&gt; sys.onDestroy()); &#125;&#125; 管理器ECS的基本框架搭建好后，我们还需要一个管理器来管理ECS框架的一些操作。下面是本项目的分类，也可以根据需求自己设计。 ECS管理器的核心功能简单概括如下图所示 组件注册我们在使用组件之前，都要对组件进行注册。由上文我们知道组件有两种，一种是组件，一种是标签，因此注册也是分两种情况进行。 首先我们定义组件id_compTid来记录组件id，定义注册池_registerPool来判断是否存在同名组件或标签，定义组件池_comps保存组件类，定义组件缓存池_compPools来保存组件对象，定义tag池_tags来保存标签名，定义组件变化池_compAddOrRemove来保存变化的组件。 组件的注册用装饰器进行，我们定义两个类装饰器函数。 注册组件：传入一个组件名，还有一个可选变量canNew表示是否可以实例化，一般我们默认true，然后我们判断注册的组件是否重复，没重复的话给当前组件命名，组件id赋值后自增，可以实例化组件的话就把组件存入组件池，并开辟一个当前组件的缓存池数组以及组件变化池数组。最后在注册池里标记为已注册。 注册组件12345678910111213141516171819202122232425262728293031/** * 注册组件 * @param compName * @param canNew * @returns */public register&lt;T&gt;(compName: string, canNew: boolean = true) &#123; return function (comp: CompType&lt;T&gt;) &#123; if (comp.tid == -1) &#123; let manager = ECSManager.getInst(); if (manager._registerPool[compName]) &#123; console.warn(&quot;组件与标签重名:&quot;, compName); &#125; else &#123; comp.tid = manager._compTid++; comp.compName = compName; if (canNew) &#123; manager._comps.push(comp); manager._compPools.set(comp.tid, []); &#125; else &#123; manager._comps.push(null); &#125; manager._compAddOrRemove.set(comp.tid, []); console.log(&quot;组件&quot; + compName + &quot;注册成功:&quot;, comp.tid) manager._registerPool[compName] = true; &#125; &#125; else &#123; console.log(&quot;组件已注册&quot;); &#125; &#125;&#125; 注册标签：注册标签我们不传入任何参数，我们只需要遍历标签类的所有属性，判断是否已注册，未注册的情况我们给标签id赋值并自增，然后和组件一样放入组件池并开辟组件缓存池。标签要额外放到标签池以方便标签的操作。最后也要在注册池里标注为已注册。 注册tag123456789101112131415161718192021222324/** * 注册tag * @returns */public registerTag() &#123; return function (_class: any) &#123; let manager = ECSManager.getInst(); let tid = manager._compTid; for (let k in _class) &#123; if (manager._registerPool[k]) &#123; console.warn(&quot;标签与组件重名:&quot;, k); &#125; else &#123; tid = manager._compTid++; _class[k] = tid; manager._comps.push(tid); manager._compPools.set(tid, []); manager._compAddOrRemove.set(tid, []); manager._tags.set(tid, k); console.log(&quot;标签&quot; + k + &quot;注册成功:&quot;, tid) manager._registerPool[k] = true; &#125; &#125; &#125;&#125; 组件功能组件的功能很简单，只是运用了对象池的概念。 组件功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//-----tag-----/** * 是否有tag * @param id * @returns */public hasTag(id: number) &#123; return this._tags.has(id);&#125;/** * 获得tag * @param id * @returns */public getTag(id: number): string &#123; return this._tags.get(id) as string;&#125;//-----tag-----//-----组件-----/** * 回收组件 * @param id 组件id * @param comp 组件实例 */public recycle(id: number, comp: IComp) &#123; this._compPools.get(id)?.push(comp);&#125;/** * 创建组件 * @param comp * @returns */public createComp&lt;T&gt;(comp: CompType&lt;T&gt;) &#123; if (!this._comps[comp.tid]) &#123; console.error(&quot;未找到组件&quot; + comp.compName) &#125; let compInstance = this._compPools.get(comp.tid)?.pop() || new this._comps[comp.tid]; return compInstance;&#125;/** * 获得所有组件 * @returns */public getComps() &#123; return this._comps;&#125;//-----组件----- 实体功能实体的功能也很简单，我们定义一个实体池_eid2Entity用于保存当前所有的实体实例，定义一个实体缓存池_eneityPool用来当实体的对象池。 实体功能1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 创建实体 * @returns */public createEntity&lt;E extends Entity = Entity&gt;(): E &#123; let entity = this._eneityPool.pop(); if (!entity) &#123; entity = new Entity(); entity.eid = this._entityId++; &#125; this._eid2Entity.set(entity.eid, entity); return entity as E;&#125;/** * 移除实体 * @param id 实体id * @param entity 实体 */public removeEntity(id: number, entity: Entity) &#123; if (this._eid2Entity.has(id)) &#123; this._eneityPool.push(entity); this._eid2Entity.delete(id); &#125; else &#123; console.warn(&quot;试图销毁不存在的实体&quot;); &#125;&#125;/** * 根据eid获取实体 * @param eid * @returns */public getEntityByEid(eid: number) &#123; return this._eid2Entity.get(eid);&#125;/** * 获得当前活动实体数量 * @returns */public activeEntityCount() &#123; return this._eid2Entity.size;&#125; 系统功能系统功能包括群组功能，过滤功能和组件变化的通知及清除功能。 组件变化的监听是在创建群组的时候就绑定好的。通过获取对应组件id的组件变化数组，存入群组的监听函数，就可以在每次组件变化的时候通知所有监听该组件的群组执行对应的函数。 其他功能就是对上文现有功能的再包装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//-----群组-----/** * 创建群组 * @param matcher */public createGroup&lt;E extends Entity = Entity&gt;(matcher: IMatcher): Group&lt;E&gt; &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = new Group(matcher); this._groups.set(matcher.mid, group); let careCompIds = matcher.indices; for (let i = 0, len = careCompIds.length; i &lt; len; i++) &#123; let child = this._compAddOrRemove.get(careCompIds[i]); if (!child) &#123; child = []; this._compAddOrRemove.set(careCompIds[i], child); &#125; child.push(group.onComponentAddOrRemove.bind(group)); &#125; &#125; return group as unknown as Group&lt;E&gt;;&#125;public query(matcher: IMatcher) &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = this.createGroup(matcher); this._eid2Entity.forEach(group.onComponentAddOrRemove, group); &#125; return group.matchEntities;&#125;//-----群组-----/*** 实体身上组件有增删操作，广播通知对应的观察者。* @param entity 实体对象* @param componentTypeId 组件类型id*/public broadcastCompAddOrRemove(entity: Entity, componentTypeId: number) &#123; let events = this._compAddOrRemove.get(componentTypeId); if (events) &#123; for (let i = events.length - 1; i &gt;= 0; i--) &#123; events![i](entity); &#125; &#125;&#125;/*** 清除*/public clear() &#123; this._eid2Entity.forEach((entity) =&gt; &#123; entity.removeSelf(); &#125;); this._groups.forEach((group) =&gt; &#123; group.clear(); &#125;); this._compAddOrRemove.forEach(callbackLst =&gt; &#123; callbackLst.length = 0; &#125;); this._eid2Entity.clear(); this._groups.clear();&#125;//-----过滤-----public getMatherId() &#123; return this._matcherId++;&#125;/** * 判断是否拥有所有对应组件 * @param args * @returns */public allOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().allOf(...args);&#125;/** * 判断是否拥有任意对应组件 * @param args * @returns */public anyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().anyOf(...args);&#125;/** * 判断是否只包含所有对应组件 * @param args * @returns */public onlyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().onlyOf(...args);&#125;/** * 判断是否不包含任意对应组件 * @param args * @returns */public excludeOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().excludeOf();&#125;//-----过滤----- 总的ECS管理类代码如下 ECSManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337import &#123; Comp &#125; from &quot;./Comp&quot;;import Entity from &quot;./Entity&quot;;import Group from &quot;./Group&quot;;import &#123; CompType &#125; from &quot;./Interface/CompType&quot;;import IComp from &quot;./Interface/IComp&quot;;import &#123; IMatcher &#125; from &quot;./Interface/IMatcher&quot;;import &#123; Matcher &#125; from &quot;./Mathcer&quot;;export type CompAddOrRemove = (entity: Entity) =&gt; void;export type CompTypeUnion&lt;T&gt; = CompType&lt;T&gt; | number;export default class ECSManager &#123; private static _instance: ECSManager | null = null; private _compTid = 0; private _entityId = 1; private _matcherId = 1; /** * 注册池，判断是否存在同名组件或标签 */ private _registerPool = &#123;&#125;; /** * 组件注册池 */ private _comps: any[] = []; /** * 组件缓存池 */ private _compPools: Map&lt;number, Comp[]&gt; = new Map(); /** * tag池 */ private _tags: Map&lt;number, string&gt; = new Map(); private _compAddOrRemove: Map&lt;number, CompAddOrRemove[]&gt; = new Map(); /** * 实体池 */ private _eid2Entity: Map&lt;number, Entity&gt; = new Map(); /** * 实体缓存池 */ private _eneityPool: Entity[] = []; private _groups: Map&lt;number, Group&gt; = new Map(); public static getInst(): ECSManager &#123; if (!this._instance) &#123; this._instance = new ECSManager(); &#125; return this._instance; &#125; public getCompTid() &#123; return this._compTid; &#125; //-----注册----- /** * 注册组件 * @param compName * @param canNew * @returns */ public register&lt;T&gt;(compName: string, canNew: boolean = true) &#123; return function (comp: CompType&lt;T&gt;) &#123; if (comp.tid == -1) &#123; let manager = ECSManager.getInst(); if (manager._registerPool[compName]) &#123; console.warn(&quot;组件与标签重名:&quot;, compName); &#125; else &#123; comp.tid = manager._compTid++; comp.compName = compName; if (canNew) &#123; manager._comps.push(comp); manager._compPools.set(comp.tid, []); &#125; else &#123; manager._comps.push(null); &#125; manager._compAddOrRemove.set(comp.tid, []); console.log(&quot;组件&quot; + compName + &quot;注册成功:&quot;, comp.tid) manager._registerPool[compName] = true; &#125; &#125; else &#123; console.log(&quot;组件已注册&quot;); &#125; &#125; &#125; /** * 注册tag * @returns */ public registerTag() &#123; return function (_class: any) &#123; let manager = ECSManager.getInst(); let tid = manager._compTid; for (let k in _class) &#123; if (manager._registerPool[k]) &#123; console.warn(&quot;标签与组件重名:&quot;, k); &#125; else &#123; tid = manager._compTid++; _class[k] = tid; manager._comps.push(tid); manager._compPools.set(tid, []); manager._compAddOrRemove.set(tid, []); manager._tags.set(tid, k); console.log(&quot;标签&quot; + k + &quot;注册成功:&quot;, tid) manager._registerPool[k] = true; &#125; &#125; &#125; &#125; //-----注册----- //-----tag----- /** * 是否有tag * @param id * @returns */ public hasTag(id: number) &#123; return this._tags.has(id); &#125; /** * 获得tag * @param id * @returns */ public getTag(id: number): string &#123; return this._tags.get(id) as string; &#125; //-----tag----- //-----组件----- /** * 回收组件 * @param id 组件id * @param comp 组件实例 */ public recycle(id: number, comp: IComp) &#123; this._compPools.get(id)?.push(comp); &#125; /** * 创建组件 * @param comp * @returns */ public createComp&lt;T&gt;(comp: CompType&lt;T&gt;) &#123; if (!this._comps[comp.tid]) &#123; console.error(&quot;未找到组件&quot; + comp.compName) &#125; let compInstance = this._compPools.get(comp.tid)?.pop() || new this._comps[comp.tid]; return compInstance; &#125; /** * 获得所有组件 * @returns */ public getComps() &#123; return this._comps; &#125; /** * 实体身上组件有增删操作，广播通知对应的观察者。 * @param entity 实体对象 * @param componentTypeId 组件类型id */ public broadcastCompAddOrRemove(entity: Entity, componentTypeId: number) &#123; let events = this._compAddOrRemove.get(componentTypeId); if (events) &#123; for (let i = events.length - 1; i &gt;= 0; i--) &#123; events![i](entity); &#125; &#125; &#125; //-----组件----- //-----实体----- /** * 创建实体 * @returns */ public createEntity&lt;E extends Entity = Entity&gt;(): E &#123; let entity = this._eneityPool.pop(); if (!entity) &#123; entity = new Entity(); entity.eid = this._entityId++; &#125; this._eid2Entity.set(entity.eid, entity); return entity as E; &#125; /** * 移除实体 * @param id 实体id * @param entity 实体 */ public removeEntity(id: number, entity: Entity) &#123; if (this._eid2Entity.has(id)) &#123; this._eneityPool.push(entity); this._eid2Entity.delete(id); &#125; else &#123; console.warn(&quot;试图销毁不存在的实体&quot;); &#125; &#125; /** * 根据eid获取实体 * @param eid * @returns */ public getEntityByEid(eid: number) &#123; return this._eid2Entity.get(eid); &#125; /** * 获得当前活动实体数量 * @returns */ public activeEntityCount() &#123; return this._eid2Entity.size; &#125; /** * 清除 */ public clear() &#123; this._eid2Entity.forEach((entity) =&gt; &#123; entity.removeSelf(); &#125;); this._groups.forEach((group) =&gt; &#123; group.clear(); &#125;); this._compAddOrRemove.forEach(callbackLst =&gt; &#123; callbackLst.length = 0; &#125;); this._eid2Entity.clear(); this._groups.clear(); &#125; //-----实体----- //-----群组----- /** * 创建群组 * @param matcher */ public createGroup&lt;E extends Entity = Entity&gt;(matcher: IMatcher): Group&lt;E&gt; &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = new Group(matcher); this._groups.set(matcher.mid, group); let careCompIds = matcher.indices; for (let i = 0, len = careCompIds.length; i &lt; len; i++) &#123; let child = this._compAddOrRemove.get(careCompIds[i]); if (!child) &#123; child = []; this._compAddOrRemove.set(careCompIds[i], child); &#125; child.push(group.onComponentAddOrRemove.bind(group)); &#125; &#125; return group as unknown as Group&lt;E&gt;; &#125; public query(matcher: IMatcher) &#123; let group = this._groups.get(matcher.mid); if (!group) &#123; group = this.createGroup(matcher); this._eid2Entity.forEach(group.onComponentAddOrRemove, group); &#125; return group.matchEntities; &#125; //-----群组----- //-----过滤----- public getMatherId() &#123; return this._matcherId++; &#125; /** * 判断是否拥有所有对应组件 * @param args * @returns */ public allOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().allOf(...args); &#125; /** * 判断是否拥有任意对应组件 * @param args * @returns */ public anyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().anyOf(...args); &#125; /** * 判断是否只包含所有对应组件 * @param args * @returns */ public onlyOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().onlyOf(...args); &#125; /** * 判断是否不包含任意对应组件 * @param args * @returns */ public excludeOf(...args: CompTypeUnion&lt;IComp&gt;[]) &#123; return new Matcher().excludeOf(); &#125; //-----过滤-----&#125; 使用方法Tag示例1234567import ECSManager from &quot;../../../ECS/ECSManager&quot;;@ECSManager.getInst().registerTag()export default class StatusTags &#123; public static StatusA = 0; public static StatusB = 1;&#125; Comp示例123456789101112import &#123; Comp &#125; from &quot;../../../ECS/Comp&quot;;import ECSManager from &quot;../../../ECS/ECSManager&quot;;@ECSManager.getInst().register(&quot;Transform&quot;)export default class TransformComp extends Comp &#123; /** 坐标 */ public position: Laya.Vector3 = new Laya.Vector3(); reset(): void &#123; this.position.set(0, 0, 0); &#125;&#125; Entity示例123456import Entity from &quot;../../../ECS/Entity&quot;;import TransformComp from &quot;../Comp/TransformComp&quot;;export default class RoleEntity extends Entity &#123; public Transform: TransformComp;&#125; ComblockSystem示例123456789101112131415161718192021222324252627import &#123; ComblockSystem &#125; from &quot;../../../ECS/ComBlockSystem&quot;;import ECSManager from &quot;../../../ECS/ECSManager&quot;;import &#123; IMatcher &#125; from &quot;../../../ECS/Interface/IMatcher&quot;;import &#123; IEntityEnterSystem &#125; from &quot;../../../ECS/Interface/ISystem&quot;;import ServantComp from &quot;../Comp/ServantComp&quot;;import WorkerComp from &quot;../Comp/WorkerComp&quot;;import RoleEntity from &quot;../Entity/RoleEntity&quot;;/** * 工作系统 */export default class WorkSystem extends ComblockSystem&lt;RoleEntity&gt; implements IEntityEnterSystem&lt;RoleEntity&gt;&#123; entityEnter(entities: RoleEntity[]): void &#123; for (let e of entities) &#123; &#125; &#125; filter(): IMatcher &#123; return ECSManager.getInst().anyOf(WorkerComp, ServantComp); &#125; update(entities: RoleEntity[]): void &#123; for (let e of entities) &#123; &#125; &#125;&#125; RootSystem示例1234567891011121314151617181920import Globals from &quot;../../../Config/Globals&quot;;import &#123; RootSystem &#125; from &quot;../../../ECS/RootSystem&quot;;import CarShopSystem from &quot;../System/CarShopSystem&quot;;import CarSystem from &quot;../System/CarSystem&quot;;import CustomSystem from &quot;../System/CustomSystem&quot;;import DollSystem from &quot;../System/DollSystem&quot;;import MoveSystem from &quot;../System/MoveSystem&quot;;import NpcSystem from &quot;../System/NpcSystem&quot;;import PathFindingSystem from &quot;../System/PathFindingSystem&quot;;import WorkSystem from &quot;../System/WorkSystem&quot;;/** * 慢速根系统 */export default class RootSlowSystem extends RootSystem &#123; constructor() &#123; super(); this.add(new WorkSystem()); &#125;&#125; 根系统调用示例123456789101112onAwake()&#123; this._rootSlowSystem = new RootSlowSystem(); this._rootSlowSystem.init();&#125;onUpdate()&#123; this._rootSlowSystem.execute(Laya.timer.delta);&#125;onDisable() &#123; this._rootSlowSystem.clear();&#125; 代码由于本项目代码较多，因此请移步GitHub查看详细代码。","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ECS","slug":"ECS","permalink":"https://busyogg.github.io/tags/ECS/"}]},{"title":"Laya实现FixedUpdate","slug":"Laya实现FixedUpdate","date":"2023-09-13T10:14:10.000Z","updated":"2023-09-17T16:54:29.826Z","comments":true,"path":"article/f6c36db9b473/","link":"","permalink":"https://busyogg.github.io/article/f6c36db9b473/","excerpt":"","text":"简介有时候我们需要固定每秒固定次数更新的功能的时候，例如Unity的FixedUpdate，Laya本身不提供这样的方法，或许有人用定时器实现，但是定时器不易管理。本项目提供一种基于帧更新的定时更新方法以解决这个问题。 基本原理每帧更新的时候计算总更新时间，根据总更新时间除以间隔时间获得当前帧需要更新的次数，根据更新次数循环更新。以此我们可以实现和帧率不同的更新频率。 本例设置间隔时间为50ms，即每秒运行20次。如果当前总帧间隔时间小于50ms的情况下，_fiexdTimes运行次数为0，于是当前帧不运行onFixedUpdate，反之运行n次。 60fps的情况下，每三帧间隔时间达到50ms，运行一次onFixedUpdate。 30fps的情况下，头2次每2帧间隔时间超过50ms，运行1次，第3次开始由于之前保存的时间为 _savedTime = 32 * 2 - 50 + 32 * 2 -50 = 28 ,加上当前帧的32ms于是大于50ms，运行一次。即前7帧为2帧2次后1帧1次。 10fps的情况下，每帧间隔100ms，因此每帧运行两次onFixedUpdate。 通过动态平衡每帧需要执行的次数，就能控制每秒执行的总次数不变。 运行的过程中可能会出现单帧运行时间Math.floor(this._fiexdTimes) * this._intervals实际小于间隔时间this._deltaTime的情况，因此增设一个_savedTime来保存未参与运算的时间，同时为了防止保存的时间和帧间隔时间过长（小游戏挂到后台，游戏暂停导致deltaTime过大）导致重复运行次数过多，因此在每帧参与运算之前都会对其进行上限判断。这部分可以根据需要自行删改。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** 累计时间 */private _deltaTime = 0;/** 上一fixed update 剩余时间 */private _savedTime = 0;/** fixed update 执行次数 */private _fiexdTimes = 0;/** 逻辑帧间隔时间 单位毫秒 50即每秒更新20次*/private _intervals = 50; /** * 固定更新 */private fixedUpdate() &#123; let mark = false; let curDelta = Laya.timer.delta; curDelta = curDelta &lt; this._intervals ? curDelta : this._intervals; //防止出现长时间放置导致的保存时间过长 if (this._savedTime &gt; this._intervals) &#123; this._savedTime = this._intervals; &#125; //累计间隔时间 this._deltaTime += curDelta + this._savedTime; //更新次数 this._fiexdTimes = this._deltaTime / this._intervals; for (let i = 1; i &lt; this._fiexdTimes; i++) &#123; this.onFixedUpdate(); mark = true; &#125; if (mark) &#123; this._savedTime = this._deltaTime - Math.floor(this._fiexdTimes) * this._intervals; this._deltaTime = 0; &#125; else &#123; this._savedTime = 0; &#125;&#125;/** * 固定更新运行内容 */onFixedUpdate() &#123; &#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"四叉树空间管理","slug":"四叉树空间管理","date":"2023-09-11T18:56:40.000Z","updated":"2023-09-25T15:20:06.410Z","comments":true,"path":"article/3357cf00d6c0/","link":"","permalink":"https://busyogg.github.io/article/3357cf00d6c0/","excerpt":"","text":"简介在游戏开发的过程中，我们要对空间进行管理，一个比较常用的方法就是用四叉树进行管理，采用的是分治的思路，把一个大的空间分为若干小空间进行管理。 原理四叉树的思路很简单，和二分查找类似 首先我们要定义一个范围，作为空间管理的基础。 然后把这个范围划分为四块。 所有操作都按照这个空间来进行，当前格子不满足条件的情况就向下拓展。 现在，我们要找到空间中的一个物体，我们就不需要从大的黑色的这个范围全部遍历物体，而是在红色分割线划分出来的小空间里面遍历该空间中存储的物体。 如图所示，下面就是一个最基础的四叉树分割。我们把一个大的空间分为了四个小的空间。 四叉树定义现在，我们遇到了第一个问题，要通过什么规则来决定是否需要划分空间呢？ 这里就要引入节点深度和节点容量的概念。 节点深度决定四叉树能够拓展到多深 节点容量决定非最深节点能存储对象的最大数量。 当非最深节点的节点容量未满的时候，节点不进行分割，所有的对象都存储在当前的节点；当容量满了之后，节点分割为更小的四块，并且节点中存储的对象通过查询比较包围盒大小，满足条件的存入新的节点中，不满足条件的则继续存放在该节点。 现在，我们往这个空间里放入一些对象。我们假设深度为2，容量也为2。那么就有如下图所示的情况。 image.png 橙色代表插入的对象，我们可以观察到，在红色分割线划分的右上角格子中，我们插入了4个对象。此时该节点深度为1，对象为4超过了节点的最大容量，因此我们继续分割，分割出粉色线四个格子。右上粉色格子对象数量为3，此时虽然超出了最大容量，但由于格子的深度为2，已经达到最大深度，因此无法继续分割，所有的对象都存储在该节点。 四叉树的数据结构可以根据以上概念得出 QTree12345678/** 最大深度 */public _maxDepth = 0;/** 最大数量 */public _maxObjCount = 0;/** 包围盒 */public _bound = &#123;&#125;;/** 根节点 */public _root: Qnode; 此处有一个QNode为四叉树节点，四叉树节点的数据结构如下 QNode12345678910111213141516/** 包围盒 */public _bound: &#123; x, z, w, h, maxX, minX, maxZ, minZ &#125;;/** 宽松包围盒 */public _looseBound: any = &#123;&#125;;/** 父节点 */public _parent: Qnode;/** 所属四叉树 */public _belongTree: Qtree;/** 对象列表 */public _objList = [];/** 子节点字典 */public _childDic = &#123;&#125;;/** 深度 */public _depth: number;/** 对象数量 */public _objCount = 0; 四叉树节点数据结构中的宽松包围盒为松散四叉树所使用，接下来会介绍。对象存储在数组中，子节点可以存为数组，也可以存为字典，最终的结果都是一样存放下一深度的四个节点，可以按照自己的喜好调整。 四叉树操作开始之前，我们要解决一个问题，如何进行对象插入的条件判断？ 在讨论方法之前，我们要先思考一个问题，如果四叉树切线边缘存在物体的情况该如何解决？这里有两种方法，一种是存在父节点，一种是每一个压到的节点都存放一个该对象。 假设这个蓝色的对象插入的时候压到了粉色边线，用第一种方法的时候，我们查找右上角粉色格子内的对象的时候，查找的结果必定会包含蓝色对象，因为蓝色对象本身是属于红色格子的。用第二种方法的时候，左下角和右下角的粉色格子都有保存蓝色对象的信息，占用了两份数据，如果是在粉色十字正中间的时候，存储的数据要变成四份。 这个时候，我们要引入一个松散四叉树的概念。我们在上面的四叉树定义中也提到过松散四叉树，松散四叉树是指每一个分割的格子的包围盒并不一定要严格分割四分之一父节点空间。 如图所示，右下角这个绿色的空间，就是右下角格子的松散包围盒。每一个格子都有自己的松散包围盒。当松散包围盒的大小是格子大小的2倍的时候会产生一个特性，那就是插入对象的中心点只要在格子中，那他必定在这个格子的松散包围盒之内 。因此一般常用2倍大小的松散包围盒。 这个时候，对象压线的问题就得到了解决，只要判断对象的中心属于哪个格子即可。 如图所示，假如橙色部分是插入对象的大小，当他的大小为最大，即红色格子大小时，他的中心点在红色格子的左下角时，依然不会超出绿色松散包围盒大小。 前期工作首先，我们要构造两个方法，一个是判断对象中心是否在格子内，还有一个是判断两个包围盒是否相交。 判断对象中心是否在格子内很简单，只要判断中心点的x和z是否大于包围盒最小值并且小于包围盒最大值即可。 中心点检测123456789101112/** * 检测是否在包围盒内 * @param rect * @returns */ private checkInAreaStrict(rect: RectBean, child: RectBean) &#123; if (rect.minX &gt; child.minX &amp;&amp; rect.maxX &lt; child.maxX &amp;&amp; rect.minZ &gt; child.minZ &amp;&amp; rect.maxZ &lt; child.maxZ) &#123; return true; &#125; return false; &#125; 检测包围盒是否相交的时候只要判断包围盒A的最大值是否小于包围盒B的最小值或者包围盒A的最小值是否大于包围盒B的最大值，这种情况下两包围盒必定不相交。这种方法即AABB（Axially Aligned Bounding Box，按坐标轴排列的包围盒）检测。 AABB相交检测123456789101112131415/** * 检测是否相交 * @param rect * @param child * @returns */ private checkIntractive(rect: RectBean, child: RectBean) &#123; if (rect.maxX &lt; child.minX || rect.minX &gt; child.maxX || rect.maxZ &lt; child.minZ || rect.minZ &gt; child.maxZ) &#123; return false; &#125; return true; &#125; 四叉树插入首先，我们先判断是否需要拓展子节点，就按照上面说的，在不存在子节点并且是根节点，或者当前节点对象数量超出限制数量并且当前节点深度不是最大深度的时候拓展。 然后我们根据规则把对象插入到四叉树中即可。先判断对象是否可以插入当前格，然后判断当前格有无子节点，有子节点尽量把对象插入子节点，同时标记当前格（如果有子节点的话也包括子节点）存储的对象数量。 插入123456789101112131415161718192021222324252627282930313233343536373839/** * 插入对象 * @param obj * @returns */public insert(obj: QtreeObj) &#123; //判断是否创建子节点 if (!this._childDic[&quot;tl&quot;] &amp;&amp; (this._depth == 0 || this._objCount &gt;= this._belongTree._maxObjCount &amp;&amp; this._depth &lt; this._belongTree._maxDepth)) &#123; this.createChild(); //填充对象到新创建的子节点中 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //遍历子节点 for (let prop in this._childDic) &#123; //对象满足子节点条件的，插入到子节点中 if (this.checkInAreaStrict(this._objList[i].rect, this._childDic[prop]._bound)) &#123; this._childDic[prop].insert(this._objList[i]); this._objList.splice(i, 1); break; &#125; &#125; &#125; &#125; if (this._childDic[&quot;tl&quot;]) &#123; //尽可能地分到子节点 for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._objCount++; return this._childDic[key].insert(obj); &#125; &#125; &#125; this._objList.push(obj); ++this._objCount; return this;&#125; 四叉树移除四叉树的移除和插入类似，每个查找到的节点都和需要移除的对象进行对比，如果该节点没有需要移除的对象，就进入到子节点去继续查找，直到找到或者最大深度。移除之后要对插入该对象的每一层的对象数量进行减1。如果四个子节点的对象数量都为0的情况下，父节点可以进行坍缩，即移除四个子节点。 移除12345678910111213141516171819202122232425262728293031/** * 移除对象 * @param obj * @returns */public remove(obj: QtreeObj) &#123; //父节点坍缩 if (this._parent._objCount &lt;= 0) &#123; this._parent._childDic = &#123;&#125;; &#125; //遍历移除 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //比较对象id是否相等，该条件可根据需要自行修改 if (this._objList[i].objId == obj.objId) &#123; this._objList.splice(i, 1); this._objCount--; return; &#125; &#125; //如果当前节点没有匹配对象，则遍历子节点寻找需要移除的对象 if (this._childDic[&quot;tl&quot;]) &#123; for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._childDic[key].remove(obj); this._objCount--; return; &#125; &#125; &#125;&#125; 四叉树查找接下来是四叉树的查找，四叉树的查找可以只查找当前源对象所在的区块，或者也可以进一步筛选和源对象相交的对象，即检测与查找范围包围盒相交的对象。本案例采取进一步筛选的模式。 在四叉树遍历的过程中，先对每个节点的对象进行相交检测，相交的物体加入查找结果数组。然后对于每个子节点，我们都要比较源对象的范围和子节点的松散包围盒是否相交。由于每个子节点都有可能和源对象交汇， 因此四个子节点都要进行判断。 查找1234567891011121314151617181920/** * 查找范围内所有节点 * @param rect */public findObjFromRect(rect: RectBean): QtreeObj[] &#123; let objs = []; //查找匹配对象 for (let key in this._objList) &#123; if (this.checkIntractive(rect, this._objList[key].rect)) &#123; objs.push(this._objList[key]); &#125; &#125; //遍历子节点 for (let key in this._childDic) &#123; if (this._childDic[key].checkIntractive(rect, this._childDic[key]._looseBound)) &#123; objs = objs.concat(this._childDic[key].findObjFromRect(rect)); &#125; &#125; return objs;&#125; 四叉树动态更新四叉树节点的更新也很简单。具体的逻辑如下图所示： 更新12345678910111213/** * 刷新对象在四叉树中的位置 * @param obj * @returns */public refresh(obj: QtreeObj) &#123; if (this.checkInAreaStrict(obj.rect, this._bound)) &#123; return this; &#125; else &#123; this.remove(obj); return this._belongTree.insert(obj); &#125;&#125; 代码包围盒数据结构1234567891011121314151617181920export default class RectBean &#123; constructor(x?, z?, w?, h?, maxX?, minX?, maxZ?, minZ?) &#123; this.x = x; this.z = z; this.w = w; this.h = h; this.maxX = maxX; this.minX = minX; this.maxZ = maxZ; this.minZ = minZ; &#125; public x; public z; public w;//宽 -- x方向 public h;//高 -- z方向 public maxX; public minX; public maxZ; public minZ;&#125; 四叉树对象数据结构123456789101112131415161718import &#123; BoxCollider &#125; from &quot;../../../../../libs/Collider&quot;;export default class QtreeObj &#123; constructor(id?, objId?, rect?, node?) &#123; this.id = id; this.objId = objId; this.rect = rect; this.node = node; &#125; /** id 一般只需要这个就够了 必要属性 */ public id: number; /** 对象id 此处为项目需要而增加的id */ public objId: number; /** 范围 必要属性 */ public rect; /** 节点 必要属性 */ public node: Laya.Sprite3D;&#125; 四叉树脚本12345678910111213141516171819202122232425262728293031import QtreeObj from &quot;./Bean/QtreeObj&quot;;import Qnode from &quot;./Qnode&quot;;export default class Qtree&#123; public _maxDepth = 0; public _maxObjCount = 0; public _bound = &#123;&#125;; /** 子节点 */ public _root: Qnode; constructor(bound,maxDepth,maxObjCount)&#123; this._bound = bound; this._maxDepth = maxDepth; this._maxObjCount = maxObjCount; this._root = new Qnode(bound, 0, this, this); &#125; public insert(obj: QtreeObj): void &#123; return this._root.insert(obj); &#125; public remove(obj: QtreeObj)&#123; this._root.remove(obj); &#125; public findObjFromRect(rect):QtreeObj[]&#123; return this._root.findObjFromRect(rect); &#125;&#125; 四叉树节点脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277import ModelFactory from &quot;../../Common/ModelFactory&quot;;import QtreeObj from &quot;./Bean/QtreeObj&quot;;import RectBean from &quot;./Bean/RectBean&quot;;import Qtree from &quot;./Qtree&quot;;export default class Qnode &#123; /** 包围盒 */ public _bound: &#123; x, z, w, h, maxX, minX, maxZ, minZ &#125;; /** 宽松包围盒 */ public _looseBound: any = &#123;&#125;; /** 父节点 */ public _parent: Qnode; /** 所属四叉树 */ public _belongTree: Qtree; /** 对象列表 */ public _objList = []; /** 子节点字典 */ public _childDic = &#123;&#125;; /** 深度 */ public _depth: number; /** 对象数量 */ public _objCount = 0; private _debugColor: Laya.Color = new Laya.Color(1, 0, 0, 1); private _debugColor2: Laya.Color = new Laya.Color(0, 1, 1, 1); private _debugView: Laya.PixelLineSprite3D; constructor(bound, depth, parent, belongTree) &#123; this._bound = bound; this._depth = depth; this._parent = parent; this._belongTree = belongTree; this._looseBound = &#123; x: bound.x, z: bound.z, w: bound.w * 2, h: bound.h * 2, maxX: bound.x + bound.w, minX: bound.x - bound.w, maxZ: bound.z + bound.h, minZ: bound.z - bound.h &#125; //绘制四叉树范围 // this.showDebugMode(); &#125; /** * 绘制四叉树范围 Laya版本 * @param loose 是否绘制松散范围 */ private showDebugMode(loose?) &#123; Laya.timer.once(1000, this, () =&gt; &#123; //场景中插入线段 this._debugView = new Laya.PixelLineSprite3D(99999); ModelFactory.getScene().addChild(this._debugView); for (let t = this._debugView.lineCount - 1; t &gt;= 0; t--) this._debugView.removeLine(t); //紧凑四叉树 this._debugView.addLine(new Laya.Vector3(this._bound.maxX, 0.1, this._bound.maxZ), new Laya.Vector3(this._bound.maxX, 0.1, this._bound.minZ), this._debugColor, this._debugColor); this._debugView.addLine(new Laya.Vector3(this._bound.minX, 0.1, this._bound.maxZ), new Laya.Vector3(this._bound.minX, 0.1, this._bound.minZ), this._debugColor, this._debugColor); this._debugView.addLine(new Laya.Vector3(this._bound.maxX, 0.1, this._bound.maxZ), new Laya.Vector3(this._bound.minX, 0.1, this._bound.maxZ), this._debugColor, this._debugColor); this._debugView.addLine(new Laya.Vector3(this._bound.maxX, 0.1, this._bound.minZ), new Laya.Vector3(this._bound.minX, 0.1, this._bound.minZ), this._debugColor, this._debugColor); if (loose) &#123; //松散四叉树 this._debugView.addLine(new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.maxZ), new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.minZ), this._debugColor2, this._debugColor2); this._debugView.addLine(new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.maxZ), new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.minZ), this._debugColor2, this._debugColor2); this._debugView.addLine(new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.maxZ), new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.maxZ), this._debugColor2, this._debugColor2); this._debugView.addLine(new Laya.Vector3(this._looseBound.maxX, 0.1, this._looseBound.minZ), new Laya.Vector3(this._looseBound.minX, 0.1, this._looseBound.minZ), this._debugColor2, this._debugColor2); &#125; &#125;) &#125; /** * 插入对象 * @param obj * @returns */ public insert(obj: QtreeObj) &#123; //判断是否创建子节点 if (!this._childDic[&quot;tl&quot;] &amp;&amp; (this._depth == 0 || this._objCount &gt;= this._belongTree._maxObjCount &amp;&amp; this._depth &lt; this._belongTree._maxDepth)) &#123; this.createChild(); //填充对象到新创建的子节点中 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //遍历子节点 for (let prop in this._childDic) &#123; //对象满足子节点条件的，插入到子节点中 if (this.checkInAreaStrict(this._objList[i].rect, this._childDic[prop]._bound)) &#123; this._childDic[prop].insert(this._objList[i]); this._objList.splice(i, 1); break; &#125; &#125; &#125; &#125; if (this._childDic[&quot;tl&quot;]) &#123; //尽可能地分到子节点 for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._objCount++; return this._childDic[key].insert(obj); &#125; &#125; &#125; this._objList.push(obj); ++this._objCount; return this; &#125; /** * 移除对象 * @param obj * @returns */ public remove(obj: QtreeObj) &#123; //父节点坍缩 if (this._parent._objCount &lt;= 0) &#123; this._parent._childDic = &#123;&#125;; &#125; //遍历移除 for (let i = this._objList.length - 1; i &gt;= 0; i--) &#123; //比较对象id是否相等，该条件可根据需要自行修改 if (this._objList[i].objId == obj.objId) &#123; this._objList.splice(i, 1); this._objCount--; return; &#125; &#125; //如果当前节点没有匹配对象，则遍历子节点寻找需要移除的对象 if (this._childDic[&quot;tl&quot;]) &#123; for (let key in this._childDic) &#123; if (this.checkInAreaStrict(obj.rect, this._childDic[key]._bound)) &#123; this._childDic[key].remove(obj); this._objCount--; return; &#125; &#125; &#125; &#125; /** * 查找范围内所有节点 * @param rect */ public findObjFromRect(rect: RectBean): QtreeObj[] &#123; let objs = []; //查找匹配对象 for (let key in this._objList) &#123; if (this.checkIntractive(rect, this._objList[key].rect)) &#123; objs.push(this._objList[key]); &#125; &#125; //遍历子节点 for (let key in this._childDic) &#123; if (this._childDic[key].checkIntractive(rect, this._childDic[key]._looseBound)) &#123; objs = objs.concat(this._childDic[key].findObjFromRect(rect)); &#125; &#125; return objs; &#125; /** * 刷新对象在四叉树中的位置 * @param obj * @returns */ public refresh(obj: QtreeObj) &#123; if (this.checkInAreaStrict(obj.rect, this._bound)) &#123; return this; &#125; else &#123; this.remove(obj); return this._belongTree.insert(obj); &#125; &#125; /** * 创建子节点 */ private createChild() &#123; let bound1 = &#123; x: this._bound.x + this._bound.w * 0.25, z: this._bound.z + this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x + this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x + this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z + this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z + this._bound.h * 0.25 - this._bound.h * 0.25 &#125;; this._childDic[&quot;tl&quot;] = new Qnode(bound1, this._depth + 1, this._parent, this._belongTree); let bound2 = &#123; x: this._bound.x - this._bound.w * 0.25, z: this._bound.z + this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x - this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x - this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z + this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z + this._bound.h * 0.25 - this._bound.h * 0.25 &#125;; this._childDic[&quot;tr&quot;] = new Qnode(bound2, this._depth + 1, this._parent, this._belongTree); let bound3 = &#123; x: this._bound.x + this._bound.w * 0.25, z: this._bound.z - this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x + this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x + this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z - this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z - this._bound.h * 0.25 - this._bound.h * 0.25 &#125;; this._childDic[&quot;bl&quot;] = new Qnode(bound3, this._depth + 1, this._parent, this._belongTree); let bound4 = &#123; x: this._bound.x - this._bound.w * 0.25, z: this._bound.z - this._bound.h * 0.25, w: this._bound.w * 0.5, h: this._bound.h * 0.5, maxX: this._bound.x - this._bound.w * 0.25 + this._bound.w * 0.25, minX: this._bound.x - this._bound.w * 0.25 - this._bound.w * 0.25, maxZ: this._bound.z - this._bound.h * 0.25 + this._bound.h * 0.25, minZ: this._bound.z - this._bound.h * 0.25 - this._bound.h * 0.25 &#125;; this._childDic[&quot;br&quot;] = new Qnode(bound4, this._depth + 1, this._parent, this._belongTree); &#125; /** * 检测是否在包围盒内 * @param rect * @returns */ private checkInAreaStrict(rect: RectBean, child: RectBean) &#123; if (rect.minX &gt; child.minX &amp;&amp; rect.maxX &lt; child.maxX &amp;&amp; rect.minZ &gt; child.minZ &amp;&amp; rect.maxZ &lt; child.maxZ) &#123; return true; &#125; return false; &#125; /** * 检测是否相交 * @param rect * @param child * @returns */ private checkIntractive(rect: RectBean, child: RectBean) &#123; if (rect.maxX &lt; child.minX || rect.minX &gt; child.maxX || rect.maxZ &lt; child.minZ || rect.minZ &gt; child.maxZ) &#123; return false; &#125; return true; &#125;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"四叉树","slug":"四叉树","permalink":"https://busyogg.github.io/tags/%E5%9B%9B%E5%8F%89%E6%A0%91/"},{"name":"空间管理","slug":"空间管理","permalink":"https://busyogg.github.io/tags/%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"}]},{"title":"基于IP的SSL证书签发","slug":"基于IP的SSL证书签发","date":"2023-09-09T20:37:36.000Z","updated":"2023-09-17T16:54:29.786Z","comments":true,"path":"article/e01680050386/","link":"","permalink":"https://busyogg.github.io/article/e01680050386/","excerpt":"","text":"简介网上大部分SSL证书都需要域名来签发，这里找到一个可以用IP来签发的SSL证书申请。 网址ZeroSSLhttps://app.zerossl.com/ 使用说明 由于没有使用过邮件验证，因此不提供具体方法。 如果选择CNAME验证，则到DNS管理填入CNAME给的参数，此处以Cloudflare举例 如果选HTTP验证 nginx代理可以自行搜索 linux nginx 访问本地文件 证书签发后我们可以根据需要安装证书 然后选择对应的类型根据提示进行安装","categories":[{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"SSL证书","slug":"SSL证书","permalink":"https://busyogg.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"}]},{"title":"Cloudflare加速github访问","slug":"Cloudflare加速github访问","date":"2023-09-09T19:27:19.000Z","updated":"2023-09-17T16:54:29.750Z","comments":true,"path":"article/ae66b10eef2c/","link":"","permalink":"https://busyogg.github.io/article/ae66b10eef2c/","excerpt":"","text":"简介利用Cloudflare代理访问GitHub地址，同理可应用于其他网址。 准备 Cloudflare账号 域名（自行注册） 实现方法 登录Cloudflare，把你的域名添加到Cloudflare。 处理域名的DNS 新增Woker worker代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&#x27;use strict&#x27;/** * static files (404.html, sw.js, conf.js) */const ASSET_URL = &#x27;https://域名/&#x27;// 前缀，如果自定义路由为example.com/gh/*，将PREFIX改为 &#x27;/gh/&#x27;，注意，少一个杠都会错！const PREFIX = &#x27;/&#x27;// 分支文件使用jsDelivr镜像的开关，0为关闭，默认关闭const Config = &#123; jsdelivr: 0&#125;const whiteList = [] // 白名单，路径里面有包含字符的才会通过，e.g. [&#x27;/username/&#x27;]/** @type &#123;RequestInit&#125; */const PREFLIGHT_INIT = &#123; status: 204, headers: new Headers(&#123; &#x27;access-control-allow-origin&#x27;: &#x27;*&#x27;, &#x27;access-control-allow-methods&#x27;: &#x27;GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS&#x27;, &#x27;access-control-max-age&#x27;: &#x27;1728000&#x27;, &#125;),&#125;const exp1 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:releases|archive)\\/.*$/iconst exp2 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:blob|raw)\\/.*$/iconst exp3 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/(?:info|git-).*$/iconst exp4 = /^(?:https?:\\/\\/)?raw\\.(?:githubusercontent|github)\\.com\\/.+?\\/.+?\\/.+?\\/.+$/iconst exp5 = /^(?:https?:\\/\\/)?gist\\.(?:githubusercontent|github)\\.com\\/.+?\\/.+?\\/.+$/iconst exp6 = /^(?:https?:\\/\\/)?github\\.com\\/.+?\\/.+?\\/tags.*$/i/** * @param &#123;any&#125; body * @param &#123;number&#125; status * @param &#123;Object&lt;string, string&gt;&#125; headers */function makeRes(body, status = 200, headers = &#123;&#125;) &#123; headers[&#x27;access-control-allow-origin&#x27;] = &#x27;*&#x27; return new Response(body, &#123;status, headers&#125;)&#125;/** * @param &#123;string&#125; urlStr */function newUrl(urlStr) &#123; try &#123; return new URL(urlStr) &#125; catch (err) &#123; return null &#125;&#125;addEventListener(&#x27;fetch&#x27;, e =&gt; &#123; const ret = fetchHandler(e) .catch(err =&gt; makeRes(&#x27;cfworker error:\\n&#x27; + err.stack, 502)) e.respondWith(ret)&#125;)function checkUrl(u) &#123; for (let i of [exp1, exp2, exp3, exp4, exp5, exp6]) &#123; if (u.search(i) === 0) &#123; return true &#125; &#125; return false&#125;/** * @param &#123;FetchEvent&#125; e */async function fetchHandler(e) &#123; const req = e.request const urlStr = req.url const urlObj = new URL(urlStr) let path = urlObj.searchParams.get(&#x27;q&#x27;) if (path) &#123; return Response.redirect(&#x27;https://&#x27; + urlObj.host + PREFIX + path, 301) &#125; // cfworker 会把路径中的 `//` 合并成 `/` path = urlObj.href.substr(urlObj.origin.length + PREFIX.length).replace(/^https?:\\/+/, &#x27;https://&#x27;) if (path.search(exp1) === 0 || path.search(exp5) === 0 || path.search(exp6) === 0 || path.search(exp3) === 0 || path.search(exp4) === 0) &#123; return httpHandler(req, path) &#125; else if (path.search(exp2) === 0) &#123; if (Config.jsdelivr) &#123; const newUrl = path.replace(&#x27;/blob/&#x27;, &#x27;@&#x27;).replace(/^(?:https?:\\/\\/)?github\\.com/, &#x27;https://cdn.jsdelivr.net/gh&#x27;) return Response.redirect(newUrl, 302) &#125; else &#123; path = path.replace(&#x27;/blob/&#x27;, &#x27;/raw/&#x27;) return httpHandler(req, path) &#125; &#125; else if (path.search(exp4) === 0) &#123; const newUrl = path.replace(/(?&lt;=com\\/.+?\\/.+?)\\/(.+?\\/)/, &#x27;@$1&#x27;).replace(/^(?:https?:\\/\\/)?raw\\.(?:githubusercontent|github)\\.com/, &#x27;https://cdn.jsdelivr.net/gh&#x27;) return Response.redirect(newUrl, 302) &#125; else &#123; return fetch(ASSET_URL + path) &#125;&#125;/** * @param &#123;Request&#125; req * @param &#123;string&#125; pathname */function httpHandler(req, pathname) &#123; const reqHdrRaw = req.headers // preflight if (req.method === &#x27;OPTIONS&#x27; &amp;&amp; reqHdrRaw.has(&#x27;access-control-request-headers&#x27;) ) &#123; return new Response(null, PREFLIGHT_INIT) &#125; const reqHdrNew = new Headers(reqHdrRaw) let urlStr = pathname let flag = !Boolean(whiteList.length) for (let i of whiteList) &#123; if (urlStr.includes(i)) &#123; flag = true break &#125; &#125; if (!flag) &#123; return new Response(&quot;blocked&quot;, &#123;status: 403&#125;) &#125; if (urlStr.startsWith(&#x27;github&#x27;)) &#123; urlStr = &#x27;https://&#x27; + urlStr &#125; const urlObj = newUrl(urlStr) /** @type &#123;RequestInit&#125; */ const reqInit = &#123; method: req.method, headers: reqHdrNew, redirect: &#x27;manual&#x27;, body: req.body &#125; return proxy(urlObj, reqInit)&#125;/** * * @param &#123;URL&#125; urlObj * @param &#123;RequestInit&#125; reqInit */async function proxy(urlObj, reqInit) &#123; const res = await fetch(urlObj.href, reqInit) const resHdrOld = res.headers const resHdrNew = new Headers(resHdrOld) const status = res.status if (resHdrNew.has(&#x27;location&#x27;)) &#123; let _location = resHdrNew.get(&#x27;location&#x27;) if (checkUrl(_location)) resHdrNew.set(&#x27;location&#x27;, PREFIX + _location) else &#123; reqInit.redirect = &#x27;follow&#x27; return proxy(newUrl(_location), reqInit) &#125; &#125; resHdrNew.set(&#x27;access-control-expose-headers&#x27;, &#x27;*&#x27;) // resHdrNew.set(&#x27;access-control-allow-origin&#x27;, &#x27;*&#x27;) resHdrNew.delete(&#x27;content-security-policy&#x27;) resHdrNew.delete(&#x27;content-security-policy-report-only&#x27;) resHdrNew.delete(&#x27;clear-site-data&#x27;) return new Response(res.body, &#123; status, headers: resHdrNew, &#125;)&#125; 设置路由 例如我的路由为 所有步骤完成后基本上就可以根据你的域名访问GitHub托管的博客了，如果没有效果的话可能要等Cloudflare域名激活或者等一会儿worker生效 GitHub图床GitHub图床也可以用这个worker代码来代理，新增一个worker，注意github图片的代理地址要写https://raw.githubusercontent.com/GitHub用户名/图床仓库名/分支名/，根据个人情况进行修改。可以在域名下添加一个路由，我是用的是img.busyo.buzz/*进行路由，然后添加img的DNS，访问图片只要使用https://img.busyo.buzz/仓库中的图片路径即可。 例： 12345678910//代理地址https://raw.githubusercontent.com/UserName/PictureReposity/main///仓库结构PictureReposity|- picture|-- test.png//访问地址https://domain.com/picture/test.png","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"https://busyogg.github.io/tags/GitHub/"},{"name":"网络加速","slug":"网络加速","permalink":"https://busyogg.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"}]},{"title":"Hexo博客搭建 美化篇","slug":"Hexo博客搭建-美化篇","date":"2023-09-01T00:07:42.000Z","updated":"2023-10-30T18:25:35.897Z","comments":true,"path":"article/38effc2a84e9/","link":"","permalink":"https://busyogg.github.io/article/38effc2a84e9/","excerpt":"","text":"简介本网站使用的是Volantis主题，并对其进行了自定义改造。 安装在 _config.yml 文件中修改以下项目 config.yml1theme: volantis 然后通过npm安装主题文件 主题安装1npm i hexo-theme-volantis 安装完主题后，在博客的根目录创建一个新的配置文件 _config.volantis.yml，并且从主题文件夹中复制配置文件的内容进来，以便修改配置。 因为我们是通过npm方式安装，因此主题配置文件在\\node_modules\\hexo-theme-volantis\\_config.yml 该主题自带的搜索功能需要安装额外模块 搜索安装1npm i -S hexo-generator-json-content 然后修改配置文件 _config.volantis.yml123search: enable: true service: hexo 配置主题主题配置可以阅读主题文档进行对应的配置。 主题配置https://volantis.js.org/v6/theme-settings/ 以下为本博客主要调节的配置 导航_config.volantis.yml12345678910111213141516171819202122232425navbar: width: auto visiable: always # always, auto effect: [shadow, blur] # [shadow, floatable, blur] logo: # choose [img] or [icon + title] img: /images/img_logo.png #logo图片路径 icon: title: menu: - name: 主页 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 暗黑模式 # 可自定义 icon: fa-solid fa-moon # 可自定义 toggle: darkmode search: Search... # Search bar placeholder 导航新增了分类和标签两个栏目，以及黑暗模式的切换按钮 分类和标签使用代码创建 12hexo new page categorieshexo new page tags 创建完成后，我们到source文件夹下对应的文件夹修改index.md文件 categories123456---layout: categoryindex: truetitle: 所有分类sidebar: [blogger,music,category, tagcloud, webinfo]--- tags123456---layout: tagindex: truetitle: 所有标签sidebar: [blogger,music,category, tagcloud, webinfo]--- 这里的sidebar是组件列表，可以根据需要参考主题文档自己修改 首页Cover_config.volantis.yml1234567891011121314cover: height_scheme: half # full, half layout_scheme: featured # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) display: home: true archive: false others: false # can be written in front-matter &#x27;cover: true&#x27; background: https://gcore.jsdelivr.net/gh/MHG-LAB/cron@gh-pages/bing/bing.jpg #背景图 # background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &quot;Busyo&#x27;s Blog&quot; #中间显示的文字 subtitle: &#x27;&#x27; search: A Wonderful Theme for Hexo # search bar placeholder # features: 此处本博客选择占一半页面的cover，为了保留博客名的显示，选择了非blank的布局，同时为了移除多余的按钮，注释了features的所有内容。display可以选择在什么界面展示。 字体_config.volantis.yml12345678910111213141516171819fontfamily: logofont: fontfamily: &#x27; &quot;haipai&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;haipai&#x27; url: /fonts/haipai.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/VarelaRound/VarelaRound-Regular.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;&quot;haipai&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;haipai&#x27; url: /fonts/haipai.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/UbuntuMono/UbuntuMono-Regular.ttf weight: normal style: normal codefont: fontfamily: &#x27;FiraCode-SemiBold, haipai, Monaco&#x27; name: &#x27;FiraCode-SemiBold&#x27; url: /fonts/FiraCode-SemiBold.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf weight: normal style: normal 此配置可以修改三个地方的字体 logo字体、正文字体和代码字体，本博客使用的字体保存于/source/fonts/文件夹下，因此传入的路径去除source之后就是/fonts/字体 侧边栏组件_config.volantis.yml12345678sidebar: position: right # left right # 主页、分类、归档等独立页面 for_page: [blogger,music,category, tagcloud, webinfo] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: 侧边栏的组件列表内的内容都是从下面组件库中选择，并且组件可根据自己需求调整配置，详情可参考官方文档和配置注释。 文章作者_config.volantis.yml1234567meta_library: # 默认文章作者（可在 _data/author.yaml 中增加其他作者，并在 front-matter 中设置） # https://volantis.js.org/advanced-settings/#多人协同 author: avatar: /images/img_icon.png # 作者头像图片路径 name: 名字 url: / #作者网址 默认即博客网址 插件幻灯片背景_config.volantis.yml12345678910111213141516171819202122232425262728parallax: enable: true position: fixed # cover: 固定位置. fixed: 滚动跟随. shuffle: true # 乱序 duration: 10000 # 显示持续时间 单位毫秒 fade: 500 # 渐变时间 单位毫秒 images: # 图片列表 - volantis-static/media/wallpaper/minimalist/2020/001.webp - volantis-static/media/wallpaper/minimalist/2020/002.webp - volantis-static/media/wallpaper/minimalist/2020/003.webp - volantis-static/media/wallpaper/minimalist/2020/004.webp - volantis-static/media/wallpaper/minimalist/2020/005.webp - volantis-static/media/wallpaper/minimalist/2020/006.webp - volantis-static/media/wallpaper/minimalist/2020/012.webp - volantis-static/media/wallpaper/minimalist/2020/016.webp - volantis-static/media/wallpaper/minimalist/2020/019.webp - volantis-static/media/wallpaper/minimalist/2020/025.webp - volantis-static/media/wallpaper/minimalist/2020/033.webp - volantis-static/media/wallpaper/minimalist/2020/034.webp - volantis-static/media/wallpaper/minimalist/2020/035.webp - volantis-static/media/wallpaper/minimalist/2020/038.webp - volantis-static/media/wallpaper/minimalist/2020/039.webp - volantis-static/media/wallpaper/minimalist/2020/042.webp - volantis-static/media/wallpaper/minimalist/2020/046.webp - volantis-static/media/wallpaper/minimalist/2020/051.webp - volantis-static/media/wallpaper/minimalist/2020/052.webp - volantis-static/media/wallpaper/minimalist/2020/054.webp - volantis-static/media/wallpaper/minimalist/2020/056.webp 音乐播放器_config.volantis.yml1234567891011121314151617181920aplayer: enable: true js: aplayer: volantis-static/libs/aplayer/dist/APlayer.min.js # https://unpkg.com/aplayer@1.10/dist/APlayer.min.js meting: volantis-static/libs/meting/dist/Meting.min.js # https://unpkg.com/meting@2.0/dist/Meting.min.js css: volantis-static/libs/aplayer/dist/APlayer.min.css # https://unpkg.com/aplayer@1.10/dist/APlayer.min.css # Required server: netease # netease, tencent, kugou, xiami, baidu type: playlist # song, playlist, album, search, artist id: 897784673 # song id / playlist id / album id / search keyword # Optional fixed: false # enable fixed mode theme: &#x27;#1BCDFC&#x27; # main color autoplay: false # audio autoplay order: list # player play order, values: &#x27;list&#x27;, &#x27;random&#x27; loop: all # player loop play, values: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;yaml&#x27; volume: 0.7 # default volume, notice that player will remember user setting, default volume will not work after user set volume themselves list_max_height: 320px # list max height list_folded: true autoHide: true # hide automaticaly 设置enable启用，server选择音乐软件，type选择类型，对应音乐软件中的类型，id选择具体的曲目，本博客使用网易云的歌单，id即代表对应的歌单。 如何获得类型和id？ 打开网页版网易云，搜索想要的内容，查看网址栏 统计_config.volantis.yml123456analytics: busuanzi: volantis-static/libs/busuanzi/js/busuanzi.pure.mini.js #https://cdn.jsdelivr.net/gh/volantis-x/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js leancloud: # 请使用自己的 id &amp; key 以防止数据丢失 app_id: # u9j57bwJod4EDmXWdxrwuqQT-MdYXbMMI app_key: # jfHtEKVE24j0IVCGHbvuFClp custom_api_server: # 国际版一般不需要写，除非自定义了 API Server 本博客使用不蒜子统计，若需要更高级的统计，可参考主题文档接入其他统计。 字数统计_config.volantis.yml123# npm i hexo-wordcount wordcount: enable: true 字数统计功能需要安装对应的模块 1npm i hexo-wordcount 界面功能界面支持多种功能，比如评论、标签、摘要、引用等，具体可以参考 界面配置 主题覆盖首先我们在主题文件夹\\node_modules\\hexo-theme-volantis\\source\\css下新建一个文件夹，名字随意，我新建了一个_busyo文件夹。 然后在新建的文件夹下新建一个cover.styl文件用来保存覆盖的样式，一个extra.styl文件用来保存新增的样式，最后我们在_busyo文件夹统计目录下的style.styl文件最末尾新增一行@import &#39;_busyo/*&#39;即可。 之后我们所有的样式改动都可以写在这两个文件夹内。 覆盖样式对于覆盖样式，我们可以利用浏览器的开发者工具定位我们想要修改的元素 此处我们看到class有两个样式，一个叫highlight，一个叫yaml，我们就可以在cover.styl文件夹内新增同名内容来修改他们。格式如下： cover.styl1234.highlight border: 3px solid rgba(0,0,0,0.5) border-radius: 20px overflow:hidden 属性修改即是css的修改，可以根据css的相关内容自己调整。 新增样式对于新增样式，可以在extra.styl文件新增不重名的样式，然后在对应的布局文件中对应的部分的class内容中加上你增加的样式。 布局文件的路径在主题文件夹\\node_modules\\hexo-theme-volantis\\layout\\下，ejs结尾的文件。 关于ejs写法请自行查找相关内容。 内容注入本主题支持在不修改主题文件的情况下向head和body中添加内容。 _config.yml123456import: head_begin: head_end: body_begin: body_end: # - &lt;script&gt;&lt;/script&gt; 注入内容可以是任意标签，也可以是JavaScript代码，不过需要注意的是，由于网页加载策略的原因，JavaScript代码只有在第一次打开网站的时候会执行，之后就会再次执行，除非刷新网页。 为了解决这个问题，本博客选择在布局文件中硬编入script标签。 本博客的代码块样式就是由代码生成替换。通过script标签引入后处理文件，这样每次打开界面都会执行代码。 article.ejs1234&lt;!--省略上面代码--&gt;&lt;/article&gt;&lt;script src = &quot;/script/AfterProcess.js&quot;&gt;&lt;/script&gt;&lt;!--省略下面代码--&gt; JavaScript代码界面美化（代码块、标题）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980window.AfterProcess = &#123; ResetCodeStyle: () =&gt; &#123; var eles = document.getElementsByClassName(&quot;highlight&quot;); var colors = [ &quot;#ed6a5e&quot;, &quot;#f5bd4f&quot;, &quot;#61c454&quot; ] for (let i = 0, len = eles.length; i &lt; len; i++) &#123; let child = eles[i].firstChild; //创建按钮 let customDiv = document.createElement(&quot;div&quot;); customDiv.style.display = &quot;flex&quot;; customDiv.style.height = &quot;40px&quot;; customDiv.style.width = &quot;100%&quot;; for (let j = 0; j &lt; 3; j++) &#123; let btn = document.createElement(&quot;div&quot;); btn.style.backgroundColor = colors[j]; btn.style.height = &quot;20px&quot;; btn.style.width = &quot;20px&quot;; btn.style.border = &quot;1px solid &quot; + colors[j]; btn.style.borderRadius = &quot;10px&quot;; btn.style.margin = &quot;10px 5px 10px 5px&quot;; customDiv.appendChild(btn); &#125; console.log(&quot;是否匹配&quot;, child.nodeName); if (child.nodeName != &quot;FIGCAPTION&quot;) &#123; //没有标题 eles[i].insertBefore(customDiv, child); &#125; else &#123; eles[i].replaceChild(customDiv, child); //有标题 let p = document.createElement(&quot;p&quot;); p.style.width = (customDiv.offsetWidth - 40 * 3) + &quot;px&quot;; p.style.height = &quot;40px&quot;; p.style.textAlign = &quot;center&quot;; p.style.margin = &quot;0px&quot;; p.style.lineHeight = &quot;40px&quot;; p.innerText = child.firstChild.innerText; p.style.fontSize = &quot;20px&quot;; customDiv.appendChild(p); &#125; &#125; &#125;, ResetTitle: ()=&gt;&#123; var eles = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;); var picker = window.getComputedStyle; for (let i = 1, len = eles.length; i &lt; len; i++) &#123; let child = eles[i].firstChild; let eleStyle = picker(eles[i]); //创建标识 let customDiv = document.createElement(&quot;div&quot;); customDiv.style.display = &quot;flex&quot;; customDiv.style.width = &quot;15px&quot;; customDiv.style.backgroundColor = &quot;#61c454&quot;; customDiv.style.height = eleStyle.fontSize; customDiv.style.marginRight = &quot;10px&quot;; customDiv.style.marginTop = (parseFloat(eleStyle.lineHeight) - parseFloat(eleStyle.fontSize)) * 0.5 + &quot;px&quot;; customDiv.style.borderRadius = &quot;5px&quot;; // console.log(&quot;字体大小&quot;,eleStyle.fontSize,parseFloat(eleStyle.lineHeight),parseFloat(eleStyle.fontSize)) // customDiv.style.verticalAlign eles[i].style.display = &quot;flex&quot;; eles[i].style.verticalAlign = &quot;center&quot; eles[i].insertBefore(customDiv, child); &#125; &#125;, Init: () =&gt; &#123; console.log(&quot;初始化界面&quot;); AfterProcess.ResetCodeStyle(); AfterProcess.ResetTitle(); &#125;&#125;AfterProcess.Init();","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"教程/Hexo","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/Hexo/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://busyogg.github.io/tags/Hexo/"}]},{"title":"Hexo博客搭建 基础篇","slug":"Hexo博客搭建-基础篇","date":"2023-08-31T20:09:13.000Z","updated":"2023-09-17T16:54:29.826Z","comments":true,"path":"article/e834ef617110/","link":"","permalink":"https://busyogg.github.io/article/e834ef617110/","excerpt":"","text":"基础介绍Hexo是一个快速、简洁且高效的博客框架，具有超快速度、支持 Markdown、一键部署、插件和可扩展性（引自官网简介）。 该框架可以部署到个人服务器或者GitHub上，本文主要是介绍如何部署到GitHub，以及配置的调整。 依赖Hexo博客需要安装相关依赖程序 Node.js Git 安装方法请自行查找。 Hexo安装Hexo博客利用Node.js的npm安装，我们打开cmd或者powershell，输入以下命令安装Hexo相关的工具 1npm install -g hexo-cli 然后我们使用以下命令创建我们的博客文件夹，其中folder代表要创建文件夹的路径，不指定的话默认在当前文件夹创建，然后我们进入文件夹开始创建我们的博客 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 如果出现无法加载文件 C:\\Users\\*\\AppData\\Roaming\\npm\\nodemon.ps1之类的报错，可以使用以下方法解决（参考链接）： 12Start-Process powershell -Verb runAsset-ExecutionPolicy RemoteSigned 或者进入项目文件夹，运行： 1npx nodemon run dev 现在我们的博客文件夹的雏形就创建好了。接下来就是把我们的博客部署到GitHub上了。 部署GitHub 首先我们要有一个GitHub的账号。 然后我们创建一个git仓库，用户名即你的git账户名 打开博客文件夹下的_comfig.yml，找到对应项目填入以下内容（没找到就自己写入）1234deploy:type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: main 安装Hexo的git工具1npm install --save hexo-deployer-git 打开git终端 输入以下命令，第一条为清空发布文件夹，第二条为生成发布文件夹，第三条为上传。123hexo clean hexo g hexo d 此时会遇到一个问题，err: Error: Spawn failed，我们需要去生成新 SSH 密钥，GitHub官方文档生成ssh，然后我们在git终端获取我们创建的 SSH 秘钥12cd ~/.sshcat id_rsa.pub 然后填入这个界面 New SSH key 接下来我们推送博客到GitHub上应该就没有问题了，推送后过一会儿我们就能通过 用户名.github.io 的链接访问博客了 基本命令官网文档 - 指令https://hexo.io/zh-cn/docs/commands 创建文章可以用如下命令来创建一个md后缀的markdown页面，这个命令还有其他按参数，具体可以查阅官网文档。 1hexo new &quot;文章名&quot; 其他项目相关的命令如下 运行本地服务器1hexo server 生成发布文件夹1hexo generate 部分文件使用要先生成才能链接成功 清除发布文件夹1hexo clean 发布到git1hexo d 本命令需要在git终端执行 配置修改除了上文提到的deploy设置外，我们还可以更改博客的一些信息 123456789# Sitetitle: 博客名subtitle: 副标题description: 简介keywords:author: 作者名language: zh-CNtimezone: &#x27;&#x27;favicon: /images/img_icon.png #网站图标 这里的图标我用了本地文件，在source文件夹下创建的images文件夹内的img_icon.png，在生成后路径会变成/public/images/img_icon.png，这里的public就是生成的文件夹，images前面加斜杠代表从根目录开始，否则会以打开的路径后面加图标路径。其他资源的调用也是类似的情况。这里也可以用网络路径。 其次就是文章访问路径的修改，默认是以时间+文章名作为访问路径，我们可以通过以下配置修改 123456url: https://busyogg.github.io/ #网址permalink: article/:category/:title/ #访问路径permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks 路径的规则为 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（不含前导零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（不含前导零） :hour 文章发表时的小时 (2 位数) :minute 文章发表时的分钟 (2 位数) :second 文章发表时的秒钟 (2 位数) :title 文件名称 (相对于 “source&#x2F;_posts&#x2F;“ 文件夹) :name 文件名称 :post_title 文章标题 :id 文章 ID (清除缓存时不具有持久性) :category 分类。如果文章没有分类，则是 default_category 配置 :hash 文件名（与 :title 相同）和日期的 SHA1 哈希值（12位16进制数） 路径开头不带斜杠，我路径的article为文章存放的根文件夹，可加可不加，可自定义名称，根据个人需求决定。 其他注意事项 所有对config文件的修改都需要重新执行 hexo server命令 source文件夹用于保存项目文件，对文章的修改可以实时更新，但要增加source文件夹下面的文件的话就需要重新执行hexo generate来生成文件 文章创建的样板文件为post.md，在scaffolds文件夹下，在创建文章的时候会帮你提前输入一些内容。其他样板文件同理。","categories":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"教程/Hexo","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/Hexo/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"https://busyogg.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://busyogg.github.io/tags/Hexo/"}]},{"title":"Unity Console控制台打印拓展工具","slug":"Unity-Console控制台打印拓展工具","date":"2023-08-28T11:23:58.000Z","updated":"2023-09-17T16:54:29.826Z","comments":true,"path":"article/ad277da9d73c/","link":"","permalink":"https://busyogg.github.io/article/ad277da9d73c/","excerpt":"","text":"简介本项目旨在展开console控制台打印的内容显示，减少打印对象内容未知的情况，同时简化多参数打印的调用。 本项目部分功能使用LitJson实现，数组、字典、json数据均会另起一行显示，其他数据之间会空一格显示 基本原理 利用params关键字，允许用户轻松打印不定数量的参数。 对部分变量类型进行手动序列化以在console控制台显示具体内容 整合所有参数最终的结果，拼为一个string并调用对应Debug方法打印 使用方法1234567891011121314151617181920212223//json数据string str = &quot;&#123; &#x27;a&#x27;:1 &#125;&quot;;JsonData jd = JsonMapper.ToObject(str);//字典内容Dictionary&lt;string, int[]&gt; testDic = new Dictionary&lt;string, int[]&gt;();testDic.Add(&quot;testA&quot;, new int[] &#123; 1, 2, 3 &#125;);testDic.Add(&quot;testB&quot;, new int[] &#123; 1 &#125;);//对象GameObject obj = new GameObject();obj.name = &quot;test_obj&quot;;//向量Vector3 vec = new Vector3();//对象object testObj = new object[] &#123; &quot;str1&quot;, 2 &#125;;//数组int[] ints = new int[] &#123; 1, 2, 3 &#125;;//输出测试ConsoleUtils.Log(&quot;输出通知内容1 ----- &quot;, ints, testObj, jd, testDic, obj, vec);ConsoleUtils.Warn(&quot;输出通知内容1 ----- &quot;, ints, testObj, jd, testDic, obj, vec);ConsoleUtils.Error(&quot;输出通知内容1 ----- &quot;, ints, testObj, jd, testDic, obj, vec); 运行效果 代码test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234using LitJson;using System;using UnityEngine;namespace Game&#123; public class ConsoleUtils &#123; private static string PrintDic(dynamic dic) &#123; string res = &quot;&#123; &quot;; foreach (dynamic data in dic) &#123; string key = data.Key.ToString(); string valueName = data.Value.GetType().Name; if (valueName.IndexOf(&quot;Dictionary&quot;) != -1) &#123; res += key + &quot;:&quot; + PrintDic(data.Value) + &quot;,&quot;; &#125; else if (valueName.IndexOf(&quot;List&quot;) != -1) &#123; res += key + &quot;:&quot; + PrintList(data.Value) + &quot;,&quot;; &#125; else &#123; res += key + &quot;:&quot; + data.Value.ToString() + &quot;,&quot;; &#125; &#125; res = res.Substring(0, res.Length - 1) + &quot; &#125;&quot;; return res; &#125; private static string PrintList(dynamic list) &#123; string res = &quot;[ &quot;; for(int i = 0,len = list.Count; i &lt; len; i++) &#123; string valueName = list[i].GetType().Name; if (valueName.IndexOf(&quot;Dictionary&quot;) != -1) &#123; res += PrintDic(list[i]) + &quot;,&quot;; &#125; else if (valueName.IndexOf(&quot;List&quot;) != -1) &#123; res += PrintList(list[i]) + &quot;,&quot;; &#125; else &#123; res += list[i].ToString() + &quot;,&quot;; &#125; &#125; res = res.Substring(0,res.Length - 1) + &quot; ]&quot;; return res; &#125; /// &lt;summary&gt; /// 打印到控制台 /// &lt;/summary&gt; /// &lt;param name=&quot;objs&quot;&gt;&lt;/param&gt; public static void Log(params object[] objs) &#123; string str = string.Empty; bool isWrap = false; foreach (object obj in objs) &#123; if (obj == null) continue; Type type = obj.GetType(); string extra = string.Empty; if (type.Name.IndexOf(&quot;[]&quot;) != -1) &#123; extra = &quot;,\\r\\n[ &quot;; Array objArray = (Array)obj; int i = 0; int len = objArray.Length; foreach (object data in objArray) &#123; extra += data.ToString() + (i == len - 1 ? string.Empty : &quot; , &quot;); i++; &#125; extra += &quot; ]&quot;; str += extra; isWrap = true; &#125; else if (type == typeof(JsonData)) &#123; string json = ((JsonData)obj).ToJson(); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;Dictionary&quot;) != -1) &#123; string json = PrintDic(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;List&quot;) != -1) &#123; string json = PrintList(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else &#123; if (isWrap) &#123; isWrap = false; str += &quot;,\\r\\n&quot;; &#125; str += obj.ToString() + &quot; &quot;; &#125; &#125; Debug.Log(str); &#125; public static void Warn(params object[] objs) &#123; string str = string.Empty; bool isWrap = false; foreach (object obj in objs) &#123; Type type = obj.GetType(); string extra = string.Empty; if (type.Name.IndexOf(&quot;[]&quot;) != -1) &#123; extra = &quot;,\\r\\n[ &quot;; Array objArray = (Array)obj; int i = 0; int len = objArray.Length; foreach (object data in objArray) &#123; extra += data.ToString() + (i == len - 1 ? string.Empty : &quot; , &quot;); i++; &#125; extra += &quot; ]&quot;; str += extra; isWrap = true; &#125; else if (type == typeof(JsonData)) &#123; string json = ((JsonData)obj).ToJson(); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;Dictionary&quot;) != -1) &#123; string json = PrintDic(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;List&quot;) != -1) &#123; string json = PrintList(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else &#123; if (isWrap) &#123; isWrap = false; str += &quot;\\r\\n&quot;; &#125; str += obj.ToString() + &quot; &quot;; &#125; &#125; Debug.LogWarning(str); &#125; public static void Error(params object[] objs) &#123; string str = string.Empty; bool isWrap = false; foreach (object obj in objs) &#123; Type type = obj.GetType(); string extra = string.Empty; if (type.Name.IndexOf(&quot;[]&quot;) != -1) &#123; extra = &quot;,\\r\\n[ &quot;; Array objArray = (Array)obj; int i = 0; int len = objArray.Length; foreach (object data in objArray) &#123; extra += data.ToString() + (i == len - 1 ? string.Empty : &quot; , &quot;); i++; &#125; extra += &quot; ]&quot;; str += extra; isWrap = true; &#125; else if (type == typeof(JsonData)) &#123; string json = ((JsonData)obj).ToJson(); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;Dictionary&quot;) != -1) &#123; string json = PrintDic(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else if (type.Name.IndexOf(&quot;List&quot;) != -1) &#123; string json = PrintList(obj); str += &quot;,\\r\\n&quot; + json; isWrap = true; &#125; else &#123; if (isWrap) &#123; isWrap = false; str += &quot;\\r\\n&quot;; &#125; str += obj.ToString() + &quot; &quot;; &#125; &#125; Debug.LogError(str); &#125; &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"Js/Ts缓动系统","slug":"Js-Ts缓动系统","date":"2023-08-24T13:45:16.000Z","updated":"2023-10-26T11:55:52.328Z","comments":true,"path":"article/923369eacdd4/","link":"","permalink":"https://busyogg.github.io/article/923369eacdd4/","excerpt":"","text":"基本原理概述缓动的基本原理很简单，就是设置一个初值和终值，在每帧更新的时候根据特定的缓动函数算出对应的中间值并插值。 本工具类分为4个部分：缓动工具类、缓动辅助类、缓动核心类、缓动时间类。同时，本工具提供链式调用，方便进行多个缓动动作的连续执行。 缓动工具类负责管理缓动的调用，以及一个作用域所有的缓动。 缓动辅助类负责管理单个缓动的初始化，同时也是链式调用的核心类。 缓动核心类负责管理具体的缓动逻辑，所以缓动都是通过该类执行。 缓动时间类负责管理缓动的更新调用，本项目托管到Laya的更新脚本上。 由于本类在设计之初是在Laya引擎运行，因此小部分代码依托Laya存在，使用的时候需要根据具体项目进行修改。 使用方法所有的操作均从缓动工具类调用，但首先在运行之前要执行TweenUtil.start()方法来初始化整个缓动工具的更新逻辑。 to和from方法表示两个不同的缓动类型，to为从当前状态到目标状态，from为从目标状态到当前状态。这两个方法都会返回一个 subTween 对象，我们可以以这个 subTween 对象进行链式调用，以点的方法重复调用to、from等方法。 例如： 12345678let obj = &#123; x:0 &#125;;TweenUtil.to(obj,&#123; x:1 &#125;,100).to(&#123; x:2 &#125;,100).to(&#123; x:3 &#125;,200); 此处执行了三个缓动，obj的x值从0到1到2再到3。三个缓动按照顺序执行一次。 同时，本项目也提供了循环执行缓动的功能，只需要在最后调用 loop() 方法，就可以对 loop 之前的所有步骤重复执行。另外，本项目也支持设置循环次数，只需要如下调用即可： 1234567891011121314151617let obj = &#123; x:0 &#125;;TweenUtil.to(obj,&#123; x:1 &#125;,100).to(&#123; x:2 &#125;,100).to(&#123; x:3 &#125;,200).loop();let obj2 = &#123; x:0 &#125;;TweenUtil.to(obj2,&#123; x:1 &#125;,100).to(&#123; x:2 &#125;,100).to(&#123; x:3 &#125;,200).loop(3); 如果存在两个loop，若前面的loop为无限循环，则后面的loop无法执行，若不是无限循环，则后面的loop会执行第一个loop到第二个loop之间的缓动行为，第一个loop之前的缓动行为全部舍弃。其他情况同理。 如果要清理缓动，有两种方法，一种是调用 TweenUtil.clear() 方法，传入一个缓动对象，则这个缓动对象会被清理，另一种是清理作用域上的所有缓动对象，调用 TweenUtil.clearAll() 方法，传入作用域，则该作用域上的所有缓动对象都会被清理。 特别注意，本项目目前不支持缓动对象池，因为有可能会出现引用bug，因此需要缓动对象池的话请自行实现。 缓动工具类原理本类内置3个变量 _tweenId ，_tweenDic ， _tweenClock _tweenId变量用于自增缓动id，也是缓动对象字典中的唯一标识符，每个作用域对应一个缓动id。 _tweenDic变量为缓动对象字典，用于存储缓动对象，结构为 { tweenId : SubTween[] } , key为缓动id，value为缓动辅助类数组，保存该作用域上的所有缓动对象。 _tweenClock变量为缓动核心类对象，在缓动核心类中会调用它来获取缓动时间类 本类的核心方法to和from的原理相同，方法分为两个部分： 创建一个缓动辅助类对象，设置对象的目标并且调用对应 to&#x2F;from 方法。 检查作用域的缓动id，如果不存在，则初始化缓动id，然后检查字典中是否存在对应id并把创建的对象保存到数组中，最后再返回这个对象。 清除缓动的原理则如下方详细代码所示。 缓动辅助类原理本类内置8个变量 target ， _listIndex ， _tweenList ， _tweening ， _tweenObj ， _tweenIndex ， _loop ， _limit target变量如名字所示，就是缓动的目标对象。 _listIndex变量用于缓动列表的索引，主要是区别各个loop缓动动作组，只有调用loop的情况下会增加。 _tweenList变量用于保存缓动动作，是一个二维数组，第一维保存缓动动作组，第二维保存缓动动作序列。 _tweening变量用于判断当前是否正在缓动 _tweenObj变量保存本类当前实例化的缓动核心类对象 _tweenIndex变量用于缓动序列的索引 _loop变量用于判断是否开启循环 _limit变量用于保存缓动循环次数限制，是个一维数组 本类的核心方法to和from的原理相同，方法分为两个部分： 保存缓动参数到 _tweenList[ _listIndex ] 数组中 如果缓动未启动，则启动缓动 本类最关键的，就是启动缓动的逻辑，具体逻辑如下图所示 本类的启动缓动，实际上就是上一个缓动动作和下一个缓动动作的连接，具体的缓动执行和结束，还得看缓动核心类。 缓动核心类原理本类内置11个变量 _target ， _prop ， _duration ， _ease ， _complete ， _delay ， _direction ， _isDone ， _time ， _def ， _isDelay _target变量如名字所示是缓动的对象 _prop变量保存需要缓动的所有属性 _duration变量是缓动的持续时间 _ease变量为缓动函数，所有缓动属性都需要通过该函数进行插值 _complete变量为回调函数，在缓动结束后执行，主要是执行缓动辅助类中的doTween _delay变量是缓动延迟时间，在延迟时间结束后才会开始执行缓动 _direction变量用于区分to和from _isDone变量用于标记是否完成缓动 _time变量用于记录当前缓动执行时间 _def变量用于保存缓动对象的原始属性 _isDelay变量用于标记是否延迟执行缓动 本类的to和from方法也是初始化传入的缓动参数，并且把本类对象推到缓动时间类的遍历列表中。 本类最关键的就是缓动每一帧更新的逻辑，具体逻辑如下图所示 注意，缓动函数的传参格式为： 经过时间，起始值，结束值，总时长，返回值为0到1的之间的数值 缓动时间类原理本类在当前示例中依托Laya更新，也可以自定义定时器来更新。核心逻辑主要就是update，遍历 _tweens ，先判断缓动核心对象是否结束缓动，结束缓动就移除，否则就执行 update 函数 ，传入 deltaTime 即 dt，单位为毫秒。 注意本类一般需要在整个项目中成为单例，不过本类并没有实现单例类，如果需要的话可自行实现。记得配合修改 TweenUtil.start 的内容。 代码缓动工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495export default class TweenUtil &#123; public static _tweenId = 1; public static _tweenDic = &#123;&#125;; private static _tweenClock: TweenClock; /** * 启动缓动工具类 本函数负责启动缓动时间类，函数体可根据需求自定义修改 */ public static start() &#123; let scriptScene = new Laya.Scene3D(); Laya.stage.addChild(scriptScene); this._tweenClock = scriptScene.addComponent(TweenClock); &#125; public static getTweenClock() &#123; return this._tweenClock; &#125; /** * to缓动 同Laya.Tween.to * @param target * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public static to(caller, target, prop, time, ease?, delay?, callback?) &#123; // console.log(&quot;缓动&quot;,target); let subTween = new SubTween(); subTween.target = target; subTween.to(prop, time, ease, delay, callback); if (!caller.tweenId) &#123; caller.tweenId = this._tweenId++; &#125; if (!this._tweenDic[caller.tweenId]) &#123; this._tweenDic[caller.tweenId] = []; &#125; this._tweenDic[caller.tweenId].push(subTween); return subTween; &#125; /** * from缓动 同Laya.Tween.to * @param target * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public static from(caller, target, prop, time, ease?, delay?, callback?) &#123; let subTween = new SubTween(); subTween.target = target; subTween.to(prop, time, ease, delay, callback); if (!caller.tweenId) &#123; caller.tweenId = this._tweenId++; &#125; if (!this.caller[caller.tweenId]) &#123; this.caller[caller.tweenId] = []; &#125; this._tweenDic[caller.tweenId].push(subTween); return subTween; &#125; /** * 清除目标缓动 * @param tweenObj */ public static clear(tweenObj: SubTween) &#123; tweenObj.clear(); &#125; /** * 清除目标节点所有缓动 * @param target */ public static clearAll(caller) &#123; // console.log(&quot;清除&quot;, caller) if (!this._tweenDic[caller.tweenId]) return; let len = this._tweenDic[caller.tweenId].length; for (let i = 0; i &lt; len; i++) &#123; (this._tweenDic[caller.tweenId][i] as SubTween).clear(); &#125; this._tweenDic[caller.tweenId] = []; &#125;&#125; 缓动辅助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152export class SubTween &#123; /** 目标节点 */ public target; /** 缓动列表索引 */ private _listIndex = 0; /** 缓动列表 */ private _tweenList; /** 是否正在缓动 */ private _tweening = false; /** 缓动对象 */ private _tweenObj: TweenCore; /** 缓动索引 */ private _tweenIndex = 0; /** 是否循环 */ private _loop = false; /** 缓动循环次数限制列表 */ private _limit:number[] = []; /** * 缓动 从现在属性到目标属性 * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public to(prop, time, ease?, delay?, callback?) &#123; if (!this._tweenList) &#123; this._tweenList = []; &#125; if (!this._tweenList[this._listIndex]) &#123; this._tweenList[this._listIndex] = []; &#125; this._tweenList[this._listIndex].push(&#123; prop: prop, time: time, ease: ease, delay: delay, callback: callback, type: 0 &#125;); this.startTween(); return this; &#125; /** * 缓动 从目标属性到现在属性 * @param prop * @param time * @param ease * @param delay * @param callback * @returns */ public from(prop, time, ease?, delay?, callback?) &#123; if (!this._tweenList) &#123; this._tweenList = []; &#125; if (!this._tweenList[this._listIndex]) &#123; this._tweenList[this._listIndex] = []; &#125; this._tweenList[this._listIndex].push(&#123; prop: prop, time: time, ease: ease, delay: delay, callback: callback, type: 1 &#125;); this.startTween(); return this; &#125; /** * 循环前面所有的动作 * @param 循环次数 不填或者0为无限循环 只有在非无限循环的情况下可以执行本次loop后面的缓动 */ public loop(limit = 0) &#123; this._loop = true; this._limit[this._listIndex] = limit - 1; this._listIndex++; return this; &#125; /** * 清除缓动 */ public clear() &#123; if (this._tweenObj) &#123; this._tweenObj.clear(); &#125; this._tweenList = null; return this; &#125; /** * 开始缓动 */ private startTween() &#123; if (!this._tweening) &#123; this._tweening = true; this.doTween(); &#125; &#125; /** * 执行缓动 */ private doTween() &#123; let self = this; if (!this._tweenList) return; let param = this._tweenList[0][this._tweenIndex++]; if (param) &#123; if (param.type == 0) &#123; this._tweenObj = new TweenCore(); this._tweenObj.to(this.target, param.prop, param.time, param.ease, () =&gt; &#123; param.callback &amp;&amp; param.callback(); self.doTween(); &#125;, param.delay); &#125; else &#123; this._tweenObj = new TweenCore(); this._tweenObj.from(this.target, param.prop, param.time, param.ease, () =&gt; &#123; param.callback &amp;&amp; param.callback(); self.doTween(); &#125;, param.delay); &#125; &#125; else &#123; if (this._loop) &#123; this._tweenIndex = 0; if (this._limit[0] == -1) &#123; this.doTween(); &#125; else &#123; if (this._limit[0] &gt; 0) &#123; this._limit[0]--; &#125; else &#123; this._tweenList.shift(); this._limit.shift(); this._listIndex--; if (this._tweenList.length == 0) &#123; this._tweenList = null; &#125; &#125; this.doTween(); &#125; &#125; else &#123; this._tweenList = null; this._limit = []; &#125; &#125; &#125;&#125; 缓动核心类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798export class TweenCore &#123; private _target; private _prop; private _duration; private _ease; private _complete; private _delay; private _direction; private _isDone; private _time = 0; private _def = &#123;&#125;; private _isDelay = false; public to(target: any, props: any, duration: number, ease?: Function | null, complete?, delay?: number) &#123; this._target = target; this._prop = props; this._duration = duration; this._ease = ease || Laya.Ease.linearInOut; this._complete = complete; this._delay = delay ? delay : 0; this._delay &amp;&amp; (this._isDelay = true); this._direction = 1; this._isDone = false; for (let key in this._prop) &#123; this._def[key] = this._target[key]; &#125; TweenUtil.getTweenClock().push(this); return this; &#125; public from(target: any, props: any, duration: number, ease?: Function | null, complete?, delay?: number) &#123; this._target = target; this._prop = props; this._duration = duration; this._ease = ease || Laya.Ease.linearInOut; this._complete = complete; this._delay = delay ? delay : 0; this._delay &amp;&amp; (this._isDelay = true); this._direction = 0; this._isDone = false; for (let key in this._prop) &#123; this._def[key] = this._target[key]; &#125; TweenUtil.getTweenClock().push(this); return this; &#125; public update(dt) &#123; if (this._target &amp;&amp; !this._isDone) &#123; //计算进度 this._time += dt; if (this._isDelay) &#123; if (this._time &gt;= this._delay) &#123; this._isDelay = false; this._time = 0; &#125; &#125; else &#123; if (this._time &gt; this._duration) &#123; this._time = this._duration; this._isDone = true; &#125; //更新 let ease = this._ease(this._time, 0, 1, this._duration); for (let key in this._prop) &#123; if (key == &quot;update&quot;) &#123; this._prop[key](); &#125; else &#123; this._target[key] = this._def[key] + (this._prop[key] - this._def[key]) * (this._direction ? ease : (1 - ease)); &#125; &#125; //结束回调 if (this._isDone) &#123; this.clear(); this._complete &amp;&amp; this._complete(); this._complete = null; &#125; &#125; &#125; &#125; public clear() &#123; TweenUtil.getTweenClock().sub(this); this._target = null; this._prop = null; this._duration = null; this._ease = null; this._delay = null; this._direction = null; this._isDone = null; this._time = 0; this._def = &#123;&#125;; this._isDelay = false; &#125; public getDone() &#123; return this._isDone; &#125;&#125; 缓动时钟类此处挂载到Laya上，也可以自定义更新逻辑 12345678910111213141516171819202122232425262728293031export class TweenClock extends Laya.Script3D &#123; private _tweens:TweenCore[] = []; onAwake() &#123; console.log(&quot;TweenClock启动&quot;) &#125; public push(tween) &#123; this._tweens.push(tween); &#125; public sub(tween) &#123; let index = this._tweens.indexOf(tween); index != -1 &amp;&amp; this._tweens.splice(index, 1); &#125; public onUpdate() &#123; let time = Laya.timer.delta; let tween: TweenCore; for (let i = this._tweens.length - 1; i &gt;= 0; i--) &#123; tween = this._tweens[i]; if (tween) &#123; if (tween.getDone()) &#123; this._tweens.splice(i, 1); continue; &#125; tween.update(time); &#125; &#125; &#125;&#125; Laya缓动函数参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186class Ease &#123; static linearNone(t, b, c, d) &#123; return c * t / d + b; &#125; static linearIn(t, b, c, d) &#123; return c * t / d + b; &#125; static linearInOut(t, b, c, d) &#123; return c * t / d + b; &#125; static linearOut(t, b, c, d) &#123; return c * t / d + b; &#125; static bounceIn(t, b, c, d) &#123; return c - Ease.bounceOut(d - t, 0, c, d) + b; &#125; static bounceInOut(t, b, c, d) &#123; if (t &lt; d * 0.5) return Ease.bounceIn(t * 2, 0, c, d) * .5 + b; else return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b; &#125; static bounceOut(t, b, c, d) &#123; if ((t /= d) &lt; (1 / 2.75)) return c * (7.5625 * t * t) + b; else if (t &lt; (2 / 2.75)) return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b; else if (t &lt; (2.5 / 2.75)) return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b; else return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b; &#125; static backIn(t, b, c, d, s = 1.70158) &#123; return c * (t /= d) * t * ((s + 1) * t - s) + b; &#125; static backInOut(t, b, c, d, s = 1.70158) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b; &#125; static backOut(t, b, c, d, s = 1.70158) &#123; return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b; &#125; static elasticIn(t, b, c, d, a = 0, p = 0) &#123; var s; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (!a || (c &gt; 0 &amp;&amp; a &lt; c) || (c &lt; 0 &amp;&amp; a &lt; -c)) &#123; a = c; s = p / 4; &#125; else s = p / Ease.PI2 * Math.asin(c / a); return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b; &#125; static elasticInOut(t, b, c, d, a = 0, p = 0) &#123; var s; if (t == 0) return b; if ((t /= d * 0.5) == 2) return b + c; if (!p) p = d * (.3 * 1.5); if (!a || (c &gt; 0 &amp;&amp; a &lt; c) || (c &lt; 0 &amp;&amp; a &lt; -c)) &#123; a = c; s = p / 4; &#125; else s = p / Ease.PI2 * Math.asin(c / a); if (t &lt; 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b; return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * .5 + c + b; &#125; static elasticOut(t, b, c, d, a = 0, p = 0) &#123; var s; if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3; if (!a || (c &gt; 0 &amp;&amp; a &lt; c) || (c &lt; 0 &amp;&amp; a &lt; -c)) &#123; a = c; s = p / 4; &#125; else s = p / Ease.PI2 * Math.asin(c / a); return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Ease.PI2 / p) + c + b); &#125; static strongIn(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125; static strongInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t * t * t + b; return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b; &#125; static strongOut(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125; static sineInOut(t, b, c, d) &#123; return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b; &#125; static sineIn(t, b, c, d) &#123; return -c * Math.cos(t / d * Ease.HALF_PI) + c + b; &#125; static sineOut(t, b, c, d) &#123; return c * Math.sin(t / d * Ease.HALF_PI) + b; &#125; static quintIn(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125; static quintInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t * t * t + b; return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b; &#125; static quintOut(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125; static quartIn(t, b, c, d) &#123; return c * (t /= d) * t * t * t + b; &#125; static quartInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t * t + b; return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b; &#125; static quartOut(t, b, c, d) &#123; return -c * ((t = t / d - 1) * t * t * t - 1) + b; &#125; static cubicIn(t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125; static cubicInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t * t + b; return c * 0.5 * ((t -= 2) * t * t + 2) + b; &#125; static cubicOut(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125; static quadIn(t, b, c, d) &#123; return c * (t /= d) * t + b; &#125; static quadInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * t * t + b; return -c * 0.5 * ((--t) * (t - 2) - 1) + b; &#125; static quadOut(t, b, c, d) &#123; return -c * (t /= d) * (t - 2) + b; &#125; static expoIn(t, b, c, d) &#123; return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001; &#125; static expoInOut(t, b, c, d) &#123; if (t == 0) return b; if (t == d) return b + c; if ((t /= d * 0.5) &lt; 1) return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b; return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b; &#125; static expoOut(t, b, c, d) &#123; return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b; &#125; static circIn(t, b, c, d) &#123; return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b; &#125; static circInOut(t, b, c, d) &#123; if ((t /= d * 0.5) &lt; 1) return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b; return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b; &#125; static circOut(t, b, c, d) &#123; return c * Math.sqrt(1 - (t = t / d - 1) * t) + b; &#125;&#125;Ease.HALF_PI = Math.PI * 0.5;Ease.PI2 = Math.PI * 2;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"}]},{"title":"Unity自定义事件系统","slug":"Unity自定义事件系统","date":"2023-08-24T09:03:15.000Z","updated":"2023-11-04T16:18:43.705Z","comments":true,"path":"article/2474251272a9/","link":"","permalink":"https://busyogg.github.io/article/2474251272a9/","excerpt":"","text":"基本原理在事件传递的过程中设置一个中间对象，负责管理监听者和发送者，以达到解耦合的目的。 首先我们定义一个方法来注册监听对象，该对象包含节点（即作用域）、事件名和事件函数，然后我们在事件触发的时候调用触发函数，来触发所有监听该事件的对象。触发函数包含事件名和参数。 此处我们以字典 _eventDictionary 来存储监听对象，以事件名作为字典的key，在字典里我们以作用域为key定义另一个字典，防止同名事件冲突以及同作用域事件重复添加。 同时，由于我们需要一个清除节点上所有事件的方法，因此我们单独设置一个字典 _eventNode 用来保存节点和事件的关系。在清除节点上所有事件的时候只需要遍历该字典 _eventNode 中对应作用域（传入的node）的事件并且从事件字典 _eventDictionary 中查找对应的事件对象及其作用域即可。 具体的调用过程如下图所示： 这就是最基本的事件系统。 粘性通知为了防止部分情况中出现通知不到位的情况（即先通知后监听），这里我们引入了粘性通知的功能。 此处我们定义一个字典 _stickyDic 来保存通知的内容，这里我们分为两种情况，一种情况是该粘性通知只需要通知一次，则我们只需要让新的通知覆盖旧的通知；另一种是需要多次通知，则我们设置一个数组来保存多次通知的内容，所以我们增设一个字典 _stickyArrayFlag 用于保存粘性通知类型。 粘性通知和普通通知的触发事件逻辑相似，可以说前半部分的代码和普通通知一样，只不过我们增设一个通知标识符，用于判断是否通知到位，若没有通知到位，则进入粘性通知内容保存的流程。 注册监听者的部分代码也有改动，在注册完成后，若从粘性通知字典 _stickyDic 取到对应事件名的内容，则立刻进行一次通知，通知结束后删除对应的内容。 简单来说，粘性通知就是在监听和通知这两个过程之后增加一个判断，对于监听者来说，就是要判断有无通知的内容，而对于通知来说，就是判断是否有监听者监听过该通知内容。 代码事件数据类1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections;namespace Game&#123; public class EventData &#123; private Action&lt;ArrayList&gt; _event = null; private string _eventName = string.Empty; public EventData(string eventName, Action&lt;ArrayList&gt; eventCallback) &#123; _eventName = eventName; _event = eventCallback; &#125; public void SetEventCallBack(Action&lt;ArrayList&gt; eventCallback) &#123; _event = eventCallback; &#125; public void RemoveEvent() &#123; _event = null; &#125; public void Triggered(ArrayList obj) &#123; if (_event != null) &#123; _event.Invoke(obj); &#125; &#125; &#125;&#125; 事件管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270using System;using System.Collections;using System.Collections.Generic;using UnityEngine;namespace Game&#123; public class EventManager &#123; /// &lt;summary&gt; /// 事件字典 /// &lt;/summary&gt; private static Dictionary&lt;string, Dictionary&lt;string, EventData&gt;&gt; _eventDictionary = new Dictionary&lt;string, Dictionary&lt;string, EventData&gt;&gt;(); /// &lt;summary&gt; /// 节点字典 /// &lt;/summary&gt; private static Dictionary&lt;string, Dictionary&lt;string, bool&gt;&gt; _eventNode = new Dictionary&lt;string, Dictionary&lt;string, bool&gt;&gt;(); /// &lt;summary&gt; /// 粘性通知字典 /// &lt;/summary&gt; private static Dictionary&lt;string, ArrayList&gt; _stickyDic = new Dictionary&lt;string, ArrayList&gt;(); /// &lt;summary&gt; /// 存储当前事件的粘性通知是否为队列通知 /// &lt;/summary&gt; private static Dictionary&lt;string, bool&gt; _stickyArrayFlag = new Dictionary&lt;string, bool&gt;(); /// &lt;summary&gt; /// 在需要监听某个事件的脚本中，调用这个方法来监听这个事件 /// &lt;/summary&gt; /// &lt;param name = &quot;id&quot;&gt;当前节点id&lt;/param&gt; /// &lt;param name=&quot;eventName&quot;&gt;事件名&lt;/param&gt; /// &lt;param name&quot;Action&quot;&gt;注册监听的函数&lt;/param&gt; public static void AddListening(string id, string eventName, Action&lt;ArrayList&gt; action) &#123; EventData eventData = null; if (!_eventDictionary.ContainsKey(eventName)) &#123; _eventDictionary.Add(eventName, new Dictionary&lt;string, EventData&gt;()); &#125; Dictionary&lt;string, EventData&gt; eventDic = _eventDictionary[eventName]; eventDic.TryGetValue(id, out eventData); if (eventData != null) &#123; eventData.SetEventCallBack(action); &#125; else &#123; eventData = new EventData(eventName, action); eventDic.Add(id, eventData); &#125; if (_eventNode.ContainsKey(id)) &#123; // _eventNode[id][eventName] = true; &#125; else &#123; Dictionary&lt;string, bool&gt; dicNode = new Dictionary&lt;string, bool&gt; &#123; &#123; id, true &#125; &#125;; _eventNode.Add(id, dicNode); &#125; //触发粘性通知 ArrayList stickyArray; _stickyDic.TryGetValue(eventName, out stickyArray); if (stickyArray != null) &#123; //有粘性通知的情况下一定能获取到是否为通知队列 bool isArray = _stickyArrayFlag[eventName]; if (isArray) &#123; for (int i = 0, len = stickyArray.Count; i &lt; len; i++) &#123; TriggerEvent(eventName, stickyArray[i] as ArrayList); &#125; &#125; else &#123; TriggerEvent(eventName, stickyArray); &#125; //完成通知，移除数据 _stickyArrayFlag.Remove(eventName); _stickyDic.Remove(eventName); &#125; &#125; /// &lt;summary&gt; /// 在不需要监听的时候停止监听 /// &lt;/summary&gt; /// &lt;param name = &quot;id&quot;&gt;当前节点id&lt;/param&gt; /// &lt;param name=&quot;eventName&quot;&gt;事件名&lt;/param&gt; public static void RemoveListening(string id, string eventName) &#123; EventData eventData = null; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(eventName, out eventDic); if (eventDic != null) &#123; eventDic.TryGetValue(id, out eventData); if (eventData != null) &#123; eventData.RemoveEvent(); //移除事件字典中的事件对应的作用域 eventDic.Remove(id); //如果事件字典中事件的作用域为0 则移除该事件 if (eventDic.Count &lt;= 0) &#123; _eventDictionary.Remove(eventName); &#125; //如果有事件存在，则一定在对应的node字典中存在 _eventNode[id].Remove(eventName); Debug.Log(&quot;移除事件&quot; + id + eventName); &#125; &#125; &#125; /// &lt;summary&gt; /// 移除节点上的所有事件 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;节点&lt;/param&gt; public static void RemoveAll(string id) &#123; if (_eventNode.ContainsKey(id)) &#123; foreach (var data in _eventNode[id]) &#123; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(data.Key, out eventDic); if (eventDic != null) &#123; EventData eventData = null; eventDic.TryGetValue(id, out eventData); if (eventData != null) &#123; //移除事件 eventData.RemoveEvent(); //移除事件字典中的事件对应的作用域 eventDic.Remove(id); //如果事件字典中事件的作用域为0 则移除该事件 if (eventDic.Count &lt;= 0) &#123; _eventDictionary.Remove(data.Key); &#125; &#125; &#125; &#125; //移除节点字典中的对应节点数据 _eventNode.Remove(id); &#125; &#125; /// &lt;summary&gt; /// 触发某个事件 /// &lt;/summary&gt; /// &lt;param name=&quot;eventName&quot;&gt;事件名&lt;/param&gt; /// &lt;param name=&quot;obj&quot;&gt;参数列表，可以为空，但是记得在回调函数里面对该参数进行判空处理&lt;/param&gt; public static void TriggerEvent(string eventName, ArrayList obj) &#123; if (_eventDictionary.ContainsKey(eventName)) &#123; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(eventName, out eventDic); if (eventDic != null) &#123; EventData triggerEvent = null; foreach (var data in eventDic) &#123; triggerEvent = data.Value; triggerEvent.Triggered(obj); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 粘性通知 /// &lt;/summary&gt; /// &lt;param name=&quot;eventName&quot;&gt;通知名&lt;/param&gt; /// &lt;param name=&quot;obj&quot;&gt;数据&lt;/param&gt; /// &lt;param name=&quot;isArray&quot;&gt;是否队列&lt;/param&gt; public static void TriggerEventSticky(string eventName, ArrayList obj, bool isArray = false) &#123; if (_eventDictionary.ContainsKey(eventName)) &#123; Dictionary&lt;string, EventData&gt; eventDic = null; _eventDictionary.TryGetValue(eventName, out eventDic); if (eventDic != null) &#123; EventData triggerEvent = null; foreach (var data in eventDic) &#123; triggerEvent = data.Value; triggerEvent.Triggered(obj); &#125; &#125; &#125; else &#123; //保存通知内容 bool arrayFlag; _stickyArrayFlag.TryGetValue(eventName, out arrayFlag); if (isArray) &#123; arrayFlag = true; ArrayList res; _stickyDic.TryGetValue(eventName, out res); if (res == null) &#123; res = new ArrayList(); _stickyDic.Add(eventName, res); _stickyArrayFlag.Add(eventName, arrayFlag); &#125; //else //&#123; // _stickyDic[eventName] = res; // _stickyArrayFlag[eventName] = arrayFlag; //&#125; res.Add(obj); &#125; else &#123; arrayFlag = false; if (_stickyDic.ContainsKey(eventName)) &#123; _stickyDic[eventName] = obj; &#125; else &#123; _stickyDic.Add(eventName, obj); &#125; if (arrayFlag) &#123; _stickyArrayFlag[eventName] = arrayFlag; &#125; else &#123; if (!_stickyArrayFlag.ContainsKey(eventName)) &#123; _stickyArrayFlag.Add(eventName, arrayFlag); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ## 其他版本 Laya版本","categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"}]},{"title":"Laya自定义事件系统","slug":"Laya自定义事件系统","date":"2023-08-23T15:18:02.000Z","updated":"2023-09-18T15:41:06.686Z","comments":true,"path":"article/1099d6589f61/","link":"","permalink":"https://busyogg.github.io/article/1099d6589f61/","excerpt":"","text":"基本原理在事件传递的过程中设置一个中间对象，负责管理监听者和发送者，以达到解耦合的目的。 首先我们定义一个方法来注册监听对象，该对象包含节点（即作用域）、事件名和事件函数，然后我们在事件触发的时候调用触发函数，来触发所有监听该事件的对象。触发函数包含事件名和参数。 此处我们以字典 _eventDic 来存储监听对象，以事件名作为字典的key，在字典里我们以作用域为key定义另一个字典，防止同名事件冲突以及同作用域事件重复添加。 同时，由于我们需要一个清除节点上所有事件的方法，因此我们单独设置一个字典 _nodeEventDic 用来保存节点和事件的关系。在清除节点上所有事件的时候只需要遍历该字典 _nodeEventDic 中对应作用域（传入的node）的事件并且从事件字典 _eventDic 中查找对应的事件对象及其作用域即可。 具体的调用过程如下图所示： 这就是最基本的事件系统。 粘性通知为了防止部分情况中出现通知不到位的情况（即先通知后监听），这里我们引入了粘性通知的功能。 此处我们定义一个字典 _stickyArr 来保存通知的内容，这里我们分为两种情况，一种情况是该粘性通知只需要通知一次，则我们只需要让新的通知覆盖旧的通知；另一种是需要多次通知，则我们设置一个数组来保存多次通知的内容。 粘性通知和普通通知的触发事件逻辑相似，可以说前半部分的代码和普通通知一样，只不过我们增设一个通知标识符，用于判断是否通知到位，若没有通知到位，则进入粘性通知内容保存的流程。 注册监听者的部分代码也有改动，在注册完成后，若从粘性通知字典 _stickyArr 取到对应事件名的内容，则立刻进行一次通知，通知结束后删除对应的内容。 简单来说，粘性通知就是在监听和通知这两个过程之后增加一个判断，对于监听者来说，就是要判断有无通知的内容，而对于通知来说，就是判断是否有监听者监听过该通知内容。 代码事件数据类123456789101112export default class EventInfo &#123; public node; public event: Function; public type: string; constructor(node, type: string, event: Function) &#123; this.node = node; this.event = event; this.type = type; &#125;&#125; 事件管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import EventInfo from &quot;../bean/EventInfo&quot;;export default class EventManager &#123; /** 事件id */ private static _eventId = 1; /** 事件字典 类型-节点-事件 */ private static _eventDic = &#123;&#125;; /** 节点对应事件 节点-事件 */ private static _nodeEventDic = &#123;&#125;; /** 粘性通知字典 */ private static _stickyArr = &#123;&#125;; /** * 发送监听 * @param type 监听类型 * @param data 发送的数据 */ public static dispatchEvent(type, data): void &#123; for (let key in this._eventDic[type]) &#123; let event = this._eventDic[type][key] as EventInfo; event.event.call(event.node, data); &#125; &#125; /** * 粘性通知 * @param type * @param data */ public static dispatchEventSticky(type, data, isArr?) &#123; let eventOk = false; //普通通知部分 for (let key in this._eventDic[type]) &#123; let event = this._eventDic[type][key] as EventInfo; event.event.call(event.node, data); eventOk = true; &#125; //如果没有执行普通通知，则保存通知内容 if (!eventOk) &#123; if (isArr) &#123; if (!this._stickyArr[type]) &#123; this._stickyArr[type] = []; &#125; this._stickyArr[type].push(data); &#125; else &#123; this._stickyArr[type] = data; &#125; &#125; &#125; /** * 注册监听 * @param node 监听的节点 * @param type 监听类型 * @param event 监听事件 */ public static onEvent(node, type: string, event: Function) &#123; var obj = new EventInfo(node, type, event); if (!this._eventDic[type]) &#123; this._eventDic[type] = &#123;&#125;; &#125; //如果节点上没有事件id，则添加 if (node.eventId == undefined) &#123; node.eventId = &quot;event_&quot; + this._eventId++; &#125; //添加事件 this._eventDic[type][node.eventId] = obj; //获取粘性通知数据 let data = this._stickyArr[type]; if (data) &#123; //根据是否数组决定是否多次执行事件 if (data.length) &#123; let event = this._eventDic[type][node.eventId] as EventInfo; for (let i = 0, len = data.length; i &lt; len; i++) &#123; event.event.call(event.node, data[i]); &#125; delete this._stickyArr[type]; &#125; else &#123; let event = this._eventDic[type][node.eventId] as EventInfo; event.event.call(event.node, data); delete this._stickyArr[type]; &#125; &#125; //汇总节点上的所有事件 if (!this._nodeEventDic[node.eventId]) &#123; this._nodeEventDic[node.eventId] = &#123;&#125;; &#125; this._nodeEventDic[node.eventId][type] = true; &#125; /** * 清除某一节点上的所有监听 * @param node */ public static offAllEventByNode(node) &#123; if (!node || !this._nodeEventDic[node.eventId]) return; for (let key in this._nodeEventDic[node.eventId]) &#123; delete this._eventDic[key][node.eventId]; if (Object.keys(this._eventDic[key]).length == 0) &#123; delete this._eventDic[key]; &#125; &#125; delete this._nodeEventDic[node.eventId]; &#125;&#125; 其他版本Unity版本","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"}]},{"title":"关于Laya对接微信开放域的问题","slug":"关于Laya对接微信开放域的问题","date":"2023-08-23T15:09:11.000Z","updated":"2024-01-23T11:46:49.228Z","comments":true,"path":"article/fcfc4d29d0e4/","link":"","permalink":"https://busyogg.github.io/article/fcfc4d29d0e4/","excerpt":"","text":"Laya对接微信开放域可以新建开放域项目来创建一个范例，开放域项目打包的时候不会打包资源文件，因此要在主域提前加载对应的资源文件并传递给开放域，能传递的有两种类型，一是ui图集，二是json，亮着调用不同接口例： 12345Laya.loader.load(&quot;res/atlas/rank.atlas&quot;,Laya.Handler.create(this,(res)=&gt;&#123; Laya.MiniAdpter.sendAtlasToOpenDataContext(&quot;res/atlas/rank.atlas&quot;); //json //Laya.MiniAdpter.sendJsonDataToDataContext()&#125;)); 展示子域的时候laya会自动设置canvas，但是子域一旦有嵌套层级，该方法就会产生偏移，解决方法为： 调整子域对象层级到根层级 手动触发changeMatrix事件。注意，如果手动触发该事件，则需要按照源码对应的格式构造传递的参数。例： 123456789101112//此处canvasData为自定义对象，包含matrix，width，height三个属性，可以不需要按照此处代码构建对象，但一定要传入对应属性的参数this.openData.postMsg(&#123; type: &quot;changeMatrix&quot;, a: canvasData.matrix.a, b: canvasData.matrix.b, c: canvasData.matrix.c, d: canvasData.matrix.d, tx: canvasData.matrix.tx, ty: canvasData.matrix.ty, w: canvasData.width, h: canvasData.height,&#125;); 注意，如果要手动触发该事件，则需要延迟一帧的时间，防止UI界面还没有自动适配好宽高导致传入的canvas坐标偏移","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"解决方案","slug":"Laya/解决方案","permalink":"https://busyogg.github.io/categories/Laya/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"微信开放域","slug":"微信开放域","permalink":"https://busyogg.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%9F%9F/"},{"name":"解决方案","slug":"解决方案","permalink":"https://busyogg.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"关于LAYA编译await/async语法报错的问题","slug":"关于LAYA编译await-async语法报错的问题","date":"2023-08-23T14:52:19.000Z","updated":"2023-09-18T12:54:15.652Z","comments":true,"path":"article/810371225f39/","link":"","permalink":"https://busyogg.github.io/article/810371225f39/","excerpt":"","text":"在项目中安装tslib即可，可以在vscode终端中输入npm install tslib 或者在tsconfig.js中配置添加lib，promise（未测试）","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"Bug","slug":"Laya/Bug","permalink":"https://busyogg.github.io/categories/Laya/Bug/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Bug","slug":"Bug","permalink":"https://busyogg.github.io/tags/Bug/"}]},{"title":"Jszip在Laya引擎上的应用","slug":"Jszip在Laya引擎上的应用","date":"2023-08-23T13:17:56.000Z","updated":"2023-09-18T12:52:57.259Z","comments":true,"path":"article/47f96467aabe/","link":"","permalink":"https://busyogg.github.io/article/47f96467aabe/","excerpt":"","text":"小游戏平台对于资源的大小限制很严格， 在OV平台上，由于快游戏本身自带压缩机制，所以包体大小的问题相对不是那么严重。在微信平台上，包体是没有压缩的。一般来说有两种解决方案， 一个是把资源放在云端，还有一个就是压缩本地资源。 在资源很多但又不是那么多的情况下，我们可以采用压缩包的方式存储资源。有的平台有文件读写的接口，有的没有。为了通用性，我们采取解压到内存中的方式。通过jszip，我们可以很好的压缩和解压文件。 Laya引擎中有多重不同的文件格式，解压压缩文件到内存中的时候其实就是读取文件并格式化，然后保存到Laya的缓存系统中，通过缓存读取文件的时候就能够直接读取到我们解压到内存中的内容。不过，由于机制问题，暂时还不支持天空盒的格式化，因此天空盒目前还只能放在本地。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295export default class ZipManager &#123; private static instance: ZipManager; public static getInstance(): ZipManager &#123; if (!this.instance) &#123; return new ZipManager(); &#125; return this.instance; &#125; public loadZip(resurl: string, cacheUrl: string, callback: Function): void &#123; var zip = Laya.loader.getRes(resurl); if (!zip) &#123; Laya.loader.load([&#123; type: Laya.Loader.BUFFER, url: resurl &#125;], Laya.Handler.create(this, function (data) &#123; Laya.loader.cacheRes(cacheUrl, Laya.loader.getRes(resurl)); Laya.loader.clearRes(resurl); if (callback) &#123; callback(); &#125; &#125;)); &#125; else &#123; callback(); &#125; &#125; public loadZipFiles(resUrl: string, cacheUrl: string, callback: Function): void &#123; // console.log(&quot;0----------&quot;,Laya.Browser.window); var self = this; let skyBox; let jsZip = new JSZip(); let zipBuff = Laya.loader.getRes(resUrl); let resources = &#123;&#125;; // console.log(&quot;测试压缩包&quot;); var loadZipComplete = function () &#123; Laya.loader.clearRes(resUrl); callback(); &#125;; //获取ZIP包内容传入JSZip中解析 jsZip.loadAsync(zipBuff).then( (data =&gt; &#123; //保存文件路径到数组 for (let file in data.files) &#123; // console.log(&quot;------------file&quot;, data.files[file]); if (!data.files[file].dir) &#123; if (file.indexOf(&quot;.lh&quot;) != -1) &#123; //存入模型文件 if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; else if (file.indexOf(&quot;.png&quot;) != -1 || file.indexOf(&quot;.jpg&quot;) != -1) &#123; //存入图片 if (!resources[&quot;image&quot;]) &#123; resources[&quot;image&quot;] = []; &#125; resources[&quot;image&quot;].push(file); &#125; else if (file.indexOf(&quot;.json&quot;) != -1) &#123; //存入json if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; else if (file.indexOf(&quot;.csv&quot;) != -1) &#123; //存入csv if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; else if (file.indexOf(&quot;.lm&quot;) != -1 || file.indexOf(&quot;.ltc&quot;) != -1 || file.indexOf(&quot;.lmat&quot;) != -1 || //存入网格 天空盒材质解析文件 材质 file.indexOf(&quot;.lani&quot;) != -1) &#123; if (!resources[&quot;mat&quot;]) &#123; resources[&quot;mat&quot;] = []; &#125; if (file.indexOf(&quot;.ltc&quot;) != -1) &#123; let fileParts = file.split(&quot;/&quot;); let name = fileParts[fileParts.length - 1].replace(&quot;.ltc&quot;, &quot;&quot;); skyBox = name; &#125; resources[&quot;mat&quot;].push(file); &#125; else &#123; //存入其他 if (!resources[&quot;other&quot;]) &#123; resources[&quot;other&quot;] = []; &#125; resources[&quot;other&quot;].push(file); &#125; &#125; &#125; loadImage(); &#125;)); //格式化文件并存入缓存 let subCount = 0; let subTotal = 0; let loadImage = () =&gt; &#123; if (resources[&quot;image&quot;]) &#123; for (let key in resources[&quot;image&quot;]) &#123; subTotal++; let file = resources[&quot;image&quot;][key]; jsZip.file(file).async(&quot;base64&quot;).then((content: any) =&gt; &#123; let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; let imgBase64; if (file.indexOf(&quot;.png&quot;) != -1) &#123; imgBase64 = &quot;data:image/png;base64,&quot; + content; &#125; else &#123; imgBase64 = &quot;data:image/jpg;base64,&quot; + content; &#125; let image: HTMLImageElement = document.createElement(&quot;img&quot;); let onImageLoaded: EventListenerOrEventListenerObject = () =&gt; &#123; image.removeEventListener(&quot;load&quot;, onImageLoaded); //接下来就可以把贴图对象赋值给材质了 if (skyBox &amp;&amp; file.indexOf(skyBox) != -1) &#123; // skyBox = null; Laya.loader.cacheRes(cacheUrl + &quot;/&quot; + file, image); &#125; else &#123; let texture: Laya.Texture2D = new Laya.Texture2D(); texture.loadImageSource(image); Laya.loader.cacheRes(cacheUrl + &quot;/&quot; + file, texture); // console.log(&quot;图片纹理&quot;, Laya.loader.getRes(cacheUrl + &quot;/&quot; + file)); &#125; subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadLm(); &#125; &#125;; image.addEventListener(&quot;load&quot;, onImageLoaded); image.src = imgBase64; &#125;); &#125; &#125; else &#123; loadLm(); &#125; &#125; let loadLm = () =&gt; &#123; if (resources[&quot;mat&quot;]) &#123; for (let key in resources[&quot;mat&quot;]) &#123; subTotal++; let file = resources[&quot;mat&quot;][key]; if (file.indexOf(&quot;.ltc&quot;) != -1) &#123; jsZip.file(file).async(&quot;text&quot;).then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create(cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadOther(); &#125; &#125;)); &#125;); &#125; else if (file.indexOf(&quot;.lmat&quot;) != -1) &#123; jsZip.file(file).async(&quot;text&quot;).then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create(cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;,file, rses); subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadOther(); &#125; &#125;)); &#125;); &#125; else &#123; jsZip.file(file).async(&quot;uint8array&quot;).then((content: any) =&gt; &#123; let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; data.json[cacheUrl + &quot;/&quot; + file] = content; func.call(Laya.Loader, data); Laya.loader.create(cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; subCount = 0; subTotal = 0; loadOther(); &#125; &#125;)); &#125;); &#125; &#125; &#125; else &#123; loadOther(); &#125; &#125; let loadOther = () =&gt; &#123; for (let key in resources[&quot;other&quot;]) &#123; subTotal++; let file = resources[&quot;other&quot;][key]; if (file.indexOf(&quot;.lh&quot;) != -1) &#123; jsZip.file(file).async(&quot;text&quot;).then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create(cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;,file, res); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;)); &#125;); &#125; else if (file.indexOf(&quot;.json&quot;) != -1) &#123; jsZip.file(file).async(&quot;text&quot;).then((content: any) =&gt; &#123; let contJson = JSON.parse(content); let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; data.json[cacheUrl + &quot;/&quot; + file] = contJson; func.call(Laya.Loader, data); Laya.loader.create(cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;)); &#125;); &#125; else if (file.indexOf(&quot;.csv&quot;) != -1) &#123; jsZip.file(file).async(&quot;text&quot;).then((content: any) =&gt; &#123; Laya.loader.cacheRes(cacheUrl + &quot;/&quot; + file, content); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;); &#125; else &#123; jsZip.file(file).async(&quot;uint8array&quot;).then((content: any) =&gt; &#123; let func = Laya.Loader.prototype[&quot;parsePLFData&quot;]; let data = &#123; json: &#123;&#125;, text: &#123;&#125; &#125; data.json[cacheUrl + &quot;/&quot; + file] = content; func.call(Laya.Loader, data); Laya.loader.create(cacheUrl + &quot;/&quot; + file, Laya.Handler.create(this, (res) =&gt; &#123; // console.log(&quot;预加载&quot;, res); subCount++; if (subCount == subTotal) &#123; loadZipComplete(); &#125; &#125;)); &#125;); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Jszip","slug":"Jszip","permalink":"https://busyogg.github.io/tags/Jszip/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"}]},{"title":"Laya进度条shader","slug":"Laya进度条shader","date":"2023-08-23T13:17:56.000Z","updated":"2023-09-18T12:51:18.326Z","comments":true,"path":"article/23513e7655b5/","link":"","permalink":"https://busyogg.github.io/article/23513e7655b5/","excerpt":"","text":"原理 根据传入的进度[0,1]剔除对应颜色值RGB之一的像素，上图为进度条所需的从颜色值0到颜色值1的贴图（透明底图，进度条的圈为从白到黑的不透明圆环）。 此代码负责剔除一定颜色值的像素，利用step函数的原理（step(a,b)，当b&gt;&#x3D;a时返回1，否则返回0），其中1.0-col.r决定进度条动画的方向，代表从白向黑，也可以直接使用col.r从黑向白。 1float colorMinus = step(1.0-col.r,u_progress); 这段代码包括两个部分，前面的部分决定进度条的颜色，后面的部分决定背景的颜色，我们可以从加号的地方拆开来看。前面的部分构造了一个三维向量，假如colorMinus为1，则前面的向量就是全1，此时和传入的进度条颜色值相乘可得进度条的颜色。后面构造了一个和前面相反的三维向量，此时后面的向量为全0，和传入的背景颜色相乘依然是0。 由此可得，当此处的像素筛选为进度条的时候，进度条的颜色值发挥作用，而背景颜色值不发挥作用；相反，此处像素筛选为背景时，进度条颜色值不发挥作用而背景颜色值发挥作用。为什么要这么做呢，因为GPU运算的时候是大量并行的，条件判断语句对于GPU来说每个分支都要执行，性能会有损失。 12vec4 final = vec4(colorMinus);final.xyz = vec3(colorMinus) * u_edgeColor.xyz + vec3(1.0-colorMinus) * u_bgColor.xyz; 只有上述代码的话，运行时的效果并不能符合我们的需要，进度条之外的像素也会有填充。因此我们需要对透明度进行剔除。 1final.a = (step(1.0-col.a,0.0) * colorMinus * u_edgeColor.a) + step(colorMinus,0.0) * u_bgColor.a; 由于我们支持自定义进度条和进度条背景的透明度，因此这两个部分也需要进行处理。 关于进度条的透明度，起判断的部分只有colorMinus * u_edgeColor.a。为什么要乘上step(1.0-col.a,0.0)呢，主要是为了筛去透明的部分，col.a是原材质贴图的透明度，当其为1的时候（不透明）所得值为0，step(1.0-col.a,0.0)的值才为1，进度条的颜色才生效。当然这里可以设置为你所需要的任意值。 关于背景的透明度，和进度条同理可得step(colorMinus,0.0) * u_bgColor.a。 进度条shader代码片元着色器12345678910111213141516171819202122#ifdef FSHIGHPRECISION precision highp float;#else precision mediump float;#endifuniform sampler2D u_DiffuseTexture;uniform float u_progress;uniform vec4 u_edgeColor;uniform vec4 u_bgColor;varying vec2 v_Texcoord0; void main()&#123; vec4 col = texture2D(u_DiffuseTexture, v_Texcoord0); float colorMinus = step(1.0-col.r,u_progress); vec4 final = vec4(colorMinus); final.xyz = vec3(colorMinus) * u_edgeColor.xyz + vec3(1.0-colorMinus) * u_bgColor.xyz; final.a = (step(1.0-col.a,0.0) * colorMinus * u_edgeColor.a) + step(colorMinus,0.0) * u_bgColor.a; gl_FragColor = final; &#125; 顶点着色器1234567891011121314#include &quot;Lighting.glsl&quot;; attribute vec4 a_Position;attribute vec2 a_Texcoord0;varying vec2 v_Texcoord0; uniform mat4 u_MvpMatrix; uniform vec4 u_TilingOffset;void main() &#123; v_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset); gl_Position=remapGLPositionZ(gl_Position); &#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"Shader","slug":"Laya/Shader","permalink":"https://busyogg.github.io/categories/Laya/Shader/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"Opengl","slug":"Opengl","permalink":"https://busyogg.github.io/tags/Opengl/"}]},{"title":"关于Laya 2.13版本 粒子特效内存泄漏问题","slug":"关于Laya-2-13版本-粒子特效内存泄漏问题","date":"2023-08-23T13:17:56.000Z","updated":"2023-09-18T12:54:37.048Z","comments":true,"path":"article/07675fbaf5d8/","link":"","permalink":"https://busyogg.github.io/article/07675fbaf5d8/","excerpt":"","text":"该版本的粒子有两类，支持GPUInstance的ShurikenParticleInstance和ShurikenParticle，前者在不停创建销毁的过程中在统计面板上会累计内存增长，看上去和内存泄漏一样。其原因为销毁对象的时候没有对_instanceParticleVertexBuffer对象进行内存统计。 解决方案 在 destroy()方法中针对_instanceParticleVertexBuffer改为如下内容 123456if (this._instanceParticleVertexBuffer) &#123; var memorySize = this._instanceParticleVertexBuffer._byteLength; Laya.Resource._addMemory(-memorySize, -memorySize); this._instanceParticleVertexBuffer.destroy(); this._instanceParticleVertexBuffer = null;&#125;","categories":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"Bug","slug":"Laya/Bug","permalink":"https://busyogg.github.io/categories/Laya/Bug/"}],"tags":[{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Bug","slug":"Bug","permalink":"https://busyogg.github.io/tags/Bug/"}]}],"categories":[{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/categories/Unity/"},{"name":"解决方案","slug":"Unity/解决方案","permalink":"https://busyogg.github.io/categories/Unity/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"设计思路","slug":"设计思路","permalink":"https://busyogg.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"},{"name":"分享","slug":"分享","permalink":"https://busyogg.github.io/categories/%E5%88%86%E4%BA%AB/"},{"name":"工具","slug":"Unity/工具","permalink":"https://busyogg.github.io/categories/Unity/%E5%B7%A5%E5%85%B7/"},{"name":"编辑器","slug":"Unity/编辑器","permalink":"https://busyogg.github.io/categories/Unity/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/categories/Laya/"},{"name":"工具","slug":"Laya/工具","permalink":"https://busyogg.github.io/categories/Laya/%E5%B7%A5%E5%85%B7/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"逆向运动学","slug":"算法/逆向运动学","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"碰撞检测","slug":"算法/碰撞检测","permalink":"https://busyogg.github.io/categories/%E7%AE%97%E6%B3%95/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"教程/Hexo","permalink":"https://busyogg.github.io/categories/%E6%95%99%E7%A8%8B/Hexo/"},{"name":"解决方案","slug":"Laya/解决方案","permalink":"https://busyogg.github.io/categories/Laya/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Bug","slug":"Laya/Bug","permalink":"https://busyogg.github.io/categories/Laya/Bug/"},{"name":"Shader","slug":"Laya/Shader","permalink":"https://busyogg.github.io/categories/Laya/Shader/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://busyogg.github.io/tags/C/"},{"name":"定点数","slug":"定点数","permalink":"https://busyogg.github.io/tags/%E5%AE%9A%E7%82%B9%E6%95%B0/"},{"name":"确定性","slug":"确定性","permalink":"https://busyogg.github.io/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7/"},{"name":"Unity","slug":"Unity","permalink":"https://busyogg.github.io/tags/Unity/"},{"name":"解决方案","slug":"解决方案","permalink":"https://busyogg.github.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"渲染","slug":"渲染","permalink":"https://busyogg.github.io/tags/%E6%B8%B2%E6%9F%93/"},{"name":"物理","slug":"物理","permalink":"https://busyogg.github.io/tags/%E7%89%A9%E7%90%86/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://busyogg.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"服务器","slug":"服务器","permalink":"https://busyogg.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"FRP","slug":"FRP","permalink":"https://busyogg.github.io/tags/FRP/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://busyogg.github.io/tags/ChatGPT/"},{"name":"工具类","slug":"工具类","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"name":"编辑器","slug":"编辑器","permalink":"https://busyogg.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"Laya","slug":"Laya","permalink":"https://busyogg.github.io/tags/Laya/"},{"name":"Typescript","slug":"Typescript","permalink":"https://busyogg.github.io/tags/Typescript/"},{"name":"系统架构","slug":"系统架构","permalink":"https://busyogg.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"UI","slug":"UI","permalink":"https://busyogg.github.io/tags/UI/"},{"name":"算法","slug":"算法","permalink":"https://busyogg.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"IK","slug":"IK","permalink":"https://busyogg.github.io/tags/IK/"},{"name":"Fabrik","slug":"Fabrik","permalink":"https://busyogg.github.io/tags/Fabrik/"},{"name":"碰撞检测","slug":"碰撞检测","permalink":"https://busyogg.github.io/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"},{"name":"AABB","slug":"AABB","permalink":"https://busyogg.github.io/tags/AABB/"},{"name":"OBB","slug":"OBB","permalink":"https://busyogg.github.io/tags/OBB/"},{"name":"射线","slug":"射线","permalink":"https://busyogg.github.io/tags/%E5%B0%84%E7%BA%BF/"},{"name":"圆","slug":"圆","permalink":"https://busyogg.github.io/tags/%E5%9C%86/"},{"name":"SAT分离轴","slug":"SAT分离轴","permalink":"https://busyogg.github.io/tags/SAT%E5%88%86%E7%A6%BB%E8%BD%B4/"},{"name":"工具","slug":"工具","permalink":"https://busyogg.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ECS","slug":"ECS","permalink":"https://busyogg.github.io/tags/ECS/"},{"name":"四叉树","slug":"四叉树","permalink":"https://busyogg.github.io/tags/%E5%9B%9B%E5%8F%89%E6%A0%91/"},{"name":"空间管理","slug":"空间管理","permalink":"https://busyogg.github.io/tags/%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"},{"name":"SSL证书","slug":"SSL证书","permalink":"https://busyogg.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"},{"name":"教程","slug":"教程","permalink":"https://busyogg.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"https://busyogg.github.io/tags/GitHub/"},{"name":"网络加速","slug":"网络加速","permalink":"https://busyogg.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8A%A0%E9%80%9F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://busyogg.github.io/tags/Hexo/"},{"name":"微信开放域","slug":"微信开放域","permalink":"https://busyogg.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%94%BE%E5%9F%9F/"},{"name":"Bug","slug":"Bug","permalink":"https://busyogg.github.io/tags/Bug/"},{"name":"Jszip","slug":"Jszip","permalink":"https://busyogg.github.io/tags/Jszip/"},{"name":"Shader","slug":"Shader","permalink":"https://busyogg.github.io/tags/Shader/"},{"name":"Opengl","slug":"Opengl","permalink":"https://busyogg.github.io/tags/Opengl/"}]}